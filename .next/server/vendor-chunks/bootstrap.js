/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bootstrap";
exports.ids = ["vendor-chunks/bootstrap"];
exports.modules = {

/***/ "(ssr)/./node_modules/bootstrap/dist/js/bootstrap.bundle.js":
/*!************************************************************!*\
  !*** ./node_modules/bootstrap/dist/js/bootstrap.bundle.js ***!
  \************************************************************/
/***/ (function(module) {

eval("/*!\r\n  * Bootstrap v5.3.3 (https://getbootstrap.com/)\r\n  * Copyright 2011-2024 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\r\n  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n  */\r\n(function (global, factory) {\r\n   true ? module.exports = factory() :\r\n  0;\r\n})(this, (function () { 'use strict';\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap dom/data.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const elementMap = new Map();\r\n  const Data = {\r\n    set(element, key, instance) {\r\n      if (!elementMap.has(element)) {\r\n        elementMap.set(element, new Map());\r\n      }\r\n      const instanceMap = elementMap.get(element);\r\n\r\n      // make it clear we only want one instance per element\r\n      // can be removed later when multiple key/instances are fine to be used\r\n      if (!instanceMap.has(key) && instanceMap.size !== 0) {\r\n        // eslint-disable-next-line no-console\r\n        console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);\r\n        return;\r\n      }\r\n      instanceMap.set(key, instance);\r\n    },\r\n    get(element, key) {\r\n      if (elementMap.has(element)) {\r\n        return elementMap.get(element).get(key) || null;\r\n      }\r\n      return null;\r\n    },\r\n    remove(element, key) {\r\n      if (!elementMap.has(element)) {\r\n        return;\r\n      }\r\n      const instanceMap = elementMap.get(element);\r\n      instanceMap.delete(key);\r\n\r\n      // free up element references if there are no instances left for an element\r\n      if (instanceMap.size === 0) {\r\n        elementMap.delete(element);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap util/index.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n  const MAX_UID = 1000000;\r\n  const MILLISECONDS_MULTIPLIER = 1000;\r\n  const TRANSITION_END = 'transitionend';\r\n\r\n  /**\r\n   * Properly escape IDs selectors to handle weird IDs\r\n   * @param {string} selector\r\n   * @returns {string}\r\n   */\r\n  const parseSelector = selector => {\r\n    if (selector && window.CSS && window.CSS.escape) {\r\n      // document.querySelector needs escaping to handle IDs (html5+) containing for instance /\r\n      selector = selector.replace(/#([^\\s\"#']+)/g, (match, id) => `#${CSS.escape(id)}`);\r\n    }\r\n    return selector;\r\n  };\r\n\r\n  // Shout-out Angus Croll (https://goo.gl/pxwQGp)\r\n  const toType = object => {\r\n    if (object === null || object === undefined) {\r\n      return `${object}`;\r\n    }\r\n    return Object.prototype.toString.call(object).match(/\\s([a-z]+)/i)[1].toLowerCase();\r\n  };\r\n\r\n  /**\r\n   * Public Util API\r\n   */\r\n\r\n  const getUID = prefix => {\r\n    do {\r\n      prefix += Math.floor(Math.random() * MAX_UID);\r\n    } while (document.getElementById(prefix));\r\n    return prefix;\r\n  };\r\n  const getTransitionDurationFromElement = element => {\r\n    if (!element) {\r\n      return 0;\r\n    }\r\n\r\n    // Get transition-duration of the element\r\n    let {\r\n      transitionDuration,\r\n      transitionDelay\r\n    } = window.getComputedStyle(element);\r\n    const floatTransitionDuration = Number.parseFloat(transitionDuration);\r\n    const floatTransitionDelay = Number.parseFloat(transitionDelay);\r\n\r\n    // Return 0 if element or transition duration is not found\r\n    if (!floatTransitionDuration && !floatTransitionDelay) {\r\n      return 0;\r\n    }\r\n\r\n    // If multiple durations are defined, take the first\r\n    transitionDuration = transitionDuration.split(',')[0];\r\n    transitionDelay = transitionDelay.split(',')[0];\r\n    return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;\r\n  };\r\n  const triggerTransitionEnd = element => {\r\n    element.dispatchEvent(new Event(TRANSITION_END));\r\n  };\r\n  const isElement$1 = object => {\r\n    if (!object || typeof object !== 'object') {\r\n      return false;\r\n    }\r\n    if (typeof object.jquery !== 'undefined') {\r\n      object = object[0];\r\n    }\r\n    return typeof object.nodeType !== 'undefined';\r\n  };\r\n  const getElement = object => {\r\n    // it's a jQuery object or a node element\r\n    if (isElement$1(object)) {\r\n      return object.jquery ? object[0] : object;\r\n    }\r\n    if (typeof object === 'string' && object.length > 0) {\r\n      return document.querySelector(parseSelector(object));\r\n    }\r\n    return null;\r\n  };\r\n  const isVisible = element => {\r\n    if (!isElement$1(element) || element.getClientRects().length === 0) {\r\n      return false;\r\n    }\r\n    const elementIsVisible = getComputedStyle(element).getPropertyValue('visibility') === 'visible';\r\n    // Handle `details` element as its content may falsie appear visible when it is closed\r\n    const closedDetails = element.closest('details:not([open])');\r\n    if (!closedDetails) {\r\n      return elementIsVisible;\r\n    }\r\n    if (closedDetails !== element) {\r\n      const summary = element.closest('summary');\r\n      if (summary && summary.parentNode !== closedDetails) {\r\n        return false;\r\n      }\r\n      if (summary === null) {\r\n        return false;\r\n      }\r\n    }\r\n    return elementIsVisible;\r\n  };\r\n  const isDisabled = element => {\r\n    if (!element || element.nodeType !== Node.ELEMENT_NODE) {\r\n      return true;\r\n    }\r\n    if (element.classList.contains('disabled')) {\r\n      return true;\r\n    }\r\n    if (typeof element.disabled !== 'undefined') {\r\n      return element.disabled;\r\n    }\r\n    return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';\r\n  };\r\n  const findShadowRoot = element => {\r\n    if (!document.documentElement.attachShadow) {\r\n      return null;\r\n    }\r\n\r\n    // Can find the shadow root otherwise it'll return the document\r\n    if (typeof element.getRootNode === 'function') {\r\n      const root = element.getRootNode();\r\n      return root instanceof ShadowRoot ? root : null;\r\n    }\r\n    if (element instanceof ShadowRoot) {\r\n      return element;\r\n    }\r\n\r\n    // when we don't find a shadow root\r\n    if (!element.parentNode) {\r\n      return null;\r\n    }\r\n    return findShadowRoot(element.parentNode);\r\n  };\r\n  const noop = () => {};\r\n\r\n  /**\r\n   * Trick to restart an element's animation\r\n   *\r\n   * @param {HTMLElement} element\r\n   * @return void\r\n   *\r\n   * @see https://www.charistheo.io/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation\r\n   */\r\n  const reflow = element => {\r\n    element.offsetHeight; // eslint-disable-line no-unused-expressions\r\n  };\r\n  const getjQuery = () => {\r\n    if (window.jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {\r\n      return window.jQuery;\r\n    }\r\n    return null;\r\n  };\r\n  const DOMContentLoadedCallbacks = [];\r\n  const onDOMContentLoaded = callback => {\r\n    if (document.readyState === 'loading') {\r\n      // add listener on the first call when the document is in loading state\r\n      if (!DOMContentLoadedCallbacks.length) {\r\n        document.addEventListener('DOMContentLoaded', () => {\r\n          for (const callback of DOMContentLoadedCallbacks) {\r\n            callback();\r\n          }\r\n        });\r\n      }\r\n      DOMContentLoadedCallbacks.push(callback);\r\n    } else {\r\n      callback();\r\n    }\r\n  };\r\n  const isRTL = () => document.documentElement.dir === 'rtl';\r\n  const defineJQueryPlugin = plugin => {\r\n    onDOMContentLoaded(() => {\r\n      const $ = getjQuery();\r\n      /* istanbul ignore if */\r\n      if ($) {\r\n        const name = plugin.NAME;\r\n        const JQUERY_NO_CONFLICT = $.fn[name];\r\n        $.fn[name] = plugin.jQueryInterface;\r\n        $.fn[name].Constructor = plugin;\r\n        $.fn[name].noConflict = () => {\r\n          $.fn[name] = JQUERY_NO_CONFLICT;\r\n          return plugin.jQueryInterface;\r\n        };\r\n      }\r\n    });\r\n  };\r\n  const execute = (possibleCallback, args = [], defaultValue = possibleCallback) => {\r\n    return typeof possibleCallback === 'function' ? possibleCallback(...args) : defaultValue;\r\n  };\r\n  const executeAfterTransition = (callback, transitionElement, waitForTransition = true) => {\r\n    if (!waitForTransition) {\r\n      execute(callback);\r\n      return;\r\n    }\r\n    const durationPadding = 5;\r\n    const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;\r\n    let called = false;\r\n    const handler = ({\r\n      target\r\n    }) => {\r\n      if (target !== transitionElement) {\r\n        return;\r\n      }\r\n      called = true;\r\n      transitionElement.removeEventListener(TRANSITION_END, handler);\r\n      execute(callback);\r\n    };\r\n    transitionElement.addEventListener(TRANSITION_END, handler);\r\n    setTimeout(() => {\r\n      if (!called) {\r\n        triggerTransitionEnd(transitionElement);\r\n      }\r\n    }, emulatedDuration);\r\n  };\r\n\r\n  /**\r\n   * Return the previous/next element of a list.\r\n   *\r\n   * @param {array} list    The list of elements\r\n   * @param activeElement   The active element\r\n   * @param shouldGetNext   Choose to get next or previous element\r\n   * @param isCycleAllowed\r\n   * @return {Element|elem} The proper element\r\n   */\r\n  const getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed) => {\r\n    const listLength = list.length;\r\n    let index = list.indexOf(activeElement);\r\n\r\n    // if the element does not exist in the list return an element\r\n    // depending on the direction and if cycle is allowed\r\n    if (index === -1) {\r\n      return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0];\r\n    }\r\n    index += shouldGetNext ? 1 : -1;\r\n    if (isCycleAllowed) {\r\n      index = (index + listLength) % listLength;\r\n    }\r\n    return list[Math.max(0, Math.min(index, listLength - 1))];\r\n  };\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap dom/event-handler.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const namespaceRegex = /[^.]*(?=\\..*)\\.|.*/;\r\n  const stripNameRegex = /\\..*/;\r\n  const stripUidRegex = /::\\d+$/;\r\n  const eventRegistry = {}; // Events storage\r\n  let uidEvent = 1;\r\n  const customEvents = {\r\n    mouseenter: 'mouseover',\r\n    mouseleave: 'mouseout'\r\n  };\r\n  const nativeEvents = new Set(['click', 'dblclick', 'mouseup', 'mousedown', 'contextmenu', 'mousewheel', 'DOMMouseScroll', 'mouseover', 'mouseout', 'mousemove', 'selectstart', 'selectend', 'keydown', 'keypress', 'keyup', 'orientationchange', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'pointerdown', 'pointermove', 'pointerup', 'pointerleave', 'pointercancel', 'gesturestart', 'gesturechange', 'gestureend', 'focus', 'blur', 'change', 'reset', 'select', 'submit', 'focusin', 'focusout', 'load', 'unload', 'beforeunload', 'resize', 'move', 'DOMContentLoaded', 'readystatechange', 'error', 'abort', 'scroll']);\r\n\r\n  /**\r\n   * Private methods\r\n   */\r\n\r\n  function makeEventUid(element, uid) {\r\n    return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;\r\n  }\r\n  function getElementEvents(element) {\r\n    const uid = makeEventUid(element);\r\n    element.uidEvent = uid;\r\n    eventRegistry[uid] = eventRegistry[uid] || {};\r\n    return eventRegistry[uid];\r\n  }\r\n  function bootstrapHandler(element, fn) {\r\n    return function handler(event) {\r\n      hydrateObj(event, {\r\n        delegateTarget: element\r\n      });\r\n      if (handler.oneOff) {\r\n        EventHandler.off(element, event.type, fn);\r\n      }\r\n      return fn.apply(element, [event]);\r\n    };\r\n  }\r\n  function bootstrapDelegationHandler(element, selector, fn) {\r\n    return function handler(event) {\r\n      const domElements = element.querySelectorAll(selector);\r\n      for (let {\r\n        target\r\n      } = event; target && target !== this; target = target.parentNode) {\r\n        for (const domElement of domElements) {\r\n          if (domElement !== target) {\r\n            continue;\r\n          }\r\n          hydrateObj(event, {\r\n            delegateTarget: target\r\n          });\r\n          if (handler.oneOff) {\r\n            EventHandler.off(element, event.type, selector, fn);\r\n          }\r\n          return fn.apply(target, [event]);\r\n        }\r\n      }\r\n    };\r\n  }\r\n  function findHandler(events, callable, delegationSelector = null) {\r\n    return Object.values(events).find(event => event.callable === callable && event.delegationSelector === delegationSelector);\r\n  }\r\n  function normalizeParameters(originalTypeEvent, handler, delegationFunction) {\r\n    const isDelegated = typeof handler === 'string';\r\n    // TODO: tooltip passes `false` instead of selector, so we need to check\r\n    const callable = isDelegated ? delegationFunction : handler || delegationFunction;\r\n    let typeEvent = getTypeEvent(originalTypeEvent);\r\n    if (!nativeEvents.has(typeEvent)) {\r\n      typeEvent = originalTypeEvent;\r\n    }\r\n    return [isDelegated, callable, typeEvent];\r\n  }\r\n  function addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {\r\n    if (typeof originalTypeEvent !== 'string' || !element) {\r\n      return;\r\n    }\r\n    let [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);\r\n\r\n    // in case of mouseenter or mouseleave wrap the handler within a function that checks for its DOM position\r\n    // this prevents the handler from being dispatched the same way as mouseover or mouseout does\r\n    if (originalTypeEvent in customEvents) {\r\n      const wrapFunction = fn => {\r\n        return function (event) {\r\n          if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {\r\n            return fn.call(this, event);\r\n          }\r\n        };\r\n      };\r\n      callable = wrapFunction(callable);\r\n    }\r\n    const events = getElementEvents(element);\r\n    const handlers = events[typeEvent] || (events[typeEvent] = {});\r\n    const previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);\r\n    if (previousFunction) {\r\n      previousFunction.oneOff = previousFunction.oneOff && oneOff;\r\n      return;\r\n    }\r\n    const uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, ''));\r\n    const fn = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);\r\n    fn.delegationSelector = isDelegated ? handler : null;\r\n    fn.callable = callable;\r\n    fn.oneOff = oneOff;\r\n    fn.uidEvent = uid;\r\n    handlers[uid] = fn;\r\n    element.addEventListener(typeEvent, fn, isDelegated);\r\n  }\r\n  function removeHandler(element, events, typeEvent, handler, delegationSelector) {\r\n    const fn = findHandler(events[typeEvent], handler, delegationSelector);\r\n    if (!fn) {\r\n      return;\r\n    }\r\n    element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));\r\n    delete events[typeEvent][fn.uidEvent];\r\n  }\r\n  function removeNamespacedHandlers(element, events, typeEvent, namespace) {\r\n    const storeElementEvent = events[typeEvent] || {};\r\n    for (const [handlerKey, event] of Object.entries(storeElementEvent)) {\r\n      if (handlerKey.includes(namespace)) {\r\n        removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);\r\n      }\r\n    }\r\n  }\r\n  function getTypeEvent(event) {\r\n    // allow to get the native events from namespaced events ('click.bs.button' --> 'click')\r\n    event = event.replace(stripNameRegex, '');\r\n    return customEvents[event] || event;\r\n  }\r\n  const EventHandler = {\r\n    on(element, event, handler, delegationFunction) {\r\n      addHandler(element, event, handler, delegationFunction, false);\r\n    },\r\n    one(element, event, handler, delegationFunction) {\r\n      addHandler(element, event, handler, delegationFunction, true);\r\n    },\r\n    off(element, originalTypeEvent, handler, delegationFunction) {\r\n      if (typeof originalTypeEvent !== 'string' || !element) {\r\n        return;\r\n      }\r\n      const [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);\r\n      const inNamespace = typeEvent !== originalTypeEvent;\r\n      const events = getElementEvents(element);\r\n      const storeElementEvent = events[typeEvent] || {};\r\n      const isNamespace = originalTypeEvent.startsWith('.');\r\n      if (typeof callable !== 'undefined') {\r\n        // Simplest case: handler is passed, remove that listener ONLY.\r\n        if (!Object.keys(storeElementEvent).length) {\r\n          return;\r\n        }\r\n        removeHandler(element, events, typeEvent, callable, isDelegated ? handler : null);\r\n        return;\r\n      }\r\n      if (isNamespace) {\r\n        for (const elementEvent of Object.keys(events)) {\r\n          removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));\r\n        }\r\n      }\r\n      for (const [keyHandlers, event] of Object.entries(storeElementEvent)) {\r\n        const handlerKey = keyHandlers.replace(stripUidRegex, '');\r\n        if (!inNamespace || originalTypeEvent.includes(handlerKey)) {\r\n          removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);\r\n        }\r\n      }\r\n    },\r\n    trigger(element, event, args) {\r\n      if (typeof event !== 'string' || !element) {\r\n        return null;\r\n      }\r\n      const $ = getjQuery();\r\n      const typeEvent = getTypeEvent(event);\r\n      const inNamespace = event !== typeEvent;\r\n      let jQueryEvent = null;\r\n      let bubbles = true;\r\n      let nativeDispatch = true;\r\n      let defaultPrevented = false;\r\n      if (inNamespace && $) {\r\n        jQueryEvent = $.Event(event, args);\r\n        $(element).trigger(jQueryEvent);\r\n        bubbles = !jQueryEvent.isPropagationStopped();\r\n        nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();\r\n        defaultPrevented = jQueryEvent.isDefaultPrevented();\r\n      }\r\n      const evt = hydrateObj(new Event(event, {\r\n        bubbles,\r\n        cancelable: true\r\n      }), args);\r\n      if (defaultPrevented) {\r\n        evt.preventDefault();\r\n      }\r\n      if (nativeDispatch) {\r\n        element.dispatchEvent(evt);\r\n      }\r\n      if (evt.defaultPrevented && jQueryEvent) {\r\n        jQueryEvent.preventDefault();\r\n      }\r\n      return evt;\r\n    }\r\n  };\r\n  function hydrateObj(obj, meta = {}) {\r\n    for (const [key, value] of Object.entries(meta)) {\r\n      try {\r\n        obj[key] = value;\r\n      } catch (_unused) {\r\n        Object.defineProperty(obj, key, {\r\n          configurable: true,\r\n          get() {\r\n            return value;\r\n          }\r\n        });\r\n      }\r\n    }\r\n    return obj;\r\n  }\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap dom/manipulator.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n  function normalizeData(value) {\r\n    if (value === 'true') {\r\n      return true;\r\n    }\r\n    if (value === 'false') {\r\n      return false;\r\n    }\r\n    if (value === Number(value).toString()) {\r\n      return Number(value);\r\n    }\r\n    if (value === '' || value === 'null') {\r\n      return null;\r\n    }\r\n    if (typeof value !== 'string') {\r\n      return value;\r\n    }\r\n    try {\r\n      return JSON.parse(decodeURIComponent(value));\r\n    } catch (_unused) {\r\n      return value;\r\n    }\r\n  }\r\n  function normalizeDataKey(key) {\r\n    return key.replace(/[A-Z]/g, chr => `-${chr.toLowerCase()}`);\r\n  }\r\n  const Manipulator = {\r\n    setDataAttribute(element, key, value) {\r\n      element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);\r\n    },\r\n    removeDataAttribute(element, key) {\r\n      element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);\r\n    },\r\n    getDataAttributes(element) {\r\n      if (!element) {\r\n        return {};\r\n      }\r\n      const attributes = {};\r\n      const bsKeys = Object.keys(element.dataset).filter(key => key.startsWith('bs') && !key.startsWith('bsConfig'));\r\n      for (const key of bsKeys) {\r\n        let pureKey = key.replace(/^bs/, '');\r\n        pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);\r\n        attributes[pureKey] = normalizeData(element.dataset[key]);\r\n      }\r\n      return attributes;\r\n    },\r\n    getDataAttribute(element, key) {\r\n      return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));\r\n    }\r\n  };\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap util/config.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class Config {\r\n    // Getters\r\n    static get Default() {\r\n      return {};\r\n    }\r\n    static get DefaultType() {\r\n      return {};\r\n    }\r\n    static get NAME() {\r\n      throw new Error('You have to implement the static method \"NAME\", for each component!');\r\n    }\r\n    _getConfig(config) {\r\n      config = this._mergeConfigObj(config);\r\n      config = this._configAfterMerge(config);\r\n      this._typeCheckConfig(config);\r\n      return config;\r\n    }\r\n    _configAfterMerge(config) {\r\n      return config;\r\n    }\r\n    _mergeConfigObj(config, element) {\r\n      const jsonConfig = isElement$1(element) ? Manipulator.getDataAttribute(element, 'config') : {}; // try to parse\r\n\r\n      return {\r\n        ...this.constructor.Default,\r\n        ...(typeof jsonConfig === 'object' ? jsonConfig : {}),\r\n        ...(isElement$1(element) ? Manipulator.getDataAttributes(element) : {}),\r\n        ...(typeof config === 'object' ? config : {})\r\n      };\r\n    }\r\n    _typeCheckConfig(config, configTypes = this.constructor.DefaultType) {\r\n      for (const [property, expectedTypes] of Object.entries(configTypes)) {\r\n        const value = config[property];\r\n        const valueType = isElement$1(value) ? 'element' : toType(value);\r\n        if (!new RegExp(expectedTypes).test(valueType)) {\r\n          throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option \"${property}\" provided type \"${valueType}\" but expected type \"${expectedTypes}\".`);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap base-component.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const VERSION = '5.3.3';\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class BaseComponent extends Config {\r\n    constructor(element, config) {\r\n      super();\r\n      element = getElement(element);\r\n      if (!element) {\r\n        return;\r\n      }\r\n      this._element = element;\r\n      this._config = this._getConfig(config);\r\n      Data.set(this._element, this.constructor.DATA_KEY, this);\r\n    }\r\n\r\n    // Public\r\n    dispose() {\r\n      Data.remove(this._element, this.constructor.DATA_KEY);\r\n      EventHandler.off(this._element, this.constructor.EVENT_KEY);\r\n      for (const propertyName of Object.getOwnPropertyNames(this)) {\r\n        this[propertyName] = null;\r\n      }\r\n    }\r\n    _queueCallback(callback, element, isAnimated = true) {\r\n      executeAfterTransition(callback, element, isAnimated);\r\n    }\r\n    _getConfig(config) {\r\n      config = this._mergeConfigObj(config, this._element);\r\n      config = this._configAfterMerge(config);\r\n      this._typeCheckConfig(config);\r\n      return config;\r\n    }\r\n\r\n    // Static\r\n    static getInstance(element) {\r\n      return Data.get(getElement(element), this.DATA_KEY);\r\n    }\r\n    static getOrCreateInstance(element, config = {}) {\r\n      return this.getInstance(element) || new this(element, typeof config === 'object' ? config : null);\r\n    }\r\n    static get VERSION() {\r\n      return VERSION;\r\n    }\r\n    static get DATA_KEY() {\r\n      return `bs.${this.NAME}`;\r\n    }\r\n    static get EVENT_KEY() {\r\n      return `.${this.DATA_KEY}`;\r\n    }\r\n    static eventName(name) {\r\n      return `${name}${this.EVENT_KEY}`;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap dom/selector-engine.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n  const getSelector = element => {\r\n    let selector = element.getAttribute('data-bs-target');\r\n    if (!selector || selector === '#') {\r\n      let hrefAttribute = element.getAttribute('href');\r\n\r\n      // The only valid content that could double as a selector are IDs or classes,\r\n      // so everything starting with `#` or `.`. If a \"real\" URL is used as the selector,\r\n      // `document.querySelector` will rightfully complain it is invalid.\r\n      // See https://github.com/twbs/bootstrap/issues/32273\r\n      if (!hrefAttribute || !hrefAttribute.includes('#') && !hrefAttribute.startsWith('.')) {\r\n        return null;\r\n      }\r\n\r\n      // Just in case some CMS puts out a full URL with the anchor appended\r\n      if (hrefAttribute.includes('#') && !hrefAttribute.startsWith('#')) {\r\n        hrefAttribute = `#${hrefAttribute.split('#')[1]}`;\r\n      }\r\n      selector = hrefAttribute && hrefAttribute !== '#' ? hrefAttribute.trim() : null;\r\n    }\r\n    return selector ? selector.split(',').map(sel => parseSelector(sel)).join(',') : null;\r\n  };\r\n  const SelectorEngine = {\r\n    find(selector, element = document.documentElement) {\r\n      return [].concat(...Element.prototype.querySelectorAll.call(element, selector));\r\n    },\r\n    findOne(selector, element = document.documentElement) {\r\n      return Element.prototype.querySelector.call(element, selector);\r\n    },\r\n    children(element, selector) {\r\n      return [].concat(...element.children).filter(child => child.matches(selector));\r\n    },\r\n    parents(element, selector) {\r\n      const parents = [];\r\n      let ancestor = element.parentNode.closest(selector);\r\n      while (ancestor) {\r\n        parents.push(ancestor);\r\n        ancestor = ancestor.parentNode.closest(selector);\r\n      }\r\n      return parents;\r\n    },\r\n    prev(element, selector) {\r\n      let previous = element.previousElementSibling;\r\n      while (previous) {\r\n        if (previous.matches(selector)) {\r\n          return [previous];\r\n        }\r\n        previous = previous.previousElementSibling;\r\n      }\r\n      return [];\r\n    },\r\n    // TODO: this is now unused; remove later along with prev()\r\n    next(element, selector) {\r\n      let next = element.nextElementSibling;\r\n      while (next) {\r\n        if (next.matches(selector)) {\r\n          return [next];\r\n        }\r\n        next = next.nextElementSibling;\r\n      }\r\n      return [];\r\n    },\r\n    focusableChildren(element) {\r\n      const focusables = ['a', 'button', 'input', 'textarea', 'select', 'details', '[tabindex]', '[contenteditable=\"true\"]'].map(selector => `${selector}:not([tabindex^=\"-\"])`).join(',');\r\n      return this.find(focusables, element).filter(el => !isDisabled(el) && isVisible(el));\r\n    },\r\n    getSelectorFromElement(element) {\r\n      const selector = getSelector(element);\r\n      if (selector) {\r\n        return SelectorEngine.findOne(selector) ? selector : null;\r\n      }\r\n      return null;\r\n    },\r\n    getElementFromSelector(element) {\r\n      const selector = getSelector(element);\r\n      return selector ? SelectorEngine.findOne(selector) : null;\r\n    },\r\n    getMultipleElementsFromSelector(element) {\r\n      const selector = getSelector(element);\r\n      return selector ? SelectorEngine.find(selector) : [];\r\n    }\r\n  };\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap util/component-functions.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n  const enableDismissTrigger = (component, method = 'hide') => {\r\n    const clickEvent = `click.dismiss${component.EVENT_KEY}`;\r\n    const name = component.NAME;\r\n    EventHandler.on(document, clickEvent, `[data-bs-dismiss=\"${name}\"]`, function (event) {\r\n      if (['A', 'AREA'].includes(this.tagName)) {\r\n        event.preventDefault();\r\n      }\r\n      if (isDisabled(this)) {\r\n        return;\r\n      }\r\n      const target = SelectorEngine.getElementFromSelector(this) || this.closest(`.${name}`);\r\n      const instance = component.getOrCreateInstance(target);\r\n\r\n      // Method argument is left, for Alert and only, as it doesn't implement the 'hide' method\r\n      instance[method]();\r\n    });\r\n  };\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap alert.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const NAME$f = 'alert';\r\n  const DATA_KEY$a = 'bs.alert';\r\n  const EVENT_KEY$b = `.${DATA_KEY$a}`;\r\n  const EVENT_CLOSE = `close${EVENT_KEY$b}`;\r\n  const EVENT_CLOSED = `closed${EVENT_KEY$b}`;\r\n  const CLASS_NAME_FADE$5 = 'fade';\r\n  const CLASS_NAME_SHOW$8 = 'show';\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class Alert extends BaseComponent {\r\n    // Getters\r\n    static get NAME() {\r\n      return NAME$f;\r\n    }\r\n\r\n    // Public\r\n    close() {\r\n      const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);\r\n      if (closeEvent.defaultPrevented) {\r\n        return;\r\n      }\r\n      this._element.classList.remove(CLASS_NAME_SHOW$8);\r\n      const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);\r\n      this._queueCallback(() => this._destroyElement(), this._element, isAnimated);\r\n    }\r\n\r\n    // Private\r\n    _destroyElement() {\r\n      this._element.remove();\r\n      EventHandler.trigger(this._element, EVENT_CLOSED);\r\n      this.dispose();\r\n    }\r\n\r\n    // Static\r\n    static jQueryInterface(config) {\r\n      return this.each(function () {\r\n        const data = Alert.getOrCreateInstance(this);\r\n        if (typeof config !== 'string') {\r\n          return;\r\n        }\r\n        if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\r\n          throw new TypeError(`No method named \"${config}\"`);\r\n        }\r\n        data[config](this);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Data API implementation\r\n   */\r\n\r\n  enableDismissTrigger(Alert, 'close');\r\n\r\n  /**\r\n   * jQuery\r\n   */\r\n\r\n  defineJQueryPlugin(Alert);\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap button.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const NAME$e = 'button';\r\n  const DATA_KEY$9 = 'bs.button';\r\n  const EVENT_KEY$a = `.${DATA_KEY$9}`;\r\n  const DATA_API_KEY$6 = '.data-api';\r\n  const CLASS_NAME_ACTIVE$3 = 'active';\r\n  const SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle=\"button\"]';\r\n  const EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$a}${DATA_API_KEY$6}`;\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class Button extends BaseComponent {\r\n    // Getters\r\n    static get NAME() {\r\n      return NAME$e;\r\n    }\r\n\r\n    // Public\r\n    toggle() {\r\n      // Toggle class and sync the `aria-pressed` attribute with the return value of the `.toggle()` method\r\n      this._element.setAttribute('aria-pressed', this._element.classList.toggle(CLASS_NAME_ACTIVE$3));\r\n    }\r\n\r\n    // Static\r\n    static jQueryInterface(config) {\r\n      return this.each(function () {\r\n        const data = Button.getOrCreateInstance(this);\r\n        if (config === 'toggle') {\r\n          data[config]();\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Data API implementation\r\n   */\r\n\r\n  EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, event => {\r\n    event.preventDefault();\r\n    const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);\r\n    const data = Button.getOrCreateInstance(button);\r\n    data.toggle();\r\n  });\r\n\r\n  /**\r\n   * jQuery\r\n   */\r\n\r\n  defineJQueryPlugin(Button);\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap util/swipe.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const NAME$d = 'swipe';\r\n  const EVENT_KEY$9 = '.bs.swipe';\r\n  const EVENT_TOUCHSTART = `touchstart${EVENT_KEY$9}`;\r\n  const EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$9}`;\r\n  const EVENT_TOUCHEND = `touchend${EVENT_KEY$9}`;\r\n  const EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$9}`;\r\n  const EVENT_POINTERUP = `pointerup${EVENT_KEY$9}`;\r\n  const POINTER_TYPE_TOUCH = 'touch';\r\n  const POINTER_TYPE_PEN = 'pen';\r\n  const CLASS_NAME_POINTER_EVENT = 'pointer-event';\r\n  const SWIPE_THRESHOLD = 40;\r\n  const Default$c = {\r\n    endCallback: null,\r\n    leftCallback: null,\r\n    rightCallback: null\r\n  };\r\n  const DefaultType$c = {\r\n    endCallback: '(function|null)',\r\n    leftCallback: '(function|null)',\r\n    rightCallback: '(function|null)'\r\n  };\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class Swipe extends Config {\r\n    constructor(element, config) {\r\n      super();\r\n      this._element = element;\r\n      if (!element || !Swipe.isSupported()) {\r\n        return;\r\n      }\r\n      this._config = this._getConfig(config);\r\n      this._deltaX = 0;\r\n      this._supportPointerEvents = Boolean(window.PointerEvent);\r\n      this._initEvents();\r\n    }\r\n\r\n    // Getters\r\n    static get Default() {\r\n      return Default$c;\r\n    }\r\n    static get DefaultType() {\r\n      return DefaultType$c;\r\n    }\r\n    static get NAME() {\r\n      return NAME$d;\r\n    }\r\n\r\n    // Public\r\n    dispose() {\r\n      EventHandler.off(this._element, EVENT_KEY$9);\r\n    }\r\n\r\n    // Private\r\n    _start(event) {\r\n      if (!this._supportPointerEvents) {\r\n        this._deltaX = event.touches[0].clientX;\r\n        return;\r\n      }\r\n      if (this._eventIsPointerPenTouch(event)) {\r\n        this._deltaX = event.clientX;\r\n      }\r\n    }\r\n    _end(event) {\r\n      if (this._eventIsPointerPenTouch(event)) {\r\n        this._deltaX = event.clientX - this._deltaX;\r\n      }\r\n      this._handleSwipe();\r\n      execute(this._config.endCallback);\r\n    }\r\n    _move(event) {\r\n      this._deltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this._deltaX;\r\n    }\r\n    _handleSwipe() {\r\n      const absDeltaX = Math.abs(this._deltaX);\r\n      if (absDeltaX <= SWIPE_THRESHOLD) {\r\n        return;\r\n      }\r\n      const direction = absDeltaX / this._deltaX;\r\n      this._deltaX = 0;\r\n      if (!direction) {\r\n        return;\r\n      }\r\n      execute(direction > 0 ? this._config.rightCallback : this._config.leftCallback);\r\n    }\r\n    _initEvents() {\r\n      if (this._supportPointerEvents) {\r\n        EventHandler.on(this._element, EVENT_POINTERDOWN, event => this._start(event));\r\n        EventHandler.on(this._element, EVENT_POINTERUP, event => this._end(event));\r\n        this._element.classList.add(CLASS_NAME_POINTER_EVENT);\r\n      } else {\r\n        EventHandler.on(this._element, EVENT_TOUCHSTART, event => this._start(event));\r\n        EventHandler.on(this._element, EVENT_TOUCHMOVE, event => this._move(event));\r\n        EventHandler.on(this._element, EVENT_TOUCHEND, event => this._end(event));\r\n      }\r\n    }\r\n    _eventIsPointerPenTouch(event) {\r\n      return this._supportPointerEvents && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);\r\n    }\r\n\r\n    // Static\r\n    static isSupported() {\r\n      return 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap carousel.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const NAME$c = 'carousel';\r\n  const DATA_KEY$8 = 'bs.carousel';\r\n  const EVENT_KEY$8 = `.${DATA_KEY$8}`;\r\n  const DATA_API_KEY$5 = '.data-api';\r\n  const ARROW_LEFT_KEY$1 = 'ArrowLeft';\r\n  const ARROW_RIGHT_KEY$1 = 'ArrowRight';\r\n  const TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch\r\n\r\n  const ORDER_NEXT = 'next';\r\n  const ORDER_PREV = 'prev';\r\n  const DIRECTION_LEFT = 'left';\r\n  const DIRECTION_RIGHT = 'right';\r\n  const EVENT_SLIDE = `slide${EVENT_KEY$8}`;\r\n  const EVENT_SLID = `slid${EVENT_KEY$8}`;\r\n  const EVENT_KEYDOWN$1 = `keydown${EVENT_KEY$8}`;\r\n  const EVENT_MOUSEENTER$1 = `mouseenter${EVENT_KEY$8}`;\r\n  const EVENT_MOUSELEAVE$1 = `mouseleave${EVENT_KEY$8}`;\r\n  const EVENT_DRAG_START = `dragstart${EVENT_KEY$8}`;\r\n  const EVENT_LOAD_DATA_API$3 = `load${EVENT_KEY$8}${DATA_API_KEY$5}`;\r\n  const EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$8}${DATA_API_KEY$5}`;\r\n  const CLASS_NAME_CAROUSEL = 'carousel';\r\n  const CLASS_NAME_ACTIVE$2 = 'active';\r\n  const CLASS_NAME_SLIDE = 'slide';\r\n  const CLASS_NAME_END = 'carousel-item-end';\r\n  const CLASS_NAME_START = 'carousel-item-start';\r\n  const CLASS_NAME_NEXT = 'carousel-item-next';\r\n  const CLASS_NAME_PREV = 'carousel-item-prev';\r\n  const SELECTOR_ACTIVE = '.active';\r\n  const SELECTOR_ITEM = '.carousel-item';\r\n  const SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE + SELECTOR_ITEM;\r\n  const SELECTOR_ITEM_IMG = '.carousel-item img';\r\n  const SELECTOR_INDICATORS = '.carousel-indicators';\r\n  const SELECTOR_DATA_SLIDE = '[data-bs-slide], [data-bs-slide-to]';\r\n  const SELECTOR_DATA_RIDE = '[data-bs-ride=\"carousel\"]';\r\n  const KEY_TO_DIRECTION = {\r\n    [ARROW_LEFT_KEY$1]: DIRECTION_RIGHT,\r\n    [ARROW_RIGHT_KEY$1]: DIRECTION_LEFT\r\n  };\r\n  const Default$b = {\r\n    interval: 5000,\r\n    keyboard: true,\r\n    pause: 'hover',\r\n    ride: false,\r\n    touch: true,\r\n    wrap: true\r\n  };\r\n  const DefaultType$b = {\r\n    interval: '(number|boolean)',\r\n    // TODO:v6 remove boolean support\r\n    keyboard: 'boolean',\r\n    pause: '(string|boolean)',\r\n    ride: '(boolean|string)',\r\n    touch: 'boolean',\r\n    wrap: 'boolean'\r\n  };\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class Carousel extends BaseComponent {\r\n    constructor(element, config) {\r\n      super(element, config);\r\n      this._interval = null;\r\n      this._activeElement = null;\r\n      this._isSliding = false;\r\n      this.touchTimeout = null;\r\n      this._swipeHelper = null;\r\n      this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);\r\n      this._addEventListeners();\r\n      if (this._config.ride === CLASS_NAME_CAROUSEL) {\r\n        this.cycle();\r\n      }\r\n    }\r\n\r\n    // Getters\r\n    static get Default() {\r\n      return Default$b;\r\n    }\r\n    static get DefaultType() {\r\n      return DefaultType$b;\r\n    }\r\n    static get NAME() {\r\n      return NAME$c;\r\n    }\r\n\r\n    // Public\r\n    next() {\r\n      this._slide(ORDER_NEXT);\r\n    }\r\n    nextWhenVisible() {\r\n      // FIXME TODO use `document.visibilityState`\r\n      // Don't call next when the page isn't visible\r\n      // or the carousel or its parent isn't visible\r\n      if (!document.hidden && isVisible(this._element)) {\r\n        this.next();\r\n      }\r\n    }\r\n    prev() {\r\n      this._slide(ORDER_PREV);\r\n    }\r\n    pause() {\r\n      if (this._isSliding) {\r\n        triggerTransitionEnd(this._element);\r\n      }\r\n      this._clearInterval();\r\n    }\r\n    cycle() {\r\n      this._clearInterval();\r\n      this._updateInterval();\r\n      this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval);\r\n    }\r\n    _maybeEnableCycle() {\r\n      if (!this._config.ride) {\r\n        return;\r\n      }\r\n      if (this._isSliding) {\r\n        EventHandler.one(this._element, EVENT_SLID, () => this.cycle());\r\n        return;\r\n      }\r\n      this.cycle();\r\n    }\r\n    to(index) {\r\n      const items = this._getItems();\r\n      if (index > items.length - 1 || index < 0) {\r\n        return;\r\n      }\r\n      if (this._isSliding) {\r\n        EventHandler.one(this._element, EVENT_SLID, () => this.to(index));\r\n        return;\r\n      }\r\n      const activeIndex = this._getItemIndex(this._getActive());\r\n      if (activeIndex === index) {\r\n        return;\r\n      }\r\n      const order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;\r\n      this._slide(order, items[index]);\r\n    }\r\n    dispose() {\r\n      if (this._swipeHelper) {\r\n        this._swipeHelper.dispose();\r\n      }\r\n      super.dispose();\r\n    }\r\n\r\n    // Private\r\n    _configAfterMerge(config) {\r\n      config.defaultInterval = config.interval;\r\n      return config;\r\n    }\r\n    _addEventListeners() {\r\n      if (this._config.keyboard) {\r\n        EventHandler.on(this._element, EVENT_KEYDOWN$1, event => this._keydown(event));\r\n      }\r\n      if (this._config.pause === 'hover') {\r\n        EventHandler.on(this._element, EVENT_MOUSEENTER$1, () => this.pause());\r\n        EventHandler.on(this._element, EVENT_MOUSELEAVE$1, () => this._maybeEnableCycle());\r\n      }\r\n      if (this._config.touch && Swipe.isSupported()) {\r\n        this._addTouchEventListeners();\r\n      }\r\n    }\r\n    _addTouchEventListeners() {\r\n      for (const img of SelectorEngine.find(SELECTOR_ITEM_IMG, this._element)) {\r\n        EventHandler.on(img, EVENT_DRAG_START, event => event.preventDefault());\r\n      }\r\n      const endCallBack = () => {\r\n        if (this._config.pause !== 'hover') {\r\n          return;\r\n        }\r\n\r\n        // If it's a touch-enabled device, mouseenter/leave are fired as\r\n        // part of the mouse compatibility events on first tap - the carousel\r\n        // would stop cycling until user tapped out of it;\r\n        // here, we listen for touchend, explicitly pause the carousel\r\n        // (as if it's the second time we tap on it, mouseenter compat event\r\n        // is NOT fired) and after a timeout (to allow for mouse compatibility\r\n        // events to fire) we explicitly restart cycling\r\n\r\n        this.pause();\r\n        if (this.touchTimeout) {\r\n          clearTimeout(this.touchTimeout);\r\n        }\r\n        this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), TOUCHEVENT_COMPAT_WAIT + this._config.interval);\r\n      };\r\n      const swipeConfig = {\r\n        leftCallback: () => this._slide(this._directionToOrder(DIRECTION_LEFT)),\r\n        rightCallback: () => this._slide(this._directionToOrder(DIRECTION_RIGHT)),\r\n        endCallback: endCallBack\r\n      };\r\n      this._swipeHelper = new Swipe(this._element, swipeConfig);\r\n    }\r\n    _keydown(event) {\r\n      if (/input|textarea/i.test(event.target.tagName)) {\r\n        return;\r\n      }\r\n      const direction = KEY_TO_DIRECTION[event.key];\r\n      if (direction) {\r\n        event.preventDefault();\r\n        this._slide(this._directionToOrder(direction));\r\n      }\r\n    }\r\n    _getItemIndex(element) {\r\n      return this._getItems().indexOf(element);\r\n    }\r\n    _setActiveIndicatorElement(index) {\r\n      if (!this._indicatorsElement) {\r\n        return;\r\n      }\r\n      const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement);\r\n      activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);\r\n      activeIndicator.removeAttribute('aria-current');\r\n      const newActiveIndicator = SelectorEngine.findOne(`[data-bs-slide-to=\"${index}\"]`, this._indicatorsElement);\r\n      if (newActiveIndicator) {\r\n        newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$2);\r\n        newActiveIndicator.setAttribute('aria-current', 'true');\r\n      }\r\n    }\r\n    _updateInterval() {\r\n      const element = this._activeElement || this._getActive();\r\n      if (!element) {\r\n        return;\r\n      }\r\n      const elementInterval = Number.parseInt(element.getAttribute('data-bs-interval'), 10);\r\n      this._config.interval = elementInterval || this._config.defaultInterval;\r\n    }\r\n    _slide(order, element = null) {\r\n      if (this._isSliding) {\r\n        return;\r\n      }\r\n      const activeElement = this._getActive();\r\n      const isNext = order === ORDER_NEXT;\r\n      const nextElement = element || getNextActiveElement(this._getItems(), activeElement, isNext, this._config.wrap);\r\n      if (nextElement === activeElement) {\r\n        return;\r\n      }\r\n      const nextElementIndex = this._getItemIndex(nextElement);\r\n      const triggerEvent = eventName => {\r\n        return EventHandler.trigger(this._element, eventName, {\r\n          relatedTarget: nextElement,\r\n          direction: this._orderToDirection(order),\r\n          from: this._getItemIndex(activeElement),\r\n          to: nextElementIndex\r\n        });\r\n      };\r\n      const slideEvent = triggerEvent(EVENT_SLIDE);\r\n      if (slideEvent.defaultPrevented) {\r\n        return;\r\n      }\r\n      if (!activeElement || !nextElement) {\r\n        // Some weirdness is happening, so we bail\r\n        // TODO: change tests that use empty divs to avoid this check\r\n        return;\r\n      }\r\n      const isCycling = Boolean(this._interval);\r\n      this.pause();\r\n      this._isSliding = true;\r\n      this._setActiveIndicatorElement(nextElementIndex);\r\n      this._activeElement = nextElement;\r\n      const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;\r\n      const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;\r\n      nextElement.classList.add(orderClassName);\r\n      reflow(nextElement);\r\n      activeElement.classList.add(directionalClassName);\r\n      nextElement.classList.add(directionalClassName);\r\n      const completeCallBack = () => {\r\n        nextElement.classList.remove(directionalClassName, orderClassName);\r\n        nextElement.classList.add(CLASS_NAME_ACTIVE$2);\r\n        activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);\r\n        this._isSliding = false;\r\n        triggerEvent(EVENT_SLID);\r\n      };\r\n      this._queueCallback(completeCallBack, activeElement, this._isAnimated());\r\n      if (isCycling) {\r\n        this.cycle();\r\n      }\r\n    }\r\n    _isAnimated() {\r\n      return this._element.classList.contains(CLASS_NAME_SLIDE);\r\n    }\r\n    _getActive() {\r\n      return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);\r\n    }\r\n    _getItems() {\r\n      return SelectorEngine.find(SELECTOR_ITEM, this._element);\r\n    }\r\n    _clearInterval() {\r\n      if (this._interval) {\r\n        clearInterval(this._interval);\r\n        this._interval = null;\r\n      }\r\n    }\r\n    _directionToOrder(direction) {\r\n      if (isRTL()) {\r\n        return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;\r\n      }\r\n      return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;\r\n    }\r\n    _orderToDirection(order) {\r\n      if (isRTL()) {\r\n        return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;\r\n      }\r\n      return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;\r\n    }\r\n\r\n    // Static\r\n    static jQueryInterface(config) {\r\n      return this.each(function () {\r\n        const data = Carousel.getOrCreateInstance(this, config);\r\n        if (typeof config === 'number') {\r\n          data.to(config);\r\n          return;\r\n        }\r\n        if (typeof config === 'string') {\r\n          if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\r\n            throw new TypeError(`No method named \"${config}\"`);\r\n          }\r\n          data[config]();\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Data API implementation\r\n   */\r\n\r\n  EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, function (event) {\r\n    const target = SelectorEngine.getElementFromSelector(this);\r\n    if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {\r\n      return;\r\n    }\r\n    event.preventDefault();\r\n    const carousel = Carousel.getOrCreateInstance(target);\r\n    const slideIndex = this.getAttribute('data-bs-slide-to');\r\n    if (slideIndex) {\r\n      carousel.to(slideIndex);\r\n      carousel._maybeEnableCycle();\r\n      return;\r\n    }\r\n    if (Manipulator.getDataAttribute(this, 'slide') === 'next') {\r\n      carousel.next();\r\n      carousel._maybeEnableCycle();\r\n      return;\r\n    }\r\n    carousel.prev();\r\n    carousel._maybeEnableCycle();\r\n  });\r\n  EventHandler.on(window, EVENT_LOAD_DATA_API$3, () => {\r\n    const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);\r\n    for (const carousel of carousels) {\r\n      Carousel.getOrCreateInstance(carousel);\r\n    }\r\n  });\r\n\r\n  /**\r\n   * jQuery\r\n   */\r\n\r\n  defineJQueryPlugin(Carousel);\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap collapse.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const NAME$b = 'collapse';\r\n  const DATA_KEY$7 = 'bs.collapse';\r\n  const EVENT_KEY$7 = `.${DATA_KEY$7}`;\r\n  const DATA_API_KEY$4 = '.data-api';\r\n  const EVENT_SHOW$6 = `show${EVENT_KEY$7}`;\r\n  const EVENT_SHOWN$6 = `shown${EVENT_KEY$7}`;\r\n  const EVENT_HIDE$6 = `hide${EVENT_KEY$7}`;\r\n  const EVENT_HIDDEN$6 = `hidden${EVENT_KEY$7}`;\r\n  const EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$7}${DATA_API_KEY$4}`;\r\n  const CLASS_NAME_SHOW$7 = 'show';\r\n  const CLASS_NAME_COLLAPSE = 'collapse';\r\n  const CLASS_NAME_COLLAPSING = 'collapsing';\r\n  const CLASS_NAME_COLLAPSED = 'collapsed';\r\n  const CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;\r\n  const CLASS_NAME_HORIZONTAL = 'collapse-horizontal';\r\n  const WIDTH = 'width';\r\n  const HEIGHT = 'height';\r\n  const SELECTOR_ACTIVES = '.collapse.show, .collapse.collapsing';\r\n  const SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle=\"collapse\"]';\r\n  const Default$a = {\r\n    parent: null,\r\n    toggle: true\r\n  };\r\n  const DefaultType$a = {\r\n    parent: '(null|element)',\r\n    toggle: 'boolean'\r\n  };\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class Collapse extends BaseComponent {\r\n    constructor(element, config) {\r\n      super(element, config);\r\n      this._isTransitioning = false;\r\n      this._triggerArray = [];\r\n      const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);\r\n      for (const elem of toggleList) {\r\n        const selector = SelectorEngine.getSelectorFromElement(elem);\r\n        const filterElement = SelectorEngine.find(selector).filter(foundElement => foundElement === this._element);\r\n        if (selector !== null && filterElement.length) {\r\n          this._triggerArray.push(elem);\r\n        }\r\n      }\r\n      this._initializeChildren();\r\n      if (!this._config.parent) {\r\n        this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());\r\n      }\r\n      if (this._config.toggle) {\r\n        this.toggle();\r\n      }\r\n    }\r\n\r\n    // Getters\r\n    static get Default() {\r\n      return Default$a;\r\n    }\r\n    static get DefaultType() {\r\n      return DefaultType$a;\r\n    }\r\n    static get NAME() {\r\n      return NAME$b;\r\n    }\r\n\r\n    // Public\r\n    toggle() {\r\n      if (this._isShown()) {\r\n        this.hide();\r\n      } else {\r\n        this.show();\r\n      }\r\n    }\r\n    show() {\r\n      if (this._isTransitioning || this._isShown()) {\r\n        return;\r\n      }\r\n      let activeChildren = [];\r\n\r\n      // find active children\r\n      if (this._config.parent) {\r\n        activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter(element => element !== this._element).map(element => Collapse.getOrCreateInstance(element, {\r\n          toggle: false\r\n        }));\r\n      }\r\n      if (activeChildren.length && activeChildren[0]._isTransitioning) {\r\n        return;\r\n      }\r\n      const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$6);\r\n      if (startEvent.defaultPrevented) {\r\n        return;\r\n      }\r\n      for (const activeInstance of activeChildren) {\r\n        activeInstance.hide();\r\n      }\r\n      const dimension = this._getDimension();\r\n      this._element.classList.remove(CLASS_NAME_COLLAPSE);\r\n      this._element.classList.add(CLASS_NAME_COLLAPSING);\r\n      this._element.style[dimension] = 0;\r\n      this._addAriaAndCollapsedClass(this._triggerArray, true);\r\n      this._isTransitioning = true;\r\n      const complete = () => {\r\n        this._isTransitioning = false;\r\n        this._element.classList.remove(CLASS_NAME_COLLAPSING);\r\n        this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);\r\n        this._element.style[dimension] = '';\r\n        EventHandler.trigger(this._element, EVENT_SHOWN$6);\r\n      };\r\n      const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);\r\n      const scrollSize = `scroll${capitalizedDimension}`;\r\n      this._queueCallback(complete, this._element, true);\r\n      this._element.style[dimension] = `${this._element[scrollSize]}px`;\r\n    }\r\n    hide() {\r\n      if (this._isTransitioning || !this._isShown()) {\r\n        return;\r\n      }\r\n      const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$6);\r\n      if (startEvent.defaultPrevented) {\r\n        return;\r\n      }\r\n      const dimension = this._getDimension();\r\n      this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;\r\n      reflow(this._element);\r\n      this._element.classList.add(CLASS_NAME_COLLAPSING);\r\n      this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);\r\n      for (const trigger of this._triggerArray) {\r\n        const element = SelectorEngine.getElementFromSelector(trigger);\r\n        if (element && !this._isShown(element)) {\r\n          this._addAriaAndCollapsedClass([trigger], false);\r\n        }\r\n      }\r\n      this._isTransitioning = true;\r\n      const complete = () => {\r\n        this._isTransitioning = false;\r\n        this._element.classList.remove(CLASS_NAME_COLLAPSING);\r\n        this._element.classList.add(CLASS_NAME_COLLAPSE);\r\n        EventHandler.trigger(this._element, EVENT_HIDDEN$6);\r\n      };\r\n      this._element.style[dimension] = '';\r\n      this._queueCallback(complete, this._element, true);\r\n    }\r\n    _isShown(element = this._element) {\r\n      return element.classList.contains(CLASS_NAME_SHOW$7);\r\n    }\r\n\r\n    // Private\r\n    _configAfterMerge(config) {\r\n      config.toggle = Boolean(config.toggle); // Coerce string values\r\n      config.parent = getElement(config.parent);\r\n      return config;\r\n    }\r\n    _getDimension() {\r\n      return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;\r\n    }\r\n    _initializeChildren() {\r\n      if (!this._config.parent) {\r\n        return;\r\n      }\r\n      const children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$4);\r\n      for (const element of children) {\r\n        const selected = SelectorEngine.getElementFromSelector(element);\r\n        if (selected) {\r\n          this._addAriaAndCollapsedClass([element], this._isShown(selected));\r\n        }\r\n      }\r\n    }\r\n    _getFirstLevelChildren(selector) {\r\n      const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);\r\n      // remove children if greater depth\r\n      return SelectorEngine.find(selector, this._config.parent).filter(element => !children.includes(element));\r\n    }\r\n    _addAriaAndCollapsedClass(triggerArray, isOpen) {\r\n      if (!triggerArray.length) {\r\n        return;\r\n      }\r\n      for (const element of triggerArray) {\r\n        element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);\r\n        element.setAttribute('aria-expanded', isOpen);\r\n      }\r\n    }\r\n\r\n    // Static\r\n    static jQueryInterface(config) {\r\n      const _config = {};\r\n      if (typeof config === 'string' && /show|hide/.test(config)) {\r\n        _config.toggle = false;\r\n      }\r\n      return this.each(function () {\r\n        const data = Collapse.getOrCreateInstance(this, _config);\r\n        if (typeof config === 'string') {\r\n          if (typeof data[config] === 'undefined') {\r\n            throw new TypeError(`No method named \"${config}\"`);\r\n          }\r\n          data[config]();\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Data API implementation\r\n   */\r\n\r\n  EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function (event) {\r\n    // preventDefault only for <a> elements (which change the URL) not inside the collapsible element\r\n    if (event.target.tagName === 'A' || event.delegateTarget && event.delegateTarget.tagName === 'A') {\r\n      event.preventDefault();\r\n    }\r\n    for (const element of SelectorEngine.getMultipleElementsFromSelector(this)) {\r\n      Collapse.getOrCreateInstance(element, {\r\n        toggle: false\r\n      }).toggle();\r\n    }\r\n  });\r\n\r\n  /**\r\n   * jQuery\r\n   */\r\n\r\n  defineJQueryPlugin(Collapse);\r\n\r\n  var top = 'top';\r\n  var bottom = 'bottom';\r\n  var right = 'right';\r\n  var left = 'left';\r\n  var auto = 'auto';\r\n  var basePlacements = [top, bottom, right, left];\r\n  var start = 'start';\r\n  var end = 'end';\r\n  var clippingParents = 'clippingParents';\r\n  var viewport = 'viewport';\r\n  var popper = 'popper';\r\n  var reference = 'reference';\r\n  var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {\r\n    return acc.concat([placement + \"-\" + start, placement + \"-\" + end]);\r\n  }, []);\r\n  var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {\r\n    return acc.concat([placement, placement + \"-\" + start, placement + \"-\" + end]);\r\n  }, []); // modifiers that need to read the DOM\r\n\r\n  var beforeRead = 'beforeRead';\r\n  var read = 'read';\r\n  var afterRead = 'afterRead'; // pure-logic modifiers\r\n\r\n  var beforeMain = 'beforeMain';\r\n  var main = 'main';\r\n  var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)\r\n\r\n  var beforeWrite = 'beforeWrite';\r\n  var write = 'write';\r\n  var afterWrite = 'afterWrite';\r\n  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];\r\n\r\n  function getNodeName(element) {\r\n    return element ? (element.nodeName || '').toLowerCase() : null;\r\n  }\r\n\r\n  function getWindow(node) {\r\n    if (node == null) {\r\n      return window;\r\n    }\r\n\r\n    if (node.toString() !== '[object Window]') {\r\n      var ownerDocument = node.ownerDocument;\r\n      return ownerDocument ? ownerDocument.defaultView || window : window;\r\n    }\r\n\r\n    return node;\r\n  }\r\n\r\n  function isElement(node) {\r\n    var OwnElement = getWindow(node).Element;\r\n    return node instanceof OwnElement || node instanceof Element;\r\n  }\r\n\r\n  function isHTMLElement(node) {\r\n    var OwnElement = getWindow(node).HTMLElement;\r\n    return node instanceof OwnElement || node instanceof HTMLElement;\r\n  }\r\n\r\n  function isShadowRoot(node) {\r\n    // IE 11 has no ShadowRoot\r\n    if (typeof ShadowRoot === 'undefined') {\r\n      return false;\r\n    }\r\n\r\n    var OwnElement = getWindow(node).ShadowRoot;\r\n    return node instanceof OwnElement || node instanceof ShadowRoot;\r\n  }\r\n\r\n  // and applies them to the HTMLElements such as popper and arrow\r\n\r\n  function applyStyles(_ref) {\r\n    var state = _ref.state;\r\n    Object.keys(state.elements).forEach(function (name) {\r\n      var style = state.styles[name] || {};\r\n      var attributes = state.attributes[name] || {};\r\n      var element = state.elements[name]; // arrow is optional + virtual elements\r\n\r\n      if (!isHTMLElement(element) || !getNodeName(element)) {\r\n        return;\r\n      } // Flow doesn't support to extend this property, but it's the most\r\n      // effective way to apply styles to an HTMLElement\r\n      // $FlowFixMe[cannot-write]\r\n\r\n\r\n      Object.assign(element.style, style);\r\n      Object.keys(attributes).forEach(function (name) {\r\n        var value = attributes[name];\r\n\r\n        if (value === false) {\r\n          element.removeAttribute(name);\r\n        } else {\r\n          element.setAttribute(name, value === true ? '' : value);\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  function effect$2(_ref2) {\r\n    var state = _ref2.state;\r\n    var initialStyles = {\r\n      popper: {\r\n        position: state.options.strategy,\r\n        left: '0',\r\n        top: '0',\r\n        margin: '0'\r\n      },\r\n      arrow: {\r\n        position: 'absolute'\r\n      },\r\n      reference: {}\r\n    };\r\n    Object.assign(state.elements.popper.style, initialStyles.popper);\r\n    state.styles = initialStyles;\r\n\r\n    if (state.elements.arrow) {\r\n      Object.assign(state.elements.arrow.style, initialStyles.arrow);\r\n    }\r\n\r\n    return function () {\r\n      Object.keys(state.elements).forEach(function (name) {\r\n        var element = state.elements[name];\r\n        var attributes = state.attributes[name] || {};\r\n        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\r\n\r\n        var style = styleProperties.reduce(function (style, property) {\r\n          style[property] = '';\r\n          return style;\r\n        }, {}); // arrow is optional + virtual elements\r\n\r\n        if (!isHTMLElement(element) || !getNodeName(element)) {\r\n          return;\r\n        }\r\n\r\n        Object.assign(element.style, style);\r\n        Object.keys(attributes).forEach(function (attribute) {\r\n          element.removeAttribute(attribute);\r\n        });\r\n      });\r\n    };\r\n  } // eslint-disable-next-line import/no-unused-modules\r\n\r\n\r\n  const applyStyles$1 = {\r\n    name: 'applyStyles',\r\n    enabled: true,\r\n    phase: 'write',\r\n    fn: applyStyles,\r\n    effect: effect$2,\r\n    requires: ['computeStyles']\r\n  };\r\n\r\n  function getBasePlacement(placement) {\r\n    return placement.split('-')[0];\r\n  }\r\n\r\n  var max = Math.max;\r\n  var min = Math.min;\r\n  var round = Math.round;\r\n\r\n  function getUAString() {\r\n    var uaData = navigator.userAgentData;\r\n\r\n    if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {\r\n      return uaData.brands.map(function (item) {\r\n        return item.brand + \"/\" + item.version;\r\n      }).join(' ');\r\n    }\r\n\r\n    return navigator.userAgent;\r\n  }\r\n\r\n  function isLayoutViewport() {\r\n    return !/^((?!chrome|android).)*safari/i.test(getUAString());\r\n  }\r\n\r\n  function getBoundingClientRect(element, includeScale, isFixedStrategy) {\r\n    if (includeScale === void 0) {\r\n      includeScale = false;\r\n    }\r\n\r\n    if (isFixedStrategy === void 0) {\r\n      isFixedStrategy = false;\r\n    }\r\n\r\n    var clientRect = element.getBoundingClientRect();\r\n    var scaleX = 1;\r\n    var scaleY = 1;\r\n\r\n    if (includeScale && isHTMLElement(element)) {\r\n      scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\r\n      scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\r\n    }\r\n\r\n    var _ref = isElement(element) ? getWindow(element) : window,\r\n        visualViewport = _ref.visualViewport;\r\n\r\n    var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\r\n    var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;\r\n    var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;\r\n    var width = clientRect.width / scaleX;\r\n    var height = clientRect.height / scaleY;\r\n    return {\r\n      width: width,\r\n      height: height,\r\n      top: y,\r\n      right: x + width,\r\n      bottom: y + height,\r\n      left: x,\r\n      x: x,\r\n      y: y\r\n    };\r\n  }\r\n\r\n  // means it doesn't take into account transforms.\r\n\r\n  function getLayoutRect(element) {\r\n    var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.\r\n    // Fixes https://github.com/popperjs/popper-core/issues/1223\r\n\r\n    var width = element.offsetWidth;\r\n    var height = element.offsetHeight;\r\n\r\n    if (Math.abs(clientRect.width - width) <= 1) {\r\n      width = clientRect.width;\r\n    }\r\n\r\n    if (Math.abs(clientRect.height - height) <= 1) {\r\n      height = clientRect.height;\r\n    }\r\n\r\n    return {\r\n      x: element.offsetLeft,\r\n      y: element.offsetTop,\r\n      width: width,\r\n      height: height\r\n    };\r\n  }\r\n\r\n  function contains(parent, child) {\r\n    var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\r\n\r\n    if (parent.contains(child)) {\r\n      return true;\r\n    } // then fallback to custom implementation with Shadow DOM support\r\n    else if (rootNode && isShadowRoot(rootNode)) {\r\n        var next = child;\r\n\r\n        do {\r\n          if (next && parent.isSameNode(next)) {\r\n            return true;\r\n          } // $FlowFixMe[prop-missing]: need a better way to handle this...\r\n\r\n\r\n          next = next.parentNode || next.host;\r\n        } while (next);\r\n      } // Give up, the result is false\r\n\r\n\r\n    return false;\r\n  }\r\n\r\n  function getComputedStyle$1(element) {\r\n    return getWindow(element).getComputedStyle(element);\r\n  }\r\n\r\n  function isTableElement(element) {\r\n    return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;\r\n  }\r\n\r\n  function getDocumentElement(element) {\r\n    // $FlowFixMe[incompatible-return]: assume body is always available\r\n    return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]\r\n    element.document) || window.document).documentElement;\r\n  }\r\n\r\n  function getParentNode(element) {\r\n    if (getNodeName(element) === 'html') {\r\n      return element;\r\n    }\r\n\r\n    return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\r\n      // $FlowFixMe[incompatible-return]\r\n      // $FlowFixMe[prop-missing]\r\n      element.assignedSlot || // step into the shadow DOM of the parent of a slotted node\r\n      element.parentNode || ( // DOM Element detected\r\n      isShadowRoot(element) ? element.host : null) || // ShadowRoot detected\r\n      // $FlowFixMe[incompatible-call]: HTMLElement is a Node\r\n      getDocumentElement(element) // fallback\r\n\r\n    );\r\n  }\r\n\r\n  function getTrueOffsetParent(element) {\r\n    if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837\r\n    getComputedStyle$1(element).position === 'fixed') {\r\n      return null;\r\n    }\r\n\r\n    return element.offsetParent;\r\n  } // `.offsetParent` reports `null` for fixed elements, while absolute elements\r\n  // return the containing block\r\n\r\n\r\n  function getContainingBlock(element) {\r\n    var isFirefox = /firefox/i.test(getUAString());\r\n    var isIE = /Trident/i.test(getUAString());\r\n\r\n    if (isIE && isHTMLElement(element)) {\r\n      // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport\r\n      var elementCss = getComputedStyle$1(element);\r\n\r\n      if (elementCss.position === 'fixed') {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    var currentNode = getParentNode(element);\r\n\r\n    if (isShadowRoot(currentNode)) {\r\n      currentNode = currentNode.host;\r\n    }\r\n\r\n    while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {\r\n      var css = getComputedStyle$1(currentNode); // This is non-exhaustive but covers the most common CSS properties that\r\n      // create a containing block.\r\n      // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\r\n\r\n      if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {\r\n        return currentNode;\r\n      } else {\r\n        currentNode = currentNode.parentNode;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  } // Gets the closest ancestor positioned element. Handles some edge cases,\r\n  // such as table ancestors and cross browser bugs.\r\n\r\n\r\n  function getOffsetParent(element) {\r\n    var window = getWindow(element);\r\n    var offsetParent = getTrueOffsetParent(element);\r\n\r\n    while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {\r\n      offsetParent = getTrueOffsetParent(offsetParent);\r\n    }\r\n\r\n    if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static')) {\r\n      return window;\r\n    }\r\n\r\n    return offsetParent || getContainingBlock(element) || window;\r\n  }\r\n\r\n  function getMainAxisFromPlacement(placement) {\r\n    return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';\r\n  }\r\n\r\n  function within(min$1, value, max$1) {\r\n    return max(min$1, min(value, max$1));\r\n  }\r\n  function withinMaxClamp(min, value, max) {\r\n    var v = within(min, value, max);\r\n    return v > max ? max : v;\r\n  }\r\n\r\n  function getFreshSideObject() {\r\n    return {\r\n      top: 0,\r\n      right: 0,\r\n      bottom: 0,\r\n      left: 0\r\n    };\r\n  }\r\n\r\n  function mergePaddingObject(paddingObject) {\r\n    return Object.assign({}, getFreshSideObject(), paddingObject);\r\n  }\r\n\r\n  function expandToHashMap(value, keys) {\r\n    return keys.reduce(function (hashMap, key) {\r\n      hashMap[key] = value;\r\n      return hashMap;\r\n    }, {});\r\n  }\r\n\r\n  var toPaddingObject = function toPaddingObject(padding, state) {\r\n    padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {\r\n      placement: state.placement\r\n    })) : padding;\r\n    return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\r\n  };\r\n\r\n  function arrow(_ref) {\r\n    var _state$modifiersData$;\r\n\r\n    var state = _ref.state,\r\n        name = _ref.name,\r\n        options = _ref.options;\r\n    var arrowElement = state.elements.arrow;\r\n    var popperOffsets = state.modifiersData.popperOffsets;\r\n    var basePlacement = getBasePlacement(state.placement);\r\n    var axis = getMainAxisFromPlacement(basePlacement);\r\n    var isVertical = [left, right].indexOf(basePlacement) >= 0;\r\n    var len = isVertical ? 'height' : 'width';\r\n\r\n    if (!arrowElement || !popperOffsets) {\r\n      return;\r\n    }\r\n\r\n    var paddingObject = toPaddingObject(options.padding, state);\r\n    var arrowRect = getLayoutRect(arrowElement);\r\n    var minProp = axis === 'y' ? top : left;\r\n    var maxProp = axis === 'y' ? bottom : right;\r\n    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\r\n    var startDiff = popperOffsets[axis] - state.rects.reference[axis];\r\n    var arrowOffsetParent = getOffsetParent(arrowElement);\r\n    var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\r\n    var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\r\n    // outside of the popper bounds\r\n\r\n    var min = paddingObject[minProp];\r\n    var max = clientSize - arrowRect[len] - paddingObject[maxProp];\r\n    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\r\n    var offset = within(min, center, max); // Prevents breaking syntax highlighting...\r\n\r\n    var axisProp = axis;\r\n    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\r\n  }\r\n\r\n  function effect$1(_ref2) {\r\n    var state = _ref2.state,\r\n        options = _ref2.options;\r\n    var _options$element = options.element,\r\n        arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;\r\n\r\n    if (arrowElement == null) {\r\n      return;\r\n    } // CSS selector\r\n\r\n\r\n    if (typeof arrowElement === 'string') {\r\n      arrowElement = state.elements.popper.querySelector(arrowElement);\r\n\r\n      if (!arrowElement) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (!contains(state.elements.popper, arrowElement)) {\r\n      return;\r\n    }\r\n\r\n    state.elements.arrow = arrowElement;\r\n  } // eslint-disable-next-line import/no-unused-modules\r\n\r\n\r\n  const arrow$1 = {\r\n    name: 'arrow',\r\n    enabled: true,\r\n    phase: 'main',\r\n    fn: arrow,\r\n    effect: effect$1,\r\n    requires: ['popperOffsets'],\r\n    requiresIfExists: ['preventOverflow']\r\n  };\r\n\r\n  function getVariation(placement) {\r\n    return placement.split('-')[1];\r\n  }\r\n\r\n  var unsetSides = {\r\n    top: 'auto',\r\n    right: 'auto',\r\n    bottom: 'auto',\r\n    left: 'auto'\r\n  }; // Round the offsets to the nearest suitable subpixel based on the DPR.\r\n  // Zooming can change the DPR, but it seems to report a value that will\r\n  // cleanly divide the values into the appropriate subpixels.\r\n\r\n  function roundOffsetsByDPR(_ref, win) {\r\n    var x = _ref.x,\r\n        y = _ref.y;\r\n    var dpr = win.devicePixelRatio || 1;\r\n    return {\r\n      x: round(x * dpr) / dpr || 0,\r\n      y: round(y * dpr) / dpr || 0\r\n    };\r\n  }\r\n\r\n  function mapToStyles(_ref2) {\r\n    var _Object$assign2;\r\n\r\n    var popper = _ref2.popper,\r\n        popperRect = _ref2.popperRect,\r\n        placement = _ref2.placement,\r\n        variation = _ref2.variation,\r\n        offsets = _ref2.offsets,\r\n        position = _ref2.position,\r\n        gpuAcceleration = _ref2.gpuAcceleration,\r\n        adaptive = _ref2.adaptive,\r\n        roundOffsets = _ref2.roundOffsets,\r\n        isFixed = _ref2.isFixed;\r\n    var _offsets$x = offsets.x,\r\n        x = _offsets$x === void 0 ? 0 : _offsets$x,\r\n        _offsets$y = offsets.y,\r\n        y = _offsets$y === void 0 ? 0 : _offsets$y;\r\n\r\n    var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({\r\n      x: x,\r\n      y: y\r\n    }) : {\r\n      x: x,\r\n      y: y\r\n    };\r\n\r\n    x = _ref3.x;\r\n    y = _ref3.y;\r\n    var hasX = offsets.hasOwnProperty('x');\r\n    var hasY = offsets.hasOwnProperty('y');\r\n    var sideX = left;\r\n    var sideY = top;\r\n    var win = window;\r\n\r\n    if (adaptive) {\r\n      var offsetParent = getOffsetParent(popper);\r\n      var heightProp = 'clientHeight';\r\n      var widthProp = 'clientWidth';\r\n\r\n      if (offsetParent === getWindow(popper)) {\r\n        offsetParent = getDocumentElement(popper);\r\n\r\n        if (getComputedStyle$1(offsetParent).position !== 'static' && position === 'absolute') {\r\n          heightProp = 'scrollHeight';\r\n          widthProp = 'scrollWidth';\r\n        }\r\n      } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\r\n\r\n\r\n      offsetParent = offsetParent;\r\n\r\n      if (placement === top || (placement === left || placement === right) && variation === end) {\r\n        sideY = bottom;\r\n        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]\r\n        offsetParent[heightProp];\r\n        y -= offsetY - popperRect.height;\r\n        y *= gpuAcceleration ? 1 : -1;\r\n      }\r\n\r\n      if (placement === left || (placement === top || placement === bottom) && variation === end) {\r\n        sideX = right;\r\n        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]\r\n        offsetParent[widthProp];\r\n        x -= offsetX - popperRect.width;\r\n        x *= gpuAcceleration ? 1 : -1;\r\n      }\r\n    }\r\n\r\n    var commonStyles = Object.assign({\r\n      position: position\r\n    }, adaptive && unsetSides);\r\n\r\n    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({\r\n      x: x,\r\n      y: y\r\n    }, getWindow(popper)) : {\r\n      x: x,\r\n      y: y\r\n    };\r\n\r\n    x = _ref4.x;\r\n    y = _ref4.y;\r\n\r\n    if (gpuAcceleration) {\r\n      var _Object$assign;\r\n\r\n      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\r\n    }\r\n\r\n    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : '', _Object$assign2[sideX] = hasX ? x + \"px\" : '', _Object$assign2.transform = '', _Object$assign2));\r\n  }\r\n\r\n  function computeStyles(_ref5) {\r\n    var state = _ref5.state,\r\n        options = _ref5.options;\r\n    var _options$gpuAccelerat = options.gpuAcceleration,\r\n        gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,\r\n        _options$adaptive = options.adaptive,\r\n        adaptive = _options$adaptive === void 0 ? true : _options$adaptive,\r\n        _options$roundOffsets = options.roundOffsets,\r\n        roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\r\n    var commonStyles = {\r\n      placement: getBasePlacement(state.placement),\r\n      variation: getVariation(state.placement),\r\n      popper: state.elements.popper,\r\n      popperRect: state.rects.popper,\r\n      gpuAcceleration: gpuAcceleration,\r\n      isFixed: state.options.strategy === 'fixed'\r\n    };\r\n\r\n    if (state.modifiersData.popperOffsets != null) {\r\n      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\r\n        offsets: state.modifiersData.popperOffsets,\r\n        position: state.options.strategy,\r\n        adaptive: adaptive,\r\n        roundOffsets: roundOffsets\r\n      })));\r\n    }\r\n\r\n    if (state.modifiersData.arrow != null) {\r\n      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\r\n        offsets: state.modifiersData.arrow,\r\n        position: 'absolute',\r\n        adaptive: false,\r\n        roundOffsets: roundOffsets\r\n      })));\r\n    }\r\n\r\n    state.attributes.popper = Object.assign({}, state.attributes.popper, {\r\n      'data-popper-placement': state.placement\r\n    });\r\n  } // eslint-disable-next-line import/no-unused-modules\r\n\r\n\r\n  const computeStyles$1 = {\r\n    name: 'computeStyles',\r\n    enabled: true,\r\n    phase: 'beforeWrite',\r\n    fn: computeStyles,\r\n    data: {}\r\n  };\r\n\r\n  var passive = {\r\n    passive: true\r\n  };\r\n\r\n  function effect(_ref) {\r\n    var state = _ref.state,\r\n        instance = _ref.instance,\r\n        options = _ref.options;\r\n    var _options$scroll = options.scroll,\r\n        scroll = _options$scroll === void 0 ? true : _options$scroll,\r\n        _options$resize = options.resize,\r\n        resize = _options$resize === void 0 ? true : _options$resize;\r\n    var window = getWindow(state.elements.popper);\r\n    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\r\n\r\n    if (scroll) {\r\n      scrollParents.forEach(function (scrollParent) {\r\n        scrollParent.addEventListener('scroll', instance.update, passive);\r\n      });\r\n    }\r\n\r\n    if (resize) {\r\n      window.addEventListener('resize', instance.update, passive);\r\n    }\r\n\r\n    return function () {\r\n      if (scroll) {\r\n        scrollParents.forEach(function (scrollParent) {\r\n          scrollParent.removeEventListener('scroll', instance.update, passive);\r\n        });\r\n      }\r\n\r\n      if (resize) {\r\n        window.removeEventListener('resize', instance.update, passive);\r\n      }\r\n    };\r\n  } // eslint-disable-next-line import/no-unused-modules\r\n\r\n\r\n  const eventListeners = {\r\n    name: 'eventListeners',\r\n    enabled: true,\r\n    phase: 'write',\r\n    fn: function fn() {},\r\n    effect: effect,\r\n    data: {}\r\n  };\r\n\r\n  var hash$1 = {\r\n    left: 'right',\r\n    right: 'left',\r\n    bottom: 'top',\r\n    top: 'bottom'\r\n  };\r\n  function getOppositePlacement(placement) {\r\n    return placement.replace(/left|right|bottom|top/g, function (matched) {\r\n      return hash$1[matched];\r\n    });\r\n  }\r\n\r\n  var hash = {\r\n    start: 'end',\r\n    end: 'start'\r\n  };\r\n  function getOppositeVariationPlacement(placement) {\r\n    return placement.replace(/start|end/g, function (matched) {\r\n      return hash[matched];\r\n    });\r\n  }\r\n\r\n  function getWindowScroll(node) {\r\n    var win = getWindow(node);\r\n    var scrollLeft = win.pageXOffset;\r\n    var scrollTop = win.pageYOffset;\r\n    return {\r\n      scrollLeft: scrollLeft,\r\n      scrollTop: scrollTop\r\n    };\r\n  }\r\n\r\n  function getWindowScrollBarX(element) {\r\n    // If <html> has a CSS width greater than the viewport, then this will be\r\n    // incorrect for RTL.\r\n    // Popper 1 is broken in this case and never had a bug report so let's assume\r\n    // it's not an issue. I don't think anyone ever specifies width on <html>\r\n    // anyway.\r\n    // Browsers where the left scrollbar doesn't cause an issue report `0` for\r\n    // this (e.g. Edge 2019, IE11, Safari)\r\n    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\r\n  }\r\n\r\n  function getViewportRect(element, strategy) {\r\n    var win = getWindow(element);\r\n    var html = getDocumentElement(element);\r\n    var visualViewport = win.visualViewport;\r\n    var width = html.clientWidth;\r\n    var height = html.clientHeight;\r\n    var x = 0;\r\n    var y = 0;\r\n\r\n    if (visualViewport) {\r\n      width = visualViewport.width;\r\n      height = visualViewport.height;\r\n      var layoutViewport = isLayoutViewport();\r\n\r\n      if (layoutViewport || !layoutViewport && strategy === 'fixed') {\r\n        x = visualViewport.offsetLeft;\r\n        y = visualViewport.offsetTop;\r\n      }\r\n    }\r\n\r\n    return {\r\n      width: width,\r\n      height: height,\r\n      x: x + getWindowScrollBarX(element),\r\n      y: y\r\n    };\r\n  }\r\n\r\n  // of the `<html>` and `<body>` rect bounds if horizontally scrollable\r\n\r\n  function getDocumentRect(element) {\r\n    var _element$ownerDocumen;\r\n\r\n    var html = getDocumentElement(element);\r\n    var winScroll = getWindowScroll(element);\r\n    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\r\n    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\r\n    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\r\n    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);\r\n    var y = -winScroll.scrollTop;\r\n\r\n    if (getComputedStyle$1(body || html).direction === 'rtl') {\r\n      x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\r\n    }\r\n\r\n    return {\r\n      width: width,\r\n      height: height,\r\n      x: x,\r\n      y: y\r\n    };\r\n  }\r\n\r\n  function isScrollParent(element) {\r\n    // Firefox wants us to check `-x` and `-y` variations as well\r\n    var _getComputedStyle = getComputedStyle$1(element),\r\n        overflow = _getComputedStyle.overflow,\r\n        overflowX = _getComputedStyle.overflowX,\r\n        overflowY = _getComputedStyle.overflowY;\r\n\r\n    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\r\n  }\r\n\r\n  function getScrollParent(node) {\r\n    if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {\r\n      // $FlowFixMe[incompatible-return]: assume body is always available\r\n      return node.ownerDocument.body;\r\n    }\r\n\r\n    if (isHTMLElement(node) && isScrollParent(node)) {\r\n      return node;\r\n    }\r\n\r\n    return getScrollParent(getParentNode(node));\r\n  }\r\n\r\n  /*\r\n  given a DOM element, return the list of all scroll parents, up the list of ancesors\r\n  until we get to the top window object. This list is what we attach scroll listeners\r\n  to, because if any of these parent elements scroll, we'll need to re-calculate the\r\n  reference element's position.\r\n  */\r\n\r\n  function listScrollParents(element, list) {\r\n    var _element$ownerDocumen;\r\n\r\n    if (list === void 0) {\r\n      list = [];\r\n    }\r\n\r\n    var scrollParent = getScrollParent(element);\r\n    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\r\n    var win = getWindow(scrollParent);\r\n    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\r\n    var updatedList = list.concat(target);\r\n    return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\r\n    updatedList.concat(listScrollParents(getParentNode(target)));\r\n  }\r\n\r\n  function rectToClientRect(rect) {\r\n    return Object.assign({}, rect, {\r\n      left: rect.x,\r\n      top: rect.y,\r\n      right: rect.x + rect.width,\r\n      bottom: rect.y + rect.height\r\n    });\r\n  }\r\n\r\n  function getInnerBoundingClientRect(element, strategy) {\r\n    var rect = getBoundingClientRect(element, false, strategy === 'fixed');\r\n    rect.top = rect.top + element.clientTop;\r\n    rect.left = rect.left + element.clientLeft;\r\n    rect.bottom = rect.top + element.clientHeight;\r\n    rect.right = rect.left + element.clientWidth;\r\n    rect.width = element.clientWidth;\r\n    rect.height = element.clientHeight;\r\n    rect.x = rect.left;\r\n    rect.y = rect.top;\r\n    return rect;\r\n  }\r\n\r\n  function getClientRectFromMixedType(element, clippingParent, strategy) {\r\n    return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\r\n  } // A \"clipping parent\" is an overflowable container with the characteristic of\r\n  // clipping (or hiding) overflowing elements with a position different from\r\n  // `initial`\r\n\r\n\r\n  function getClippingParents(element) {\r\n    var clippingParents = listScrollParents(getParentNode(element));\r\n    var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle$1(element).position) >= 0;\r\n    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\r\n\r\n    if (!isElement(clipperElement)) {\r\n      return [];\r\n    } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414\r\n\r\n\r\n    return clippingParents.filter(function (clippingParent) {\r\n      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';\r\n    });\r\n  } // Gets the maximum area that the element is visible in due to any number of\r\n  // clipping parents\r\n\r\n\r\n  function getClippingRect(element, boundary, rootBoundary, strategy) {\r\n    var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\r\n    var clippingParents = [].concat(mainClippingParents, [rootBoundary]);\r\n    var firstClippingParent = clippingParents[0];\r\n    var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {\r\n      var rect = getClientRectFromMixedType(element, clippingParent, strategy);\r\n      accRect.top = max(rect.top, accRect.top);\r\n      accRect.right = min(rect.right, accRect.right);\r\n      accRect.bottom = min(rect.bottom, accRect.bottom);\r\n      accRect.left = max(rect.left, accRect.left);\r\n      return accRect;\r\n    }, getClientRectFromMixedType(element, firstClippingParent, strategy));\r\n    clippingRect.width = clippingRect.right - clippingRect.left;\r\n    clippingRect.height = clippingRect.bottom - clippingRect.top;\r\n    clippingRect.x = clippingRect.left;\r\n    clippingRect.y = clippingRect.top;\r\n    return clippingRect;\r\n  }\r\n\r\n  function computeOffsets(_ref) {\r\n    var reference = _ref.reference,\r\n        element = _ref.element,\r\n        placement = _ref.placement;\r\n    var basePlacement = placement ? getBasePlacement(placement) : null;\r\n    var variation = placement ? getVariation(placement) : null;\r\n    var commonX = reference.x + reference.width / 2 - element.width / 2;\r\n    var commonY = reference.y + reference.height / 2 - element.height / 2;\r\n    var offsets;\r\n\r\n    switch (basePlacement) {\r\n      case top:\r\n        offsets = {\r\n          x: commonX,\r\n          y: reference.y - element.height\r\n        };\r\n        break;\r\n\r\n      case bottom:\r\n        offsets = {\r\n          x: commonX,\r\n          y: reference.y + reference.height\r\n        };\r\n        break;\r\n\r\n      case right:\r\n        offsets = {\r\n          x: reference.x + reference.width,\r\n          y: commonY\r\n        };\r\n        break;\r\n\r\n      case left:\r\n        offsets = {\r\n          x: reference.x - element.width,\r\n          y: commonY\r\n        };\r\n        break;\r\n\r\n      default:\r\n        offsets = {\r\n          x: reference.x,\r\n          y: reference.y\r\n        };\r\n    }\r\n\r\n    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\r\n\r\n    if (mainAxis != null) {\r\n      var len = mainAxis === 'y' ? 'height' : 'width';\r\n\r\n      switch (variation) {\r\n        case start:\r\n          offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);\r\n          break;\r\n\r\n        case end:\r\n          offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);\r\n          break;\r\n      }\r\n    }\r\n\r\n    return offsets;\r\n  }\r\n\r\n  function detectOverflow(state, options) {\r\n    if (options === void 0) {\r\n      options = {};\r\n    }\r\n\r\n    var _options = options,\r\n        _options$placement = _options.placement,\r\n        placement = _options$placement === void 0 ? state.placement : _options$placement,\r\n        _options$strategy = _options.strategy,\r\n        strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,\r\n        _options$boundary = _options.boundary,\r\n        boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,\r\n        _options$rootBoundary = _options.rootBoundary,\r\n        rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,\r\n        _options$elementConte = _options.elementContext,\r\n        elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,\r\n        _options$altBoundary = _options.altBoundary,\r\n        altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,\r\n        _options$padding = _options.padding,\r\n        padding = _options$padding === void 0 ? 0 : _options$padding;\r\n    var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\r\n    var altContext = elementContext === popper ? reference : popper;\r\n    var popperRect = state.rects.popper;\r\n    var element = state.elements[altBoundary ? altContext : elementContext];\r\n    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);\r\n    var referenceClientRect = getBoundingClientRect(state.elements.reference);\r\n    var popperOffsets = computeOffsets({\r\n      reference: referenceClientRect,\r\n      element: popperRect,\r\n      strategy: 'absolute',\r\n      placement: placement\r\n    });\r\n    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));\r\n    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\r\n    // 0 or negative = within the clipping rect\r\n\r\n    var overflowOffsets = {\r\n      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\r\n      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\r\n      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\r\n      right: elementClientRect.right - clippingClientRect.right + paddingObject.right\r\n    };\r\n    var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\r\n\r\n    if (elementContext === popper && offsetData) {\r\n      var offset = offsetData[placement];\r\n      Object.keys(overflowOffsets).forEach(function (key) {\r\n        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\r\n        var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\r\n        overflowOffsets[key] += offset[axis] * multiply;\r\n      });\r\n    }\r\n\r\n    return overflowOffsets;\r\n  }\r\n\r\n  function computeAutoPlacement(state, options) {\r\n    if (options === void 0) {\r\n      options = {};\r\n    }\r\n\r\n    var _options = options,\r\n        placement = _options.placement,\r\n        boundary = _options.boundary,\r\n        rootBoundary = _options.rootBoundary,\r\n        padding = _options.padding,\r\n        flipVariations = _options.flipVariations,\r\n        _options$allowedAutoP = _options.allowedAutoPlacements,\r\n        allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;\r\n    var variation = getVariation(placement);\r\n    var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {\r\n      return getVariation(placement) === variation;\r\n    }) : basePlacements;\r\n    var allowedPlacements = placements$1.filter(function (placement) {\r\n      return allowedAutoPlacements.indexOf(placement) >= 0;\r\n    });\r\n\r\n    if (allowedPlacements.length === 0) {\r\n      allowedPlacements = placements$1;\r\n    } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...\r\n\r\n\r\n    var overflows = allowedPlacements.reduce(function (acc, placement) {\r\n      acc[placement] = detectOverflow(state, {\r\n        placement: placement,\r\n        boundary: boundary,\r\n        rootBoundary: rootBoundary,\r\n        padding: padding\r\n      })[getBasePlacement(placement)];\r\n      return acc;\r\n    }, {});\r\n    return Object.keys(overflows).sort(function (a, b) {\r\n      return overflows[a] - overflows[b];\r\n    });\r\n  }\r\n\r\n  function getExpandedFallbackPlacements(placement) {\r\n    if (getBasePlacement(placement) === auto) {\r\n      return [];\r\n    }\r\n\r\n    var oppositePlacement = getOppositePlacement(placement);\r\n    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\r\n  }\r\n\r\n  function flip(_ref) {\r\n    var state = _ref.state,\r\n        options = _ref.options,\r\n        name = _ref.name;\r\n\r\n    if (state.modifiersData[name]._skip) {\r\n      return;\r\n    }\r\n\r\n    var _options$mainAxis = options.mainAxis,\r\n        checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\r\n        _options$altAxis = options.altAxis,\r\n        checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,\r\n        specifiedFallbackPlacements = options.fallbackPlacements,\r\n        padding = options.padding,\r\n        boundary = options.boundary,\r\n        rootBoundary = options.rootBoundary,\r\n        altBoundary = options.altBoundary,\r\n        _options$flipVariatio = options.flipVariations,\r\n        flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,\r\n        allowedAutoPlacements = options.allowedAutoPlacements;\r\n    var preferredPlacement = state.options.placement;\r\n    var basePlacement = getBasePlacement(preferredPlacement);\r\n    var isBasePlacement = basePlacement === preferredPlacement;\r\n    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\r\n    var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {\r\n      return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\r\n        placement: placement,\r\n        boundary: boundary,\r\n        rootBoundary: rootBoundary,\r\n        padding: padding,\r\n        flipVariations: flipVariations,\r\n        allowedAutoPlacements: allowedAutoPlacements\r\n      }) : placement);\r\n    }, []);\r\n    var referenceRect = state.rects.reference;\r\n    var popperRect = state.rects.popper;\r\n    var checksMap = new Map();\r\n    var makeFallbackChecks = true;\r\n    var firstFittingPlacement = placements[0];\r\n\r\n    for (var i = 0; i < placements.length; i++) {\r\n      var placement = placements[i];\r\n\r\n      var _basePlacement = getBasePlacement(placement);\r\n\r\n      var isStartVariation = getVariation(placement) === start;\r\n      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;\r\n      var len = isVertical ? 'width' : 'height';\r\n      var overflow = detectOverflow(state, {\r\n        placement: placement,\r\n        boundary: boundary,\r\n        rootBoundary: rootBoundary,\r\n        altBoundary: altBoundary,\r\n        padding: padding\r\n      });\r\n      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\r\n\r\n      if (referenceRect[len] > popperRect[len]) {\r\n        mainVariationSide = getOppositePlacement(mainVariationSide);\r\n      }\r\n\r\n      var altVariationSide = getOppositePlacement(mainVariationSide);\r\n      var checks = [];\r\n\r\n      if (checkMainAxis) {\r\n        checks.push(overflow[_basePlacement] <= 0);\r\n      }\r\n\r\n      if (checkAltAxis) {\r\n        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\r\n      }\r\n\r\n      if (checks.every(function (check) {\r\n        return check;\r\n      })) {\r\n        firstFittingPlacement = placement;\r\n        makeFallbackChecks = false;\r\n        break;\r\n      }\r\n\r\n      checksMap.set(placement, checks);\r\n    }\r\n\r\n    if (makeFallbackChecks) {\r\n      // `2` may be desired in some cases – research later\r\n      var numberOfChecks = flipVariations ? 3 : 1;\r\n\r\n      var _loop = function _loop(_i) {\r\n        var fittingPlacement = placements.find(function (placement) {\r\n          var checks = checksMap.get(placement);\r\n\r\n          if (checks) {\r\n            return checks.slice(0, _i).every(function (check) {\r\n              return check;\r\n            });\r\n          }\r\n        });\r\n\r\n        if (fittingPlacement) {\r\n          firstFittingPlacement = fittingPlacement;\r\n          return \"break\";\r\n        }\r\n      };\r\n\r\n      for (var _i = numberOfChecks; _i > 0; _i--) {\r\n        var _ret = _loop(_i);\r\n\r\n        if (_ret === \"break\") break;\r\n      }\r\n    }\r\n\r\n    if (state.placement !== firstFittingPlacement) {\r\n      state.modifiersData[name]._skip = true;\r\n      state.placement = firstFittingPlacement;\r\n      state.reset = true;\r\n    }\r\n  } // eslint-disable-next-line import/no-unused-modules\r\n\r\n\r\n  const flip$1 = {\r\n    name: 'flip',\r\n    enabled: true,\r\n    phase: 'main',\r\n    fn: flip,\r\n    requiresIfExists: ['offset'],\r\n    data: {\r\n      _skip: false\r\n    }\r\n  };\r\n\r\n  function getSideOffsets(overflow, rect, preventedOffsets) {\r\n    if (preventedOffsets === void 0) {\r\n      preventedOffsets = {\r\n        x: 0,\r\n        y: 0\r\n      };\r\n    }\r\n\r\n    return {\r\n      top: overflow.top - rect.height - preventedOffsets.y,\r\n      right: overflow.right - rect.width + preventedOffsets.x,\r\n      bottom: overflow.bottom - rect.height + preventedOffsets.y,\r\n      left: overflow.left - rect.width - preventedOffsets.x\r\n    };\r\n  }\r\n\r\n  function isAnySideFullyClipped(overflow) {\r\n    return [top, right, bottom, left].some(function (side) {\r\n      return overflow[side] >= 0;\r\n    });\r\n  }\r\n\r\n  function hide(_ref) {\r\n    var state = _ref.state,\r\n        name = _ref.name;\r\n    var referenceRect = state.rects.reference;\r\n    var popperRect = state.rects.popper;\r\n    var preventedOffsets = state.modifiersData.preventOverflow;\r\n    var referenceOverflow = detectOverflow(state, {\r\n      elementContext: 'reference'\r\n    });\r\n    var popperAltOverflow = detectOverflow(state, {\r\n      altBoundary: true\r\n    });\r\n    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\r\n    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\r\n    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\r\n    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\r\n    state.modifiersData[name] = {\r\n      referenceClippingOffsets: referenceClippingOffsets,\r\n      popperEscapeOffsets: popperEscapeOffsets,\r\n      isReferenceHidden: isReferenceHidden,\r\n      hasPopperEscaped: hasPopperEscaped\r\n    };\r\n    state.attributes.popper = Object.assign({}, state.attributes.popper, {\r\n      'data-popper-reference-hidden': isReferenceHidden,\r\n      'data-popper-escaped': hasPopperEscaped\r\n    });\r\n  } // eslint-disable-next-line import/no-unused-modules\r\n\r\n\r\n  const hide$1 = {\r\n    name: 'hide',\r\n    enabled: true,\r\n    phase: 'main',\r\n    requiresIfExists: ['preventOverflow'],\r\n    fn: hide\r\n  };\r\n\r\n  function distanceAndSkiddingToXY(placement, rects, offset) {\r\n    var basePlacement = getBasePlacement(placement);\r\n    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;\r\n\r\n    var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {\r\n      placement: placement\r\n    })) : offset,\r\n        skidding = _ref[0],\r\n        distance = _ref[1];\r\n\r\n    skidding = skidding || 0;\r\n    distance = (distance || 0) * invertDistance;\r\n    return [left, right].indexOf(basePlacement) >= 0 ? {\r\n      x: distance,\r\n      y: skidding\r\n    } : {\r\n      x: skidding,\r\n      y: distance\r\n    };\r\n  }\r\n\r\n  function offset(_ref2) {\r\n    var state = _ref2.state,\r\n        options = _ref2.options,\r\n        name = _ref2.name;\r\n    var _options$offset = options.offset,\r\n        offset = _options$offset === void 0 ? [0, 0] : _options$offset;\r\n    var data = placements.reduce(function (acc, placement) {\r\n      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\r\n      return acc;\r\n    }, {});\r\n    var _data$state$placement = data[state.placement],\r\n        x = _data$state$placement.x,\r\n        y = _data$state$placement.y;\r\n\r\n    if (state.modifiersData.popperOffsets != null) {\r\n      state.modifiersData.popperOffsets.x += x;\r\n      state.modifiersData.popperOffsets.y += y;\r\n    }\r\n\r\n    state.modifiersData[name] = data;\r\n  } // eslint-disable-next-line import/no-unused-modules\r\n\r\n\r\n  const offset$1 = {\r\n    name: 'offset',\r\n    enabled: true,\r\n    phase: 'main',\r\n    requires: ['popperOffsets'],\r\n    fn: offset\r\n  };\r\n\r\n  function popperOffsets(_ref) {\r\n    var state = _ref.state,\r\n        name = _ref.name;\r\n    // Offsets are the actual position the popper needs to have to be\r\n    // properly positioned near its reference element\r\n    // This is the most basic placement, and will be adjusted by\r\n    // the modifiers in the next step\r\n    state.modifiersData[name] = computeOffsets({\r\n      reference: state.rects.reference,\r\n      element: state.rects.popper,\r\n      strategy: 'absolute',\r\n      placement: state.placement\r\n    });\r\n  } // eslint-disable-next-line import/no-unused-modules\r\n\r\n\r\n  const popperOffsets$1 = {\r\n    name: 'popperOffsets',\r\n    enabled: true,\r\n    phase: 'read',\r\n    fn: popperOffsets,\r\n    data: {}\r\n  };\r\n\r\n  function getAltAxis(axis) {\r\n    return axis === 'x' ? 'y' : 'x';\r\n  }\r\n\r\n  function preventOverflow(_ref) {\r\n    var state = _ref.state,\r\n        options = _ref.options,\r\n        name = _ref.name;\r\n    var _options$mainAxis = options.mainAxis,\r\n        checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\r\n        _options$altAxis = options.altAxis,\r\n        checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\r\n        boundary = options.boundary,\r\n        rootBoundary = options.rootBoundary,\r\n        altBoundary = options.altBoundary,\r\n        padding = options.padding,\r\n        _options$tether = options.tether,\r\n        tether = _options$tether === void 0 ? true : _options$tether,\r\n        _options$tetherOffset = options.tetherOffset,\r\n        tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\r\n    var overflow = detectOverflow(state, {\r\n      boundary: boundary,\r\n      rootBoundary: rootBoundary,\r\n      padding: padding,\r\n      altBoundary: altBoundary\r\n    });\r\n    var basePlacement = getBasePlacement(state.placement);\r\n    var variation = getVariation(state.placement);\r\n    var isBasePlacement = !variation;\r\n    var mainAxis = getMainAxisFromPlacement(basePlacement);\r\n    var altAxis = getAltAxis(mainAxis);\r\n    var popperOffsets = state.modifiersData.popperOffsets;\r\n    var referenceRect = state.rects.reference;\r\n    var popperRect = state.rects.popper;\r\n    var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {\r\n      placement: state.placement\r\n    })) : tetherOffset;\r\n    var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {\r\n      mainAxis: tetherOffsetValue,\r\n      altAxis: tetherOffsetValue\r\n    } : Object.assign({\r\n      mainAxis: 0,\r\n      altAxis: 0\r\n    }, tetherOffsetValue);\r\n    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;\r\n    var data = {\r\n      x: 0,\r\n      y: 0\r\n    };\r\n\r\n    if (!popperOffsets) {\r\n      return;\r\n    }\r\n\r\n    if (checkMainAxis) {\r\n      var _offsetModifierState$;\r\n\r\n      var mainSide = mainAxis === 'y' ? top : left;\r\n      var altSide = mainAxis === 'y' ? bottom : right;\r\n      var len = mainAxis === 'y' ? 'height' : 'width';\r\n      var offset = popperOffsets[mainAxis];\r\n      var min$1 = offset + overflow[mainSide];\r\n      var max$1 = offset - overflow[altSide];\r\n      var additive = tether ? -popperRect[len] / 2 : 0;\r\n      var minLen = variation === start ? referenceRect[len] : popperRect[len];\r\n      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\r\n      // outside the reference bounds\r\n\r\n      var arrowElement = state.elements.arrow;\r\n      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\r\n        width: 0,\r\n        height: 0\r\n      };\r\n      var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\r\n      var arrowPaddingMin = arrowPaddingObject[mainSide];\r\n      var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\r\n      // to include its full size in the calculation. If the reference is small\r\n      // and near the edge of a boundary, the popper can overflow even if the\r\n      // reference is not overflowing as well (e.g. virtual elements with no\r\n      // width or height)\r\n\r\n      var arrowLen = within(0, referenceRect[len], arrowRect[len]);\r\n      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;\r\n      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;\r\n      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\r\n      var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\r\n      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;\r\n      var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;\r\n      var tetherMax = offset + maxOffset - offsetModifierValue;\r\n      var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);\r\n      popperOffsets[mainAxis] = preventedOffset;\r\n      data[mainAxis] = preventedOffset - offset;\r\n    }\r\n\r\n    if (checkAltAxis) {\r\n      var _offsetModifierState$2;\r\n\r\n      var _mainSide = mainAxis === 'x' ? top : left;\r\n\r\n      var _altSide = mainAxis === 'x' ? bottom : right;\r\n\r\n      var _offset = popperOffsets[altAxis];\r\n\r\n      var _len = altAxis === 'y' ? 'height' : 'width';\r\n\r\n      var _min = _offset + overflow[_mainSide];\r\n\r\n      var _max = _offset - overflow[_altSide];\r\n\r\n      var isOriginSide = [top, left].indexOf(basePlacement) !== -1;\r\n\r\n      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;\r\n\r\n      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;\r\n\r\n      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;\r\n\r\n      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);\r\n\r\n      popperOffsets[altAxis] = _preventedOffset;\r\n      data[altAxis] = _preventedOffset - _offset;\r\n    }\r\n\r\n    state.modifiersData[name] = data;\r\n  } // eslint-disable-next-line import/no-unused-modules\r\n\r\n\r\n  const preventOverflow$1 = {\r\n    name: 'preventOverflow',\r\n    enabled: true,\r\n    phase: 'main',\r\n    fn: preventOverflow,\r\n    requiresIfExists: ['offset']\r\n  };\r\n\r\n  function getHTMLElementScroll(element) {\r\n    return {\r\n      scrollLeft: element.scrollLeft,\r\n      scrollTop: element.scrollTop\r\n    };\r\n  }\r\n\r\n  function getNodeScroll(node) {\r\n    if (node === getWindow(node) || !isHTMLElement(node)) {\r\n      return getWindowScroll(node);\r\n    } else {\r\n      return getHTMLElementScroll(node);\r\n    }\r\n  }\r\n\r\n  function isElementScaled(element) {\r\n    var rect = element.getBoundingClientRect();\r\n    var scaleX = round(rect.width) / element.offsetWidth || 1;\r\n    var scaleY = round(rect.height) / element.offsetHeight || 1;\r\n    return scaleX !== 1 || scaleY !== 1;\r\n  } // Returns the composite rect of an element relative to its offsetParent.\r\n  // Composite means it takes into account transforms as well as layout.\r\n\r\n\r\n  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\r\n    if (isFixed === void 0) {\r\n      isFixed = false;\r\n    }\r\n\r\n    var isOffsetParentAnElement = isHTMLElement(offsetParent);\r\n    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);\r\n    var documentElement = getDocumentElement(offsetParent);\r\n    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);\r\n    var scroll = {\r\n      scrollLeft: 0,\r\n      scrollTop: 0\r\n    };\r\n    var offsets = {\r\n      x: 0,\r\n      y: 0\r\n    };\r\n\r\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\r\n      if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078\r\n      isScrollParent(documentElement)) {\r\n        scroll = getNodeScroll(offsetParent);\r\n      }\r\n\r\n      if (isHTMLElement(offsetParent)) {\r\n        offsets = getBoundingClientRect(offsetParent, true);\r\n        offsets.x += offsetParent.clientLeft;\r\n        offsets.y += offsetParent.clientTop;\r\n      } else if (documentElement) {\r\n        offsets.x = getWindowScrollBarX(documentElement);\r\n      }\r\n    }\r\n\r\n    return {\r\n      x: rect.left + scroll.scrollLeft - offsets.x,\r\n      y: rect.top + scroll.scrollTop - offsets.y,\r\n      width: rect.width,\r\n      height: rect.height\r\n    };\r\n  }\r\n\r\n  function order(modifiers) {\r\n    var map = new Map();\r\n    var visited = new Set();\r\n    var result = [];\r\n    modifiers.forEach(function (modifier) {\r\n      map.set(modifier.name, modifier);\r\n    }); // On visiting object, check for its dependencies and visit them recursively\r\n\r\n    function sort(modifier) {\r\n      visited.add(modifier.name);\r\n      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\r\n      requires.forEach(function (dep) {\r\n        if (!visited.has(dep)) {\r\n          var depModifier = map.get(dep);\r\n\r\n          if (depModifier) {\r\n            sort(depModifier);\r\n          }\r\n        }\r\n      });\r\n      result.push(modifier);\r\n    }\r\n\r\n    modifiers.forEach(function (modifier) {\r\n      if (!visited.has(modifier.name)) {\r\n        // check for visited object\r\n        sort(modifier);\r\n      }\r\n    });\r\n    return result;\r\n  }\r\n\r\n  function orderModifiers(modifiers) {\r\n    // order based on dependencies\r\n    var orderedModifiers = order(modifiers); // order based on phase\r\n\r\n    return modifierPhases.reduce(function (acc, phase) {\r\n      return acc.concat(orderedModifiers.filter(function (modifier) {\r\n        return modifier.phase === phase;\r\n      }));\r\n    }, []);\r\n  }\r\n\r\n  function debounce(fn) {\r\n    var pending;\r\n    return function () {\r\n      if (!pending) {\r\n        pending = new Promise(function (resolve) {\r\n          Promise.resolve().then(function () {\r\n            pending = undefined;\r\n            resolve(fn());\r\n          });\r\n        });\r\n      }\r\n\r\n      return pending;\r\n    };\r\n  }\r\n\r\n  function mergeByName(modifiers) {\r\n    var merged = modifiers.reduce(function (merged, current) {\r\n      var existing = merged[current.name];\r\n      merged[current.name] = existing ? Object.assign({}, existing, current, {\r\n        options: Object.assign({}, existing.options, current.options),\r\n        data: Object.assign({}, existing.data, current.data)\r\n      }) : current;\r\n      return merged;\r\n    }, {}); // IE11 does not support Object.values\r\n\r\n    return Object.keys(merged).map(function (key) {\r\n      return merged[key];\r\n    });\r\n  }\r\n\r\n  var DEFAULT_OPTIONS = {\r\n    placement: 'bottom',\r\n    modifiers: [],\r\n    strategy: 'absolute'\r\n  };\r\n\r\n  function areValidElements() {\r\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\r\n      args[_key] = arguments[_key];\r\n    }\r\n\r\n    return !args.some(function (element) {\r\n      return !(element && typeof element.getBoundingClientRect === 'function');\r\n    });\r\n  }\r\n\r\n  function popperGenerator(generatorOptions) {\r\n    if (generatorOptions === void 0) {\r\n      generatorOptions = {};\r\n    }\r\n\r\n    var _generatorOptions = generatorOptions,\r\n        _generatorOptions$def = _generatorOptions.defaultModifiers,\r\n        defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\r\n        _generatorOptions$def2 = _generatorOptions.defaultOptions,\r\n        defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\r\n    return function createPopper(reference, popper, options) {\r\n      if (options === void 0) {\r\n        options = defaultOptions;\r\n      }\r\n\r\n      var state = {\r\n        placement: 'bottom',\r\n        orderedModifiers: [],\r\n        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\r\n        modifiersData: {},\r\n        elements: {\r\n          reference: reference,\r\n          popper: popper\r\n        },\r\n        attributes: {},\r\n        styles: {}\r\n      };\r\n      var effectCleanupFns = [];\r\n      var isDestroyed = false;\r\n      var instance = {\r\n        state: state,\r\n        setOptions: function setOptions(setOptionsAction) {\r\n          var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;\r\n          cleanupModifierEffects();\r\n          state.options = Object.assign({}, defaultOptions, state.options, options);\r\n          state.scrollParents = {\r\n            reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\r\n            popper: listScrollParents(popper)\r\n          }; // Orders the modifiers based on their dependencies and `phase`\r\n          // properties\r\n\r\n          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\r\n\r\n          state.orderedModifiers = orderedModifiers.filter(function (m) {\r\n            return m.enabled;\r\n          });\r\n          runModifierEffects();\r\n          return instance.update();\r\n        },\r\n        // Sync update – it will always be executed, even if not necessary. This\r\n        // is useful for low frequency updates where sync behavior simplifies the\r\n        // logic.\r\n        // For high frequency updates (e.g. `resize` and `scroll` events), always\r\n        // prefer the async Popper#update method\r\n        forceUpdate: function forceUpdate() {\r\n          if (isDestroyed) {\r\n            return;\r\n          }\r\n\r\n          var _state$elements = state.elements,\r\n              reference = _state$elements.reference,\r\n              popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\r\n          // anymore\r\n\r\n          if (!areValidElements(reference, popper)) {\r\n            return;\r\n          } // Store the reference and popper rects to be read by modifiers\r\n\r\n\r\n          state.rects = {\r\n            reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\r\n            popper: getLayoutRect(popper)\r\n          }; // Modifiers have the ability to reset the current update cycle. The\r\n          // most common use case for this is the `flip` modifier changing the\r\n          // placement, which then needs to re-run all the modifiers, because the\r\n          // logic was previously ran for the previous placement and is therefore\r\n          // stale/incorrect\r\n\r\n          state.reset = false;\r\n          state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\r\n          // is filled with the initial data specified by the modifier. This means\r\n          // it doesn't persist and is fresh on each update.\r\n          // To ensure persistent data, use `${name}#persistent`\r\n\r\n          state.orderedModifiers.forEach(function (modifier) {\r\n            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\r\n          });\r\n\r\n          for (var index = 0; index < state.orderedModifiers.length; index++) {\r\n            if (state.reset === true) {\r\n              state.reset = false;\r\n              index = -1;\r\n              continue;\r\n            }\r\n\r\n            var _state$orderedModifie = state.orderedModifiers[index],\r\n                fn = _state$orderedModifie.fn,\r\n                _state$orderedModifie2 = _state$orderedModifie.options,\r\n                _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\r\n                name = _state$orderedModifie.name;\r\n\r\n            if (typeof fn === 'function') {\r\n              state = fn({\r\n                state: state,\r\n                options: _options,\r\n                name: name,\r\n                instance: instance\r\n              }) || state;\r\n            }\r\n          }\r\n        },\r\n        // Async and optimistically optimized update – it will not be executed if\r\n        // not necessary (debounced to run at most once-per-tick)\r\n        update: debounce(function () {\r\n          return new Promise(function (resolve) {\r\n            instance.forceUpdate();\r\n            resolve(state);\r\n          });\r\n        }),\r\n        destroy: function destroy() {\r\n          cleanupModifierEffects();\r\n          isDestroyed = true;\r\n        }\r\n      };\r\n\r\n      if (!areValidElements(reference, popper)) {\r\n        return instance;\r\n      }\r\n\r\n      instance.setOptions(options).then(function (state) {\r\n        if (!isDestroyed && options.onFirstUpdate) {\r\n          options.onFirstUpdate(state);\r\n        }\r\n      }); // Modifiers have the ability to execute arbitrary code before the first\r\n      // update cycle runs. They will be executed in the same order as the update\r\n      // cycle. This is useful when a modifier adds some persistent data that\r\n      // other modifiers need to use, but the modifier is run after the dependent\r\n      // one.\r\n\r\n      function runModifierEffects() {\r\n        state.orderedModifiers.forEach(function (_ref) {\r\n          var name = _ref.name,\r\n              _ref$options = _ref.options,\r\n              options = _ref$options === void 0 ? {} : _ref$options,\r\n              effect = _ref.effect;\r\n\r\n          if (typeof effect === 'function') {\r\n            var cleanupFn = effect({\r\n              state: state,\r\n              name: name,\r\n              instance: instance,\r\n              options: options\r\n            });\r\n\r\n            var noopFn = function noopFn() {};\r\n\r\n            effectCleanupFns.push(cleanupFn || noopFn);\r\n          }\r\n        });\r\n      }\r\n\r\n      function cleanupModifierEffects() {\r\n        effectCleanupFns.forEach(function (fn) {\r\n          return fn();\r\n        });\r\n        effectCleanupFns = [];\r\n      }\r\n\r\n      return instance;\r\n    };\r\n  }\r\n  var createPopper$2 = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules\r\n\r\n  var defaultModifiers$1 = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1];\r\n  var createPopper$1 = /*#__PURE__*/popperGenerator({\r\n    defaultModifiers: defaultModifiers$1\r\n  }); // eslint-disable-next-line import/no-unused-modules\r\n\r\n  var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];\r\n  var createPopper = /*#__PURE__*/popperGenerator({\r\n    defaultModifiers: defaultModifiers\r\n  }); // eslint-disable-next-line import/no-unused-modules\r\n\r\n  const Popper = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({\r\n    __proto__: null,\r\n    afterMain,\r\n    afterRead,\r\n    afterWrite,\r\n    applyStyles: applyStyles$1,\r\n    arrow: arrow$1,\r\n    auto,\r\n    basePlacements,\r\n    beforeMain,\r\n    beforeRead,\r\n    beforeWrite,\r\n    bottom,\r\n    clippingParents,\r\n    computeStyles: computeStyles$1,\r\n    createPopper,\r\n    createPopperBase: createPopper$2,\r\n    createPopperLite: createPopper$1,\r\n    detectOverflow,\r\n    end,\r\n    eventListeners,\r\n    flip: flip$1,\r\n    hide: hide$1,\r\n    left,\r\n    main,\r\n    modifierPhases,\r\n    offset: offset$1,\r\n    placements,\r\n    popper,\r\n    popperGenerator,\r\n    popperOffsets: popperOffsets$1,\r\n    preventOverflow: preventOverflow$1,\r\n    read,\r\n    reference,\r\n    right,\r\n    start,\r\n    top,\r\n    variationPlacements,\r\n    viewport,\r\n    write\r\n  }, Symbol.toStringTag, { value: 'Module' }));\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap dropdown.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const NAME$a = 'dropdown';\r\n  const DATA_KEY$6 = 'bs.dropdown';\r\n  const EVENT_KEY$6 = `.${DATA_KEY$6}`;\r\n  const DATA_API_KEY$3 = '.data-api';\r\n  const ESCAPE_KEY$2 = 'Escape';\r\n  const TAB_KEY$1 = 'Tab';\r\n  const ARROW_UP_KEY$1 = 'ArrowUp';\r\n  const ARROW_DOWN_KEY$1 = 'ArrowDown';\r\n  const RIGHT_MOUSE_BUTTON = 2; // MouseEvent.button value for the secondary button, usually the right button\r\n\r\n  const EVENT_HIDE$5 = `hide${EVENT_KEY$6}`;\r\n  const EVENT_HIDDEN$5 = `hidden${EVENT_KEY$6}`;\r\n  const EVENT_SHOW$5 = `show${EVENT_KEY$6}`;\r\n  const EVENT_SHOWN$5 = `shown${EVENT_KEY$6}`;\r\n  const EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;\r\n  const EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$6}${DATA_API_KEY$3}`;\r\n  const EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$6}${DATA_API_KEY$3}`;\r\n  const CLASS_NAME_SHOW$6 = 'show';\r\n  const CLASS_NAME_DROPUP = 'dropup';\r\n  const CLASS_NAME_DROPEND = 'dropend';\r\n  const CLASS_NAME_DROPSTART = 'dropstart';\r\n  const CLASS_NAME_DROPUP_CENTER = 'dropup-center';\r\n  const CLASS_NAME_DROPDOWN_CENTER = 'dropdown-center';\r\n  const SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle=\"dropdown\"]:not(.disabled):not(:disabled)';\r\n  const SELECTOR_DATA_TOGGLE_SHOWN = `${SELECTOR_DATA_TOGGLE$3}.${CLASS_NAME_SHOW$6}`;\r\n  const SELECTOR_MENU = '.dropdown-menu';\r\n  const SELECTOR_NAVBAR = '.navbar';\r\n  const SELECTOR_NAVBAR_NAV = '.navbar-nav';\r\n  const SELECTOR_VISIBLE_ITEMS = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)';\r\n  const PLACEMENT_TOP = isRTL() ? 'top-end' : 'top-start';\r\n  const PLACEMENT_TOPEND = isRTL() ? 'top-start' : 'top-end';\r\n  const PLACEMENT_BOTTOM = isRTL() ? 'bottom-end' : 'bottom-start';\r\n  const PLACEMENT_BOTTOMEND = isRTL() ? 'bottom-start' : 'bottom-end';\r\n  const PLACEMENT_RIGHT = isRTL() ? 'left-start' : 'right-start';\r\n  const PLACEMENT_LEFT = isRTL() ? 'right-start' : 'left-start';\r\n  const PLACEMENT_TOPCENTER = 'top';\r\n  const PLACEMENT_BOTTOMCENTER = 'bottom';\r\n  const Default$9 = {\r\n    autoClose: true,\r\n    boundary: 'clippingParents',\r\n    display: 'dynamic',\r\n    offset: [0, 2],\r\n    popperConfig: null,\r\n    reference: 'toggle'\r\n  };\r\n  const DefaultType$9 = {\r\n    autoClose: '(boolean|string)',\r\n    boundary: '(string|element)',\r\n    display: 'string',\r\n    offset: '(array|string|function)',\r\n    popperConfig: '(null|object|function)',\r\n    reference: '(string|element|object)'\r\n  };\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class Dropdown extends BaseComponent {\r\n    constructor(element, config) {\r\n      super(element, config);\r\n      this._popper = null;\r\n      this._parent = this._element.parentNode; // dropdown wrapper\r\n      // TODO: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.3/forms/input-group/\r\n      this._menu = SelectorEngine.next(this._element, SELECTOR_MENU)[0] || SelectorEngine.prev(this._element, SELECTOR_MENU)[0] || SelectorEngine.findOne(SELECTOR_MENU, this._parent);\r\n      this._inNavbar = this._detectNavbar();\r\n    }\r\n\r\n    // Getters\r\n    static get Default() {\r\n      return Default$9;\r\n    }\r\n    static get DefaultType() {\r\n      return DefaultType$9;\r\n    }\r\n    static get NAME() {\r\n      return NAME$a;\r\n    }\r\n\r\n    // Public\r\n    toggle() {\r\n      return this._isShown() ? this.hide() : this.show();\r\n    }\r\n    show() {\r\n      if (isDisabled(this._element) || this._isShown()) {\r\n        return;\r\n      }\r\n      const relatedTarget = {\r\n        relatedTarget: this._element\r\n      };\r\n      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$5, relatedTarget);\r\n      if (showEvent.defaultPrevented) {\r\n        return;\r\n      }\r\n      this._createPopper();\r\n\r\n      // If this is a touch-enabled device we add extra\r\n      // empty mouseover listeners to the body's immediate children;\r\n      // only needed because of broken event delegation on iOS\r\n      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\r\n      if ('ontouchstart' in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)) {\r\n        for (const element of [].concat(...document.body.children)) {\r\n          EventHandler.on(element, 'mouseover', noop);\r\n        }\r\n      }\r\n      this._element.focus();\r\n      this._element.setAttribute('aria-expanded', true);\r\n      this._menu.classList.add(CLASS_NAME_SHOW$6);\r\n      this._element.classList.add(CLASS_NAME_SHOW$6);\r\n      EventHandler.trigger(this._element, EVENT_SHOWN$5, relatedTarget);\r\n    }\r\n    hide() {\r\n      if (isDisabled(this._element) || !this._isShown()) {\r\n        return;\r\n      }\r\n      const relatedTarget = {\r\n        relatedTarget: this._element\r\n      };\r\n      this._completeHide(relatedTarget);\r\n    }\r\n    dispose() {\r\n      if (this._popper) {\r\n        this._popper.destroy();\r\n      }\r\n      super.dispose();\r\n    }\r\n    update() {\r\n      this._inNavbar = this._detectNavbar();\r\n      if (this._popper) {\r\n        this._popper.update();\r\n      }\r\n    }\r\n\r\n    // Private\r\n    _completeHide(relatedTarget) {\r\n      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$5, relatedTarget);\r\n      if (hideEvent.defaultPrevented) {\r\n        return;\r\n      }\r\n\r\n      // If this is a touch-enabled device we remove the extra\r\n      // empty mouseover listeners we added for iOS support\r\n      if ('ontouchstart' in document.documentElement) {\r\n        for (const element of [].concat(...document.body.children)) {\r\n          EventHandler.off(element, 'mouseover', noop);\r\n        }\r\n      }\r\n      if (this._popper) {\r\n        this._popper.destroy();\r\n      }\r\n      this._menu.classList.remove(CLASS_NAME_SHOW$6);\r\n      this._element.classList.remove(CLASS_NAME_SHOW$6);\r\n      this._element.setAttribute('aria-expanded', 'false');\r\n      Manipulator.removeDataAttribute(this._menu, 'popper');\r\n      EventHandler.trigger(this._element, EVENT_HIDDEN$5, relatedTarget);\r\n    }\r\n    _getConfig(config) {\r\n      config = super._getConfig(config);\r\n      if (typeof config.reference === 'object' && !isElement$1(config.reference) && typeof config.reference.getBoundingClientRect !== 'function') {\r\n        // Popper virtual elements require a getBoundingClientRect method\r\n        throw new TypeError(`${NAME$a.toUpperCase()}: Option \"reference\" provided type \"object\" without a required \"getBoundingClientRect\" method.`);\r\n      }\r\n      return config;\r\n    }\r\n    _createPopper() {\r\n      if (typeof Popper === 'undefined') {\r\n        throw new TypeError('Bootstrap\\'s dropdowns require Popper (https://popper.js.org)');\r\n      }\r\n      let referenceElement = this._element;\r\n      if (this._config.reference === 'parent') {\r\n        referenceElement = this._parent;\r\n      } else if (isElement$1(this._config.reference)) {\r\n        referenceElement = getElement(this._config.reference);\r\n      } else if (typeof this._config.reference === 'object') {\r\n        referenceElement = this._config.reference;\r\n      }\r\n      const popperConfig = this._getPopperConfig();\r\n      this._popper = createPopper(referenceElement, this._menu, popperConfig);\r\n    }\r\n    _isShown() {\r\n      return this._menu.classList.contains(CLASS_NAME_SHOW$6);\r\n    }\r\n    _getPlacement() {\r\n      const parentDropdown = this._parent;\r\n      if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {\r\n        return PLACEMENT_RIGHT;\r\n      }\r\n      if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {\r\n        return PLACEMENT_LEFT;\r\n      }\r\n      if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) {\r\n        return PLACEMENT_TOPCENTER;\r\n      }\r\n      if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) {\r\n        return PLACEMENT_BOTTOMCENTER;\r\n      }\r\n\r\n      // We need to trim the value because custom properties can also include spaces\r\n      const isEnd = getComputedStyle(this._menu).getPropertyValue('--bs-position').trim() === 'end';\r\n      if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {\r\n        return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;\r\n      }\r\n      return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;\r\n    }\r\n    _detectNavbar() {\r\n      return this._element.closest(SELECTOR_NAVBAR) !== null;\r\n    }\r\n    _getOffset() {\r\n      const {\r\n        offset\r\n      } = this._config;\r\n      if (typeof offset === 'string') {\r\n        return offset.split(',').map(value => Number.parseInt(value, 10));\r\n      }\r\n      if (typeof offset === 'function') {\r\n        return popperData => offset(popperData, this._element);\r\n      }\r\n      return offset;\r\n    }\r\n    _getPopperConfig() {\r\n      const defaultBsPopperConfig = {\r\n        placement: this._getPlacement(),\r\n        modifiers: [{\r\n          name: 'preventOverflow',\r\n          options: {\r\n            boundary: this._config.boundary\r\n          }\r\n        }, {\r\n          name: 'offset',\r\n          options: {\r\n            offset: this._getOffset()\r\n          }\r\n        }]\r\n      };\r\n\r\n      // Disable Popper if we have a static display or Dropdown is in Navbar\r\n      if (this._inNavbar || this._config.display === 'static') {\r\n        Manipulator.setDataAttribute(this._menu, 'popper', 'static'); // TODO: v6 remove\r\n        defaultBsPopperConfig.modifiers = [{\r\n          name: 'applyStyles',\r\n          enabled: false\r\n        }];\r\n      }\r\n      return {\r\n        ...defaultBsPopperConfig,\r\n        ...execute(this._config.popperConfig, [defaultBsPopperConfig])\r\n      };\r\n    }\r\n    _selectMenuItem({\r\n      key,\r\n      target\r\n    }) {\r\n      const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter(element => isVisible(element));\r\n      if (!items.length) {\r\n        return;\r\n      }\r\n\r\n      // if target isn't included in items (e.g. when expanding the dropdown)\r\n      // allow cycling to get the last item in case key equals ARROW_UP_KEY\r\n      getNextActiveElement(items, target, key === ARROW_DOWN_KEY$1, !items.includes(target)).focus();\r\n    }\r\n\r\n    // Static\r\n    static jQueryInterface(config) {\r\n      return this.each(function () {\r\n        const data = Dropdown.getOrCreateInstance(this, config);\r\n        if (typeof config !== 'string') {\r\n          return;\r\n        }\r\n        if (typeof data[config] === 'undefined') {\r\n          throw new TypeError(`No method named \"${config}\"`);\r\n        }\r\n        data[config]();\r\n      });\r\n    }\r\n    static clearMenus(event) {\r\n      if (event.button === RIGHT_MOUSE_BUTTON || event.type === 'keyup' && event.key !== TAB_KEY$1) {\r\n        return;\r\n      }\r\n      const openToggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN);\r\n      for (const toggle of openToggles) {\r\n        const context = Dropdown.getInstance(toggle);\r\n        if (!context || context._config.autoClose === false) {\r\n          continue;\r\n        }\r\n        const composedPath = event.composedPath();\r\n        const isMenuTarget = composedPath.includes(context._menu);\r\n        if (composedPath.includes(context._element) || context._config.autoClose === 'inside' && !isMenuTarget || context._config.autoClose === 'outside' && isMenuTarget) {\r\n          continue;\r\n        }\r\n\r\n        // Tab navigation through the dropdown menu or events from contained inputs shouldn't close the menu\r\n        if (context._menu.contains(event.target) && (event.type === 'keyup' && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) {\r\n          continue;\r\n        }\r\n        const relatedTarget = {\r\n          relatedTarget: context._element\r\n        };\r\n        if (event.type === 'click') {\r\n          relatedTarget.clickEvent = event;\r\n        }\r\n        context._completeHide(relatedTarget);\r\n      }\r\n    }\r\n    static dataApiKeydownHandler(event) {\r\n      // If not an UP | DOWN | ESCAPE key => not a dropdown command\r\n      // If input/textarea && if key is other than ESCAPE => not a dropdown command\r\n\r\n      const isInput = /input|textarea/i.test(event.target.tagName);\r\n      const isEscapeEvent = event.key === ESCAPE_KEY$2;\r\n      const isUpOrDownEvent = [ARROW_UP_KEY$1, ARROW_DOWN_KEY$1].includes(event.key);\r\n      if (!isUpOrDownEvent && !isEscapeEvent) {\r\n        return;\r\n      }\r\n      if (isInput && !isEscapeEvent) {\r\n        return;\r\n      }\r\n      event.preventDefault();\r\n\r\n      // TODO: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.3/forms/input-group/\r\n      const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.next(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.findOne(SELECTOR_DATA_TOGGLE$3, event.delegateTarget.parentNode);\r\n      const instance = Dropdown.getOrCreateInstance(getToggleButton);\r\n      if (isUpOrDownEvent) {\r\n        event.stopPropagation();\r\n        instance.show();\r\n        instance._selectMenuItem(event);\r\n        return;\r\n      }\r\n      if (instance._isShown()) {\r\n        // else is escape and we check if it is shown\r\n        event.stopPropagation();\r\n        instance.hide();\r\n        getToggleButton.focus();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Data API implementation\r\n   */\r\n\r\n  EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);\r\n  EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);\r\n  EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);\r\n  EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);\r\n  EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function (event) {\r\n    event.preventDefault();\r\n    Dropdown.getOrCreateInstance(this).toggle();\r\n  });\r\n\r\n  /**\r\n   * jQuery\r\n   */\r\n\r\n  defineJQueryPlugin(Dropdown);\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap util/backdrop.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const NAME$9 = 'backdrop';\r\n  const CLASS_NAME_FADE$4 = 'fade';\r\n  const CLASS_NAME_SHOW$5 = 'show';\r\n  const EVENT_MOUSEDOWN = `mousedown.bs.${NAME$9}`;\r\n  const Default$8 = {\r\n    className: 'modal-backdrop',\r\n    clickCallback: null,\r\n    isAnimated: false,\r\n    isVisible: true,\r\n    // if false, we use the backdrop helper without adding any element to the dom\r\n    rootElement: 'body' // give the choice to place backdrop under different elements\r\n  };\r\n  const DefaultType$8 = {\r\n    className: 'string',\r\n    clickCallback: '(function|null)',\r\n    isAnimated: 'boolean',\r\n    isVisible: 'boolean',\r\n    rootElement: '(element|string)'\r\n  };\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class Backdrop extends Config {\r\n    constructor(config) {\r\n      super();\r\n      this._config = this._getConfig(config);\r\n      this._isAppended = false;\r\n      this._element = null;\r\n    }\r\n\r\n    // Getters\r\n    static get Default() {\r\n      return Default$8;\r\n    }\r\n    static get DefaultType() {\r\n      return DefaultType$8;\r\n    }\r\n    static get NAME() {\r\n      return NAME$9;\r\n    }\r\n\r\n    // Public\r\n    show(callback) {\r\n      if (!this._config.isVisible) {\r\n        execute(callback);\r\n        return;\r\n      }\r\n      this._append();\r\n      const element = this._getElement();\r\n      if (this._config.isAnimated) {\r\n        reflow(element);\r\n      }\r\n      element.classList.add(CLASS_NAME_SHOW$5);\r\n      this._emulateAnimation(() => {\r\n        execute(callback);\r\n      });\r\n    }\r\n    hide(callback) {\r\n      if (!this._config.isVisible) {\r\n        execute(callback);\r\n        return;\r\n      }\r\n      this._getElement().classList.remove(CLASS_NAME_SHOW$5);\r\n      this._emulateAnimation(() => {\r\n        this.dispose();\r\n        execute(callback);\r\n      });\r\n    }\r\n    dispose() {\r\n      if (!this._isAppended) {\r\n        return;\r\n      }\r\n      EventHandler.off(this._element, EVENT_MOUSEDOWN);\r\n      this._element.remove();\r\n      this._isAppended = false;\r\n    }\r\n\r\n    // Private\r\n    _getElement() {\r\n      if (!this._element) {\r\n        const backdrop = document.createElement('div');\r\n        backdrop.className = this._config.className;\r\n        if (this._config.isAnimated) {\r\n          backdrop.classList.add(CLASS_NAME_FADE$4);\r\n        }\r\n        this._element = backdrop;\r\n      }\r\n      return this._element;\r\n    }\r\n    _configAfterMerge(config) {\r\n      // use getElement() with the default \"body\" to get a fresh Element on each instantiation\r\n      config.rootElement = getElement(config.rootElement);\r\n      return config;\r\n    }\r\n    _append() {\r\n      if (this._isAppended) {\r\n        return;\r\n      }\r\n      const element = this._getElement();\r\n      this._config.rootElement.append(element);\r\n      EventHandler.on(element, EVENT_MOUSEDOWN, () => {\r\n        execute(this._config.clickCallback);\r\n      });\r\n      this._isAppended = true;\r\n    }\r\n    _emulateAnimation(callback) {\r\n      executeAfterTransition(callback, this._getElement(), this._config.isAnimated);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap util/focustrap.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const NAME$8 = 'focustrap';\r\n  const DATA_KEY$5 = 'bs.focustrap';\r\n  const EVENT_KEY$5 = `.${DATA_KEY$5}`;\r\n  const EVENT_FOCUSIN$2 = `focusin${EVENT_KEY$5}`;\r\n  const EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$5}`;\r\n  const TAB_KEY = 'Tab';\r\n  const TAB_NAV_FORWARD = 'forward';\r\n  const TAB_NAV_BACKWARD = 'backward';\r\n  const Default$7 = {\r\n    autofocus: true,\r\n    trapElement: null // The element to trap focus inside of\r\n  };\r\n  const DefaultType$7 = {\r\n    autofocus: 'boolean',\r\n    trapElement: 'element'\r\n  };\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class FocusTrap extends Config {\r\n    constructor(config) {\r\n      super();\r\n      this._config = this._getConfig(config);\r\n      this._isActive = false;\r\n      this._lastTabNavDirection = null;\r\n    }\r\n\r\n    // Getters\r\n    static get Default() {\r\n      return Default$7;\r\n    }\r\n    static get DefaultType() {\r\n      return DefaultType$7;\r\n    }\r\n    static get NAME() {\r\n      return NAME$8;\r\n    }\r\n\r\n    // Public\r\n    activate() {\r\n      if (this._isActive) {\r\n        return;\r\n      }\r\n      if (this._config.autofocus) {\r\n        this._config.trapElement.focus();\r\n      }\r\n      EventHandler.off(document, EVENT_KEY$5); // guard against infinite focus loop\r\n      EventHandler.on(document, EVENT_FOCUSIN$2, event => this._handleFocusin(event));\r\n      EventHandler.on(document, EVENT_KEYDOWN_TAB, event => this._handleKeydown(event));\r\n      this._isActive = true;\r\n    }\r\n    deactivate() {\r\n      if (!this._isActive) {\r\n        return;\r\n      }\r\n      this._isActive = false;\r\n      EventHandler.off(document, EVENT_KEY$5);\r\n    }\r\n\r\n    // Private\r\n    _handleFocusin(event) {\r\n      const {\r\n        trapElement\r\n      } = this._config;\r\n      if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) {\r\n        return;\r\n      }\r\n      const elements = SelectorEngine.focusableChildren(trapElement);\r\n      if (elements.length === 0) {\r\n        trapElement.focus();\r\n      } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {\r\n        elements[elements.length - 1].focus();\r\n      } else {\r\n        elements[0].focus();\r\n      }\r\n    }\r\n    _handleKeydown(event) {\r\n      if (event.key !== TAB_KEY) {\r\n        return;\r\n      }\r\n      this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap util/scrollBar.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';\r\n  const SELECTOR_STICKY_CONTENT = '.sticky-top';\r\n  const PROPERTY_PADDING = 'padding-right';\r\n  const PROPERTY_MARGIN = 'margin-right';\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class ScrollBarHelper {\r\n    constructor() {\r\n      this._element = document.body;\r\n    }\r\n\r\n    // Public\r\n    getWidth() {\r\n      // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes\r\n      const documentWidth = document.documentElement.clientWidth;\r\n      return Math.abs(window.innerWidth - documentWidth);\r\n    }\r\n    hide() {\r\n      const width = this.getWidth();\r\n      this._disableOverFlow();\r\n      // give padding to element to balance the hidden scrollbar width\r\n      this._setElementAttributes(this._element, PROPERTY_PADDING, calculatedValue => calculatedValue + width);\r\n      // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth\r\n      this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, calculatedValue => calculatedValue + width);\r\n      this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, calculatedValue => calculatedValue - width);\r\n    }\r\n    reset() {\r\n      this._resetElementAttributes(this._element, 'overflow');\r\n      this._resetElementAttributes(this._element, PROPERTY_PADDING);\r\n      this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);\r\n      this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);\r\n    }\r\n    isOverflowing() {\r\n      return this.getWidth() > 0;\r\n    }\r\n\r\n    // Private\r\n    _disableOverFlow() {\r\n      this._saveInitialAttribute(this._element, 'overflow');\r\n      this._element.style.overflow = 'hidden';\r\n    }\r\n    _setElementAttributes(selector, styleProperty, callback) {\r\n      const scrollbarWidth = this.getWidth();\r\n      const manipulationCallBack = element => {\r\n        if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {\r\n          return;\r\n        }\r\n        this._saveInitialAttribute(element, styleProperty);\r\n        const calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);\r\n        element.style.setProperty(styleProperty, `${callback(Number.parseFloat(calculatedValue))}px`);\r\n      };\r\n      this._applyManipulationCallback(selector, manipulationCallBack);\r\n    }\r\n    _saveInitialAttribute(element, styleProperty) {\r\n      const actualValue = element.style.getPropertyValue(styleProperty);\r\n      if (actualValue) {\r\n        Manipulator.setDataAttribute(element, styleProperty, actualValue);\r\n      }\r\n    }\r\n    _resetElementAttributes(selector, styleProperty) {\r\n      const manipulationCallBack = element => {\r\n        const value = Manipulator.getDataAttribute(element, styleProperty);\r\n        // We only want to remove the property if the value is `null`; the value can also be zero\r\n        if (value === null) {\r\n          element.style.removeProperty(styleProperty);\r\n          return;\r\n        }\r\n        Manipulator.removeDataAttribute(element, styleProperty);\r\n        element.style.setProperty(styleProperty, value);\r\n      };\r\n      this._applyManipulationCallback(selector, manipulationCallBack);\r\n    }\r\n    _applyManipulationCallback(selector, callBack) {\r\n      if (isElement$1(selector)) {\r\n        callBack(selector);\r\n        return;\r\n      }\r\n      for (const sel of SelectorEngine.find(selector, this._element)) {\r\n        callBack(sel);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap modal.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const NAME$7 = 'modal';\r\n  const DATA_KEY$4 = 'bs.modal';\r\n  const EVENT_KEY$4 = `.${DATA_KEY$4}`;\r\n  const DATA_API_KEY$2 = '.data-api';\r\n  const ESCAPE_KEY$1 = 'Escape';\r\n  const EVENT_HIDE$4 = `hide${EVENT_KEY$4}`;\r\n  const EVENT_HIDE_PREVENTED$1 = `hidePrevented${EVENT_KEY$4}`;\r\n  const EVENT_HIDDEN$4 = `hidden${EVENT_KEY$4}`;\r\n  const EVENT_SHOW$4 = `show${EVENT_KEY$4}`;\r\n  const EVENT_SHOWN$4 = `shown${EVENT_KEY$4}`;\r\n  const EVENT_RESIZE$1 = `resize${EVENT_KEY$4}`;\r\n  const EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY$4}`;\r\n  const EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$4}`;\r\n  const EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$4}`;\r\n  const EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$4}${DATA_API_KEY$2}`;\r\n  const CLASS_NAME_OPEN = 'modal-open';\r\n  const CLASS_NAME_FADE$3 = 'fade';\r\n  const CLASS_NAME_SHOW$4 = 'show';\r\n  const CLASS_NAME_STATIC = 'modal-static';\r\n  const OPEN_SELECTOR$1 = '.modal.show';\r\n  const SELECTOR_DIALOG = '.modal-dialog';\r\n  const SELECTOR_MODAL_BODY = '.modal-body';\r\n  const SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle=\"modal\"]';\r\n  const Default$6 = {\r\n    backdrop: true,\r\n    focus: true,\r\n    keyboard: true\r\n  };\r\n  const DefaultType$6 = {\r\n    backdrop: '(boolean|string)',\r\n    focus: 'boolean',\r\n    keyboard: 'boolean'\r\n  };\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class Modal extends BaseComponent {\r\n    constructor(element, config) {\r\n      super(element, config);\r\n      this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);\r\n      this._backdrop = this._initializeBackDrop();\r\n      this._focustrap = this._initializeFocusTrap();\r\n      this._isShown = false;\r\n      this._isTransitioning = false;\r\n      this._scrollBar = new ScrollBarHelper();\r\n      this._addEventListeners();\r\n    }\r\n\r\n    // Getters\r\n    static get Default() {\r\n      return Default$6;\r\n    }\r\n    static get DefaultType() {\r\n      return DefaultType$6;\r\n    }\r\n    static get NAME() {\r\n      return NAME$7;\r\n    }\r\n\r\n    // Public\r\n    toggle(relatedTarget) {\r\n      return this._isShown ? this.hide() : this.show(relatedTarget);\r\n    }\r\n    show(relatedTarget) {\r\n      if (this._isShown || this._isTransitioning) {\r\n        return;\r\n      }\r\n      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, {\r\n        relatedTarget\r\n      });\r\n      if (showEvent.defaultPrevented) {\r\n        return;\r\n      }\r\n      this._isShown = true;\r\n      this._isTransitioning = true;\r\n      this._scrollBar.hide();\r\n      document.body.classList.add(CLASS_NAME_OPEN);\r\n      this._adjustDialog();\r\n      this._backdrop.show(() => this._showElement(relatedTarget));\r\n    }\r\n    hide() {\r\n      if (!this._isShown || this._isTransitioning) {\r\n        return;\r\n      }\r\n      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4);\r\n      if (hideEvent.defaultPrevented) {\r\n        return;\r\n      }\r\n      this._isShown = false;\r\n      this._isTransitioning = true;\r\n      this._focustrap.deactivate();\r\n      this._element.classList.remove(CLASS_NAME_SHOW$4);\r\n      this._queueCallback(() => this._hideModal(), this._element, this._isAnimated());\r\n    }\r\n    dispose() {\r\n      EventHandler.off(window, EVENT_KEY$4);\r\n      EventHandler.off(this._dialog, EVENT_KEY$4);\r\n      this._backdrop.dispose();\r\n      this._focustrap.deactivate();\r\n      super.dispose();\r\n    }\r\n    handleUpdate() {\r\n      this._adjustDialog();\r\n    }\r\n\r\n    // Private\r\n    _initializeBackDrop() {\r\n      return new Backdrop({\r\n        isVisible: Boolean(this._config.backdrop),\r\n        // 'static' option will be translated to true, and booleans will keep their value,\r\n        isAnimated: this._isAnimated()\r\n      });\r\n    }\r\n    _initializeFocusTrap() {\r\n      return new FocusTrap({\r\n        trapElement: this._element\r\n      });\r\n    }\r\n    _showElement(relatedTarget) {\r\n      // try to append dynamic modal\r\n      if (!document.body.contains(this._element)) {\r\n        document.body.append(this._element);\r\n      }\r\n      this._element.style.display = 'block';\r\n      this._element.removeAttribute('aria-hidden');\r\n      this._element.setAttribute('aria-modal', true);\r\n      this._element.setAttribute('role', 'dialog');\r\n      this._element.scrollTop = 0;\r\n      const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);\r\n      if (modalBody) {\r\n        modalBody.scrollTop = 0;\r\n      }\r\n      reflow(this._element);\r\n      this._element.classList.add(CLASS_NAME_SHOW$4);\r\n      const transitionComplete = () => {\r\n        if (this._config.focus) {\r\n          this._focustrap.activate();\r\n        }\r\n        this._isTransitioning = false;\r\n        EventHandler.trigger(this._element, EVENT_SHOWN$4, {\r\n          relatedTarget\r\n        });\r\n      };\r\n      this._queueCallback(transitionComplete, this._dialog, this._isAnimated());\r\n    }\r\n    _addEventListeners() {\r\n      EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, event => {\r\n        if (event.key !== ESCAPE_KEY$1) {\r\n          return;\r\n        }\r\n        if (this._config.keyboard) {\r\n          this.hide();\r\n          return;\r\n        }\r\n        this._triggerBackdropTransition();\r\n      });\r\n      EventHandler.on(window, EVENT_RESIZE$1, () => {\r\n        if (this._isShown && !this._isTransitioning) {\r\n          this._adjustDialog();\r\n        }\r\n      });\r\n      EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, event => {\r\n        // a bad trick to segregate clicks that may start inside dialog but end outside, and avoid listen to scrollbar clicks\r\n        EventHandler.one(this._element, EVENT_CLICK_DISMISS, event2 => {\r\n          if (this._element !== event.target || this._element !== event2.target) {\r\n            return;\r\n          }\r\n          if (this._config.backdrop === 'static') {\r\n            this._triggerBackdropTransition();\r\n            return;\r\n          }\r\n          if (this._config.backdrop) {\r\n            this.hide();\r\n          }\r\n        });\r\n      });\r\n    }\r\n    _hideModal() {\r\n      this._element.style.display = 'none';\r\n      this._element.setAttribute('aria-hidden', true);\r\n      this._element.removeAttribute('aria-modal');\r\n      this._element.removeAttribute('role');\r\n      this._isTransitioning = false;\r\n      this._backdrop.hide(() => {\r\n        document.body.classList.remove(CLASS_NAME_OPEN);\r\n        this._resetAdjustments();\r\n        this._scrollBar.reset();\r\n        EventHandler.trigger(this._element, EVENT_HIDDEN$4);\r\n      });\r\n    }\r\n    _isAnimated() {\r\n      return this._element.classList.contains(CLASS_NAME_FADE$3);\r\n    }\r\n    _triggerBackdropTransition() {\r\n      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1);\r\n      if (hideEvent.defaultPrevented) {\r\n        return;\r\n      }\r\n      const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\r\n      const initialOverflowY = this._element.style.overflowY;\r\n      // return if the following background transition hasn't yet completed\r\n      if (initialOverflowY === 'hidden' || this._element.classList.contains(CLASS_NAME_STATIC)) {\r\n        return;\r\n      }\r\n      if (!isModalOverflowing) {\r\n        this._element.style.overflowY = 'hidden';\r\n      }\r\n      this._element.classList.add(CLASS_NAME_STATIC);\r\n      this._queueCallback(() => {\r\n        this._element.classList.remove(CLASS_NAME_STATIC);\r\n        this._queueCallback(() => {\r\n          this._element.style.overflowY = initialOverflowY;\r\n        }, this._dialog);\r\n      }, this._dialog);\r\n      this._element.focus();\r\n    }\r\n\r\n    /**\r\n     * The following methods are used to handle overflowing modals\r\n     */\r\n\r\n    _adjustDialog() {\r\n      const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\r\n      const scrollbarWidth = this._scrollBar.getWidth();\r\n      const isBodyOverflowing = scrollbarWidth > 0;\r\n      if (isBodyOverflowing && !isModalOverflowing) {\r\n        const property = isRTL() ? 'paddingLeft' : 'paddingRight';\r\n        this._element.style[property] = `${scrollbarWidth}px`;\r\n      }\r\n      if (!isBodyOverflowing && isModalOverflowing) {\r\n        const property = isRTL() ? 'paddingRight' : 'paddingLeft';\r\n        this._element.style[property] = `${scrollbarWidth}px`;\r\n      }\r\n    }\r\n    _resetAdjustments() {\r\n      this._element.style.paddingLeft = '';\r\n      this._element.style.paddingRight = '';\r\n    }\r\n\r\n    // Static\r\n    static jQueryInterface(config, relatedTarget) {\r\n      return this.each(function () {\r\n        const data = Modal.getOrCreateInstance(this, config);\r\n        if (typeof config !== 'string') {\r\n          return;\r\n        }\r\n        if (typeof data[config] === 'undefined') {\r\n          throw new TypeError(`No method named \"${config}\"`);\r\n        }\r\n        data[config](relatedTarget);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Data API implementation\r\n   */\r\n\r\n  EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function (event) {\r\n    const target = SelectorEngine.getElementFromSelector(this);\r\n    if (['A', 'AREA'].includes(this.tagName)) {\r\n      event.preventDefault();\r\n    }\r\n    EventHandler.one(target, EVENT_SHOW$4, showEvent => {\r\n      if (showEvent.defaultPrevented) {\r\n        // only register focus restorer if modal will actually get shown\r\n        return;\r\n      }\r\n      EventHandler.one(target, EVENT_HIDDEN$4, () => {\r\n        if (isVisible(this)) {\r\n          this.focus();\r\n        }\r\n      });\r\n    });\r\n\r\n    // avoid conflict when clicking modal toggler while another one is open\r\n    const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);\r\n    if (alreadyOpen) {\r\n      Modal.getInstance(alreadyOpen).hide();\r\n    }\r\n    const data = Modal.getOrCreateInstance(target);\r\n    data.toggle(this);\r\n  });\r\n  enableDismissTrigger(Modal);\r\n\r\n  /**\r\n   * jQuery\r\n   */\r\n\r\n  defineJQueryPlugin(Modal);\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap offcanvas.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const NAME$6 = 'offcanvas';\r\n  const DATA_KEY$3 = 'bs.offcanvas';\r\n  const EVENT_KEY$3 = `.${DATA_KEY$3}`;\r\n  const DATA_API_KEY$1 = '.data-api';\r\n  const EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$3}${DATA_API_KEY$1}`;\r\n  const ESCAPE_KEY = 'Escape';\r\n  const CLASS_NAME_SHOW$3 = 'show';\r\n  const CLASS_NAME_SHOWING$1 = 'showing';\r\n  const CLASS_NAME_HIDING = 'hiding';\r\n  const CLASS_NAME_BACKDROP = 'offcanvas-backdrop';\r\n  const OPEN_SELECTOR = '.offcanvas.show';\r\n  const EVENT_SHOW$3 = `show${EVENT_KEY$3}`;\r\n  const EVENT_SHOWN$3 = `shown${EVENT_KEY$3}`;\r\n  const EVENT_HIDE$3 = `hide${EVENT_KEY$3}`;\r\n  const EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$3}`;\r\n  const EVENT_HIDDEN$3 = `hidden${EVENT_KEY$3}`;\r\n  const EVENT_RESIZE = `resize${EVENT_KEY$3}`;\r\n  const EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$3}${DATA_API_KEY$1}`;\r\n  const EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$3}`;\r\n  const SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle=\"offcanvas\"]';\r\n  const Default$5 = {\r\n    backdrop: true,\r\n    keyboard: true,\r\n    scroll: false\r\n  };\r\n  const DefaultType$5 = {\r\n    backdrop: '(boolean|string)',\r\n    keyboard: 'boolean',\r\n    scroll: 'boolean'\r\n  };\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class Offcanvas extends BaseComponent {\r\n    constructor(element, config) {\r\n      super(element, config);\r\n      this._isShown = false;\r\n      this._backdrop = this._initializeBackDrop();\r\n      this._focustrap = this._initializeFocusTrap();\r\n      this._addEventListeners();\r\n    }\r\n\r\n    // Getters\r\n    static get Default() {\r\n      return Default$5;\r\n    }\r\n    static get DefaultType() {\r\n      return DefaultType$5;\r\n    }\r\n    static get NAME() {\r\n      return NAME$6;\r\n    }\r\n\r\n    // Public\r\n    toggle(relatedTarget) {\r\n      return this._isShown ? this.hide() : this.show(relatedTarget);\r\n    }\r\n    show(relatedTarget) {\r\n      if (this._isShown) {\r\n        return;\r\n      }\r\n      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {\r\n        relatedTarget\r\n      });\r\n      if (showEvent.defaultPrevented) {\r\n        return;\r\n      }\r\n      this._isShown = true;\r\n      this._backdrop.show();\r\n      if (!this._config.scroll) {\r\n        new ScrollBarHelper().hide();\r\n      }\r\n      this._element.setAttribute('aria-modal', true);\r\n      this._element.setAttribute('role', 'dialog');\r\n      this._element.classList.add(CLASS_NAME_SHOWING$1);\r\n      const completeCallBack = () => {\r\n        if (!this._config.scroll || this._config.backdrop) {\r\n          this._focustrap.activate();\r\n        }\r\n        this._element.classList.add(CLASS_NAME_SHOW$3);\r\n        this._element.classList.remove(CLASS_NAME_SHOWING$1);\r\n        EventHandler.trigger(this._element, EVENT_SHOWN$3, {\r\n          relatedTarget\r\n        });\r\n      };\r\n      this._queueCallback(completeCallBack, this._element, true);\r\n    }\r\n    hide() {\r\n      if (!this._isShown) {\r\n        return;\r\n      }\r\n      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);\r\n      if (hideEvent.defaultPrevented) {\r\n        return;\r\n      }\r\n      this._focustrap.deactivate();\r\n      this._element.blur();\r\n      this._isShown = false;\r\n      this._element.classList.add(CLASS_NAME_HIDING);\r\n      this._backdrop.hide();\r\n      const completeCallback = () => {\r\n        this._element.classList.remove(CLASS_NAME_SHOW$3, CLASS_NAME_HIDING);\r\n        this._element.removeAttribute('aria-modal');\r\n        this._element.removeAttribute('role');\r\n        if (!this._config.scroll) {\r\n          new ScrollBarHelper().reset();\r\n        }\r\n        EventHandler.trigger(this._element, EVENT_HIDDEN$3);\r\n      };\r\n      this._queueCallback(completeCallback, this._element, true);\r\n    }\r\n    dispose() {\r\n      this._backdrop.dispose();\r\n      this._focustrap.deactivate();\r\n      super.dispose();\r\n    }\r\n\r\n    // Private\r\n    _initializeBackDrop() {\r\n      const clickCallback = () => {\r\n        if (this._config.backdrop === 'static') {\r\n          EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);\r\n          return;\r\n        }\r\n        this.hide();\r\n      };\r\n\r\n      // 'static' option will be translated to true, and booleans will keep their value\r\n      const isVisible = Boolean(this._config.backdrop);\r\n      return new Backdrop({\r\n        className: CLASS_NAME_BACKDROP,\r\n        isVisible,\r\n        isAnimated: true,\r\n        rootElement: this._element.parentNode,\r\n        clickCallback: isVisible ? clickCallback : null\r\n      });\r\n    }\r\n    _initializeFocusTrap() {\r\n      return new FocusTrap({\r\n        trapElement: this._element\r\n      });\r\n    }\r\n    _addEventListeners() {\r\n      EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, event => {\r\n        if (event.key !== ESCAPE_KEY) {\r\n          return;\r\n        }\r\n        if (this._config.keyboard) {\r\n          this.hide();\r\n          return;\r\n        }\r\n        EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);\r\n      });\r\n    }\r\n\r\n    // Static\r\n    static jQueryInterface(config) {\r\n      return this.each(function () {\r\n        const data = Offcanvas.getOrCreateInstance(this, config);\r\n        if (typeof config !== 'string') {\r\n          return;\r\n        }\r\n        if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\r\n          throw new TypeError(`No method named \"${config}\"`);\r\n        }\r\n        data[config](this);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Data API implementation\r\n   */\r\n\r\n  EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function (event) {\r\n    const target = SelectorEngine.getElementFromSelector(this);\r\n    if (['A', 'AREA'].includes(this.tagName)) {\r\n      event.preventDefault();\r\n    }\r\n    if (isDisabled(this)) {\r\n      return;\r\n    }\r\n    EventHandler.one(target, EVENT_HIDDEN$3, () => {\r\n      // focus on trigger when it is closed\r\n      if (isVisible(this)) {\r\n        this.focus();\r\n      }\r\n    });\r\n\r\n    // avoid conflict when clicking a toggler of an offcanvas, while another is open\r\n    const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);\r\n    if (alreadyOpen && alreadyOpen !== target) {\r\n      Offcanvas.getInstance(alreadyOpen).hide();\r\n    }\r\n    const data = Offcanvas.getOrCreateInstance(target);\r\n    data.toggle(this);\r\n  });\r\n  EventHandler.on(window, EVENT_LOAD_DATA_API$2, () => {\r\n    for (const selector of SelectorEngine.find(OPEN_SELECTOR)) {\r\n      Offcanvas.getOrCreateInstance(selector).show();\r\n    }\r\n  });\r\n  EventHandler.on(window, EVENT_RESIZE, () => {\r\n    for (const element of SelectorEngine.find('[aria-modal][class*=show][class*=offcanvas-]')) {\r\n      if (getComputedStyle(element).position !== 'fixed') {\r\n        Offcanvas.getOrCreateInstance(element).hide();\r\n      }\r\n    }\r\n  });\r\n  enableDismissTrigger(Offcanvas);\r\n\r\n  /**\r\n   * jQuery\r\n   */\r\n\r\n  defineJQueryPlugin(Offcanvas);\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap util/sanitizer.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n  // js-docs-start allow-list\r\n  const ARIA_ATTRIBUTE_PATTERN = /^aria-[\\w-]*$/i;\r\n  const DefaultAllowlist = {\r\n    // Global attributes allowed on any supplied element below.\r\n    '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],\r\n    a: ['target', 'href', 'title', 'rel'],\r\n    area: [],\r\n    b: [],\r\n    br: [],\r\n    col: [],\r\n    code: [],\r\n    dd: [],\r\n    div: [],\r\n    dl: [],\r\n    dt: [],\r\n    em: [],\r\n    hr: [],\r\n    h1: [],\r\n    h2: [],\r\n    h3: [],\r\n    h4: [],\r\n    h5: [],\r\n    h6: [],\r\n    i: [],\r\n    img: ['src', 'srcset', 'alt', 'title', 'width', 'height'],\r\n    li: [],\r\n    ol: [],\r\n    p: [],\r\n    pre: [],\r\n    s: [],\r\n    small: [],\r\n    span: [],\r\n    sub: [],\r\n    sup: [],\r\n    strong: [],\r\n    u: [],\r\n    ul: []\r\n  };\r\n  // js-docs-end allow-list\r\n\r\n  const uriAttributes = new Set(['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href']);\r\n\r\n  /**\r\n   * A pattern that recognizes URLs that are safe wrt. XSS in URL navigation\r\n   * contexts.\r\n   *\r\n   * Shout-out to Angular https://github.com/angular/angular/blob/15.2.8/packages/core/src/sanitization/url_sanitizer.ts#L38\r\n   */\r\n  // eslint-disable-next-line unicorn/better-regex\r\n  const SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i;\r\n  const allowedAttribute = (attribute, allowedAttributeList) => {\r\n    const attributeName = attribute.nodeName.toLowerCase();\r\n    if (allowedAttributeList.includes(attributeName)) {\r\n      if (uriAttributes.has(attributeName)) {\r\n        return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue));\r\n      }\r\n      return true;\r\n    }\r\n\r\n    // Check if a regular expression validates the attribute.\r\n    return allowedAttributeList.filter(attributeRegex => attributeRegex instanceof RegExp).some(regex => regex.test(attributeName));\r\n  };\r\n  function sanitizeHtml(unsafeHtml, allowList, sanitizeFunction) {\r\n    if (!unsafeHtml.length) {\r\n      return unsafeHtml;\r\n    }\r\n    if (sanitizeFunction && typeof sanitizeFunction === 'function') {\r\n      return sanitizeFunction(unsafeHtml);\r\n    }\r\n    const domParser = new window.DOMParser();\r\n    const createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');\r\n    const elements = [].concat(...createdDocument.body.querySelectorAll('*'));\r\n    for (const element of elements) {\r\n      const elementName = element.nodeName.toLowerCase();\r\n      if (!Object.keys(allowList).includes(elementName)) {\r\n        element.remove();\r\n        continue;\r\n      }\r\n      const attributeList = [].concat(...element.attributes);\r\n      const allowedAttributes = [].concat(allowList['*'] || [], allowList[elementName] || []);\r\n      for (const attribute of attributeList) {\r\n        if (!allowedAttribute(attribute, allowedAttributes)) {\r\n          element.removeAttribute(attribute.nodeName);\r\n        }\r\n      }\r\n    }\r\n    return createdDocument.body.innerHTML;\r\n  }\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap util/template-factory.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const NAME$5 = 'TemplateFactory';\r\n  const Default$4 = {\r\n    allowList: DefaultAllowlist,\r\n    content: {},\r\n    // { selector : text ,  selector2 : text2 , }\r\n    extraClass: '',\r\n    html: false,\r\n    sanitize: true,\r\n    sanitizeFn: null,\r\n    template: '<div></div>'\r\n  };\r\n  const DefaultType$4 = {\r\n    allowList: 'object',\r\n    content: 'object',\r\n    extraClass: '(string|function)',\r\n    html: 'boolean',\r\n    sanitize: 'boolean',\r\n    sanitizeFn: '(null|function)',\r\n    template: 'string'\r\n  };\r\n  const DefaultContentType = {\r\n    entry: '(string|element|function|null)',\r\n    selector: '(string|element)'\r\n  };\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class TemplateFactory extends Config {\r\n    constructor(config) {\r\n      super();\r\n      this._config = this._getConfig(config);\r\n    }\r\n\r\n    // Getters\r\n    static get Default() {\r\n      return Default$4;\r\n    }\r\n    static get DefaultType() {\r\n      return DefaultType$4;\r\n    }\r\n    static get NAME() {\r\n      return NAME$5;\r\n    }\r\n\r\n    // Public\r\n    getContent() {\r\n      return Object.values(this._config.content).map(config => this._resolvePossibleFunction(config)).filter(Boolean);\r\n    }\r\n    hasContent() {\r\n      return this.getContent().length > 0;\r\n    }\r\n    changeContent(content) {\r\n      this._checkContent(content);\r\n      this._config.content = {\r\n        ...this._config.content,\r\n        ...content\r\n      };\r\n      return this;\r\n    }\r\n    toHtml() {\r\n      const templateWrapper = document.createElement('div');\r\n      templateWrapper.innerHTML = this._maybeSanitize(this._config.template);\r\n      for (const [selector, text] of Object.entries(this._config.content)) {\r\n        this._setContent(templateWrapper, text, selector);\r\n      }\r\n      const template = templateWrapper.children[0];\r\n      const extraClass = this._resolvePossibleFunction(this._config.extraClass);\r\n      if (extraClass) {\r\n        template.classList.add(...extraClass.split(' '));\r\n      }\r\n      return template;\r\n    }\r\n\r\n    // Private\r\n    _typeCheckConfig(config) {\r\n      super._typeCheckConfig(config);\r\n      this._checkContent(config.content);\r\n    }\r\n    _checkContent(arg) {\r\n      for (const [selector, content] of Object.entries(arg)) {\r\n        super._typeCheckConfig({\r\n          selector,\r\n          entry: content\r\n        }, DefaultContentType);\r\n      }\r\n    }\r\n    _setContent(template, content, selector) {\r\n      const templateElement = SelectorEngine.findOne(selector, template);\r\n      if (!templateElement) {\r\n        return;\r\n      }\r\n      content = this._resolvePossibleFunction(content);\r\n      if (!content) {\r\n        templateElement.remove();\r\n        return;\r\n      }\r\n      if (isElement$1(content)) {\r\n        this._putElementInTemplate(getElement(content), templateElement);\r\n        return;\r\n      }\r\n      if (this._config.html) {\r\n        templateElement.innerHTML = this._maybeSanitize(content);\r\n        return;\r\n      }\r\n      templateElement.textContent = content;\r\n    }\r\n    _maybeSanitize(arg) {\r\n      return this._config.sanitize ? sanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn) : arg;\r\n    }\r\n    _resolvePossibleFunction(arg) {\r\n      return execute(arg, [this]);\r\n    }\r\n    _putElementInTemplate(element, templateElement) {\r\n      if (this._config.html) {\r\n        templateElement.innerHTML = '';\r\n        templateElement.append(element);\r\n        return;\r\n      }\r\n      templateElement.textContent = element.textContent;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap tooltip.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const NAME$4 = 'tooltip';\r\n  const DISALLOWED_ATTRIBUTES = new Set(['sanitize', 'allowList', 'sanitizeFn']);\r\n  const CLASS_NAME_FADE$2 = 'fade';\r\n  const CLASS_NAME_MODAL = 'modal';\r\n  const CLASS_NAME_SHOW$2 = 'show';\r\n  const SELECTOR_TOOLTIP_INNER = '.tooltip-inner';\r\n  const SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;\r\n  const EVENT_MODAL_HIDE = 'hide.bs.modal';\r\n  const TRIGGER_HOVER = 'hover';\r\n  const TRIGGER_FOCUS = 'focus';\r\n  const TRIGGER_CLICK = 'click';\r\n  const TRIGGER_MANUAL = 'manual';\r\n  const EVENT_HIDE$2 = 'hide';\r\n  const EVENT_HIDDEN$2 = 'hidden';\r\n  const EVENT_SHOW$2 = 'show';\r\n  const EVENT_SHOWN$2 = 'shown';\r\n  const EVENT_INSERTED = 'inserted';\r\n  const EVENT_CLICK$1 = 'click';\r\n  const EVENT_FOCUSIN$1 = 'focusin';\r\n  const EVENT_FOCUSOUT$1 = 'focusout';\r\n  const EVENT_MOUSEENTER = 'mouseenter';\r\n  const EVENT_MOUSELEAVE = 'mouseleave';\r\n  const AttachmentMap = {\r\n    AUTO: 'auto',\r\n    TOP: 'top',\r\n    RIGHT: isRTL() ? 'left' : 'right',\r\n    BOTTOM: 'bottom',\r\n    LEFT: isRTL() ? 'right' : 'left'\r\n  };\r\n  const Default$3 = {\r\n    allowList: DefaultAllowlist,\r\n    animation: true,\r\n    boundary: 'clippingParents',\r\n    container: false,\r\n    customClass: '',\r\n    delay: 0,\r\n    fallbackPlacements: ['top', 'right', 'bottom', 'left'],\r\n    html: false,\r\n    offset: [0, 6],\r\n    placement: 'top',\r\n    popperConfig: null,\r\n    sanitize: true,\r\n    sanitizeFn: null,\r\n    selector: false,\r\n    template: '<div class=\"tooltip\" role=\"tooltip\">' + '<div class=\"tooltip-arrow\"></div>' + '<div class=\"tooltip-inner\"></div>' + '</div>',\r\n    title: '',\r\n    trigger: 'hover focus'\r\n  };\r\n  const DefaultType$3 = {\r\n    allowList: 'object',\r\n    animation: 'boolean',\r\n    boundary: '(string|element)',\r\n    container: '(string|element|boolean)',\r\n    customClass: '(string|function)',\r\n    delay: '(number|object)',\r\n    fallbackPlacements: 'array',\r\n    html: 'boolean',\r\n    offset: '(array|string|function)',\r\n    placement: '(string|function)',\r\n    popperConfig: '(null|object|function)',\r\n    sanitize: 'boolean',\r\n    sanitizeFn: '(null|function)',\r\n    selector: '(string|boolean)',\r\n    template: 'string',\r\n    title: '(string|element|function)',\r\n    trigger: 'string'\r\n  };\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class Tooltip extends BaseComponent {\r\n    constructor(element, config) {\r\n      if (typeof Popper === 'undefined') {\r\n        throw new TypeError('Bootstrap\\'s tooltips require Popper (https://popper.js.org)');\r\n      }\r\n      super(element, config);\r\n\r\n      // Private\r\n      this._isEnabled = true;\r\n      this._timeout = 0;\r\n      this._isHovered = null;\r\n      this._activeTrigger = {};\r\n      this._popper = null;\r\n      this._templateFactory = null;\r\n      this._newContent = null;\r\n\r\n      // Protected\r\n      this.tip = null;\r\n      this._setListeners();\r\n      if (!this._config.selector) {\r\n        this._fixTitle();\r\n      }\r\n    }\r\n\r\n    // Getters\r\n    static get Default() {\r\n      return Default$3;\r\n    }\r\n    static get DefaultType() {\r\n      return DefaultType$3;\r\n    }\r\n    static get NAME() {\r\n      return NAME$4;\r\n    }\r\n\r\n    // Public\r\n    enable() {\r\n      this._isEnabled = true;\r\n    }\r\n    disable() {\r\n      this._isEnabled = false;\r\n    }\r\n    toggleEnabled() {\r\n      this._isEnabled = !this._isEnabled;\r\n    }\r\n    toggle() {\r\n      if (!this._isEnabled) {\r\n        return;\r\n      }\r\n      this._activeTrigger.click = !this._activeTrigger.click;\r\n      if (this._isShown()) {\r\n        this._leave();\r\n        return;\r\n      }\r\n      this._enter();\r\n    }\r\n    dispose() {\r\n      clearTimeout(this._timeout);\r\n      EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);\r\n      if (this._element.getAttribute('data-bs-original-title')) {\r\n        this._element.setAttribute('title', this._element.getAttribute('data-bs-original-title'));\r\n      }\r\n      this._disposePopper();\r\n      super.dispose();\r\n    }\r\n    show() {\r\n      if (this._element.style.display === 'none') {\r\n        throw new Error('Please use show on visible elements');\r\n      }\r\n      if (!(this._isWithContent() && this._isEnabled)) {\r\n        return;\r\n      }\r\n      const showEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW$2));\r\n      const shadowRoot = findShadowRoot(this._element);\r\n      const isInTheDom = (shadowRoot || this._element.ownerDocument.documentElement).contains(this._element);\r\n      if (showEvent.defaultPrevented || !isInTheDom) {\r\n        return;\r\n      }\r\n\r\n      // TODO: v6 remove this or make it optional\r\n      this._disposePopper();\r\n      const tip = this._getTipElement();\r\n      this._element.setAttribute('aria-describedby', tip.getAttribute('id'));\r\n      const {\r\n        container\r\n      } = this._config;\r\n      if (!this._element.ownerDocument.documentElement.contains(this.tip)) {\r\n        container.append(tip);\r\n        EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED));\r\n      }\r\n      this._popper = this._createPopper(tip);\r\n      tip.classList.add(CLASS_NAME_SHOW$2);\r\n\r\n      // If this is a touch-enabled device we add extra\r\n      // empty mouseover listeners to the body's immediate children;\r\n      // only needed because of broken event delegation on iOS\r\n      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\r\n      if ('ontouchstart' in document.documentElement) {\r\n        for (const element of [].concat(...document.body.children)) {\r\n          EventHandler.on(element, 'mouseover', noop);\r\n        }\r\n      }\r\n      const complete = () => {\r\n        EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOWN$2));\r\n        if (this._isHovered === false) {\r\n          this._leave();\r\n        }\r\n        this._isHovered = false;\r\n      };\r\n      this._queueCallback(complete, this.tip, this._isAnimated());\r\n    }\r\n    hide() {\r\n      if (!this._isShown()) {\r\n        return;\r\n      }\r\n      const hideEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE$2));\r\n      if (hideEvent.defaultPrevented) {\r\n        return;\r\n      }\r\n      const tip = this._getTipElement();\r\n      tip.classList.remove(CLASS_NAME_SHOW$2);\r\n\r\n      // If this is a touch-enabled device we remove the extra\r\n      // empty mouseover listeners we added for iOS support\r\n      if ('ontouchstart' in document.documentElement) {\r\n        for (const element of [].concat(...document.body.children)) {\r\n          EventHandler.off(element, 'mouseover', noop);\r\n        }\r\n      }\r\n      this._activeTrigger[TRIGGER_CLICK] = false;\r\n      this._activeTrigger[TRIGGER_FOCUS] = false;\r\n      this._activeTrigger[TRIGGER_HOVER] = false;\r\n      this._isHovered = null; // it is a trick to support manual triggering\r\n\r\n      const complete = () => {\r\n        if (this._isWithActiveTrigger()) {\r\n          return;\r\n        }\r\n        if (!this._isHovered) {\r\n          this._disposePopper();\r\n        }\r\n        this._element.removeAttribute('aria-describedby');\r\n        EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDDEN$2));\r\n      };\r\n      this._queueCallback(complete, this.tip, this._isAnimated());\r\n    }\r\n    update() {\r\n      if (this._popper) {\r\n        this._popper.update();\r\n      }\r\n    }\r\n\r\n    // Protected\r\n    _isWithContent() {\r\n      return Boolean(this._getTitle());\r\n    }\r\n    _getTipElement() {\r\n      if (!this.tip) {\r\n        this.tip = this._createTipElement(this._newContent || this._getContentForTemplate());\r\n      }\r\n      return this.tip;\r\n    }\r\n    _createTipElement(content) {\r\n      const tip = this._getTemplateFactory(content).toHtml();\r\n\r\n      // TODO: remove this check in v6\r\n      if (!tip) {\r\n        return null;\r\n      }\r\n      tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);\r\n      // TODO: v6 the following can be achieved with CSS only\r\n      tip.classList.add(`bs-${this.constructor.NAME}-auto`);\r\n      const tipId = getUID(this.constructor.NAME).toString();\r\n      tip.setAttribute('id', tipId);\r\n      if (this._isAnimated()) {\r\n        tip.classList.add(CLASS_NAME_FADE$2);\r\n      }\r\n      return tip;\r\n    }\r\n    setContent(content) {\r\n      this._newContent = content;\r\n      if (this._isShown()) {\r\n        this._disposePopper();\r\n        this.show();\r\n      }\r\n    }\r\n    _getTemplateFactory(content) {\r\n      if (this._templateFactory) {\r\n        this._templateFactory.changeContent(content);\r\n      } else {\r\n        this._templateFactory = new TemplateFactory({\r\n          ...this._config,\r\n          // the `content` var has to be after `this._config`\r\n          // to override config.content in case of popover\r\n          content,\r\n          extraClass: this._resolvePossibleFunction(this._config.customClass)\r\n        });\r\n      }\r\n      return this._templateFactory;\r\n    }\r\n    _getContentForTemplate() {\r\n      return {\r\n        [SELECTOR_TOOLTIP_INNER]: this._getTitle()\r\n      };\r\n    }\r\n    _getTitle() {\r\n      return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute('data-bs-original-title');\r\n    }\r\n\r\n    // Private\r\n    _initializeOnDelegatedTarget(event) {\r\n      return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());\r\n    }\r\n    _isAnimated() {\r\n      return this._config.animation || this.tip && this.tip.classList.contains(CLASS_NAME_FADE$2);\r\n    }\r\n    _isShown() {\r\n      return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$2);\r\n    }\r\n    _createPopper(tip) {\r\n      const placement = execute(this._config.placement, [this, tip, this._element]);\r\n      const attachment = AttachmentMap[placement.toUpperCase()];\r\n      return createPopper(this._element, tip, this._getPopperConfig(attachment));\r\n    }\r\n    _getOffset() {\r\n      const {\r\n        offset\r\n      } = this._config;\r\n      if (typeof offset === 'string') {\r\n        return offset.split(',').map(value => Number.parseInt(value, 10));\r\n      }\r\n      if (typeof offset === 'function') {\r\n        return popperData => offset(popperData, this._element);\r\n      }\r\n      return offset;\r\n    }\r\n    _resolvePossibleFunction(arg) {\r\n      return execute(arg, [this._element]);\r\n    }\r\n    _getPopperConfig(attachment) {\r\n      const defaultBsPopperConfig = {\r\n        placement: attachment,\r\n        modifiers: [{\r\n          name: 'flip',\r\n          options: {\r\n            fallbackPlacements: this._config.fallbackPlacements\r\n          }\r\n        }, {\r\n          name: 'offset',\r\n          options: {\r\n            offset: this._getOffset()\r\n          }\r\n        }, {\r\n          name: 'preventOverflow',\r\n          options: {\r\n            boundary: this._config.boundary\r\n          }\r\n        }, {\r\n          name: 'arrow',\r\n          options: {\r\n            element: `.${this.constructor.NAME}-arrow`\r\n          }\r\n        }, {\r\n          name: 'preSetPlacement',\r\n          enabled: true,\r\n          phase: 'beforeMain',\r\n          fn: data => {\r\n            // Pre-set Popper's placement attribute in order to read the arrow sizes properly.\r\n            // Otherwise, Popper mixes up the width and height dimensions since the initial arrow style is for top placement\r\n            this._getTipElement().setAttribute('data-popper-placement', data.state.placement);\r\n          }\r\n        }]\r\n      };\r\n      return {\r\n        ...defaultBsPopperConfig,\r\n        ...execute(this._config.popperConfig, [defaultBsPopperConfig])\r\n      };\r\n    }\r\n    _setListeners() {\r\n      const triggers = this._config.trigger.split(' ');\r\n      for (const trigger of triggers) {\r\n        if (trigger === 'click') {\r\n          EventHandler.on(this._element, this.constructor.eventName(EVENT_CLICK$1), this._config.selector, event => {\r\n            const context = this._initializeOnDelegatedTarget(event);\r\n            context.toggle();\r\n          });\r\n        } else if (trigger !== TRIGGER_MANUAL) {\r\n          const eventIn = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN$1);\r\n          const eventOut = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT$1);\r\n          EventHandler.on(this._element, eventIn, this._config.selector, event => {\r\n            const context = this._initializeOnDelegatedTarget(event);\r\n            context._activeTrigger[event.type === 'focusin' ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;\r\n            context._enter();\r\n          });\r\n          EventHandler.on(this._element, eventOut, this._config.selector, event => {\r\n            const context = this._initializeOnDelegatedTarget(event);\r\n            context._activeTrigger[event.type === 'focusout' ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);\r\n            context._leave();\r\n          });\r\n        }\r\n      }\r\n      this._hideModalHandler = () => {\r\n        if (this._element) {\r\n          this.hide();\r\n        }\r\n      };\r\n      EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);\r\n    }\r\n    _fixTitle() {\r\n      const title = this._element.getAttribute('title');\r\n      if (!title) {\r\n        return;\r\n      }\r\n      if (!this._element.getAttribute('aria-label') && !this._element.textContent.trim()) {\r\n        this._element.setAttribute('aria-label', title);\r\n      }\r\n      this._element.setAttribute('data-bs-original-title', title); // DO NOT USE IT. Is only for backwards compatibility\r\n      this._element.removeAttribute('title');\r\n    }\r\n    _enter() {\r\n      if (this._isShown() || this._isHovered) {\r\n        this._isHovered = true;\r\n        return;\r\n      }\r\n      this._isHovered = true;\r\n      this._setTimeout(() => {\r\n        if (this._isHovered) {\r\n          this.show();\r\n        }\r\n      }, this._config.delay.show);\r\n    }\r\n    _leave() {\r\n      if (this._isWithActiveTrigger()) {\r\n        return;\r\n      }\r\n      this._isHovered = false;\r\n      this._setTimeout(() => {\r\n        if (!this._isHovered) {\r\n          this.hide();\r\n        }\r\n      }, this._config.delay.hide);\r\n    }\r\n    _setTimeout(handler, timeout) {\r\n      clearTimeout(this._timeout);\r\n      this._timeout = setTimeout(handler, timeout);\r\n    }\r\n    _isWithActiveTrigger() {\r\n      return Object.values(this._activeTrigger).includes(true);\r\n    }\r\n    _getConfig(config) {\r\n      const dataAttributes = Manipulator.getDataAttributes(this._element);\r\n      for (const dataAttribute of Object.keys(dataAttributes)) {\r\n        if (DISALLOWED_ATTRIBUTES.has(dataAttribute)) {\r\n          delete dataAttributes[dataAttribute];\r\n        }\r\n      }\r\n      config = {\r\n        ...dataAttributes,\r\n        ...(typeof config === 'object' && config ? config : {})\r\n      };\r\n      config = this._mergeConfigObj(config);\r\n      config = this._configAfterMerge(config);\r\n      this._typeCheckConfig(config);\r\n      return config;\r\n    }\r\n    _configAfterMerge(config) {\r\n      config.container = config.container === false ? document.body : getElement(config.container);\r\n      if (typeof config.delay === 'number') {\r\n        config.delay = {\r\n          show: config.delay,\r\n          hide: config.delay\r\n        };\r\n      }\r\n      if (typeof config.title === 'number') {\r\n        config.title = config.title.toString();\r\n      }\r\n      if (typeof config.content === 'number') {\r\n        config.content = config.content.toString();\r\n      }\r\n      return config;\r\n    }\r\n    _getDelegateConfig() {\r\n      const config = {};\r\n      for (const [key, value] of Object.entries(this._config)) {\r\n        if (this.constructor.Default[key] !== value) {\r\n          config[key] = value;\r\n        }\r\n      }\r\n      config.selector = false;\r\n      config.trigger = 'manual';\r\n\r\n      // In the future can be replaced with:\r\n      // const keysWithDifferentValues = Object.entries(this._config).filter(entry => this.constructor.Default[entry[0]] !== this._config[entry[0]])\r\n      // `Object.fromEntries(keysWithDifferentValues)`\r\n      return config;\r\n    }\r\n    _disposePopper() {\r\n      if (this._popper) {\r\n        this._popper.destroy();\r\n        this._popper = null;\r\n      }\r\n      if (this.tip) {\r\n        this.tip.remove();\r\n        this.tip = null;\r\n      }\r\n    }\r\n\r\n    // Static\r\n    static jQueryInterface(config) {\r\n      return this.each(function () {\r\n        const data = Tooltip.getOrCreateInstance(this, config);\r\n        if (typeof config !== 'string') {\r\n          return;\r\n        }\r\n        if (typeof data[config] === 'undefined') {\r\n          throw new TypeError(`No method named \"${config}\"`);\r\n        }\r\n        data[config]();\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * jQuery\r\n   */\r\n\r\n  defineJQueryPlugin(Tooltip);\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap popover.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const NAME$3 = 'popover';\r\n  const SELECTOR_TITLE = '.popover-header';\r\n  const SELECTOR_CONTENT = '.popover-body';\r\n  const Default$2 = {\r\n    ...Tooltip.Default,\r\n    content: '',\r\n    offset: [0, 8],\r\n    placement: 'right',\r\n    template: '<div class=\"popover\" role=\"tooltip\">' + '<div class=\"popover-arrow\"></div>' + '<h3 class=\"popover-header\"></h3>' + '<div class=\"popover-body\"></div>' + '</div>',\r\n    trigger: 'click'\r\n  };\r\n  const DefaultType$2 = {\r\n    ...Tooltip.DefaultType,\r\n    content: '(null|string|element|function)'\r\n  };\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class Popover extends Tooltip {\r\n    // Getters\r\n    static get Default() {\r\n      return Default$2;\r\n    }\r\n    static get DefaultType() {\r\n      return DefaultType$2;\r\n    }\r\n    static get NAME() {\r\n      return NAME$3;\r\n    }\r\n\r\n    // Overrides\r\n    _isWithContent() {\r\n      return this._getTitle() || this._getContent();\r\n    }\r\n\r\n    // Private\r\n    _getContentForTemplate() {\r\n      return {\r\n        [SELECTOR_TITLE]: this._getTitle(),\r\n        [SELECTOR_CONTENT]: this._getContent()\r\n      };\r\n    }\r\n    _getContent() {\r\n      return this._resolvePossibleFunction(this._config.content);\r\n    }\r\n\r\n    // Static\r\n    static jQueryInterface(config) {\r\n      return this.each(function () {\r\n        const data = Popover.getOrCreateInstance(this, config);\r\n        if (typeof config !== 'string') {\r\n          return;\r\n        }\r\n        if (typeof data[config] === 'undefined') {\r\n          throw new TypeError(`No method named \"${config}\"`);\r\n        }\r\n        data[config]();\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * jQuery\r\n   */\r\n\r\n  defineJQueryPlugin(Popover);\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap scrollspy.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const NAME$2 = 'scrollspy';\r\n  const DATA_KEY$2 = 'bs.scrollspy';\r\n  const EVENT_KEY$2 = `.${DATA_KEY$2}`;\r\n  const DATA_API_KEY = '.data-api';\r\n  const EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;\r\n  const EVENT_CLICK = `click${EVENT_KEY$2}`;\r\n  const EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$2}${DATA_API_KEY}`;\r\n  const CLASS_NAME_DROPDOWN_ITEM = 'dropdown-item';\r\n  const CLASS_NAME_ACTIVE$1 = 'active';\r\n  const SELECTOR_DATA_SPY = '[data-bs-spy=\"scroll\"]';\r\n  const SELECTOR_TARGET_LINKS = '[href]';\r\n  const SELECTOR_NAV_LIST_GROUP = '.nav, .list-group';\r\n  const SELECTOR_NAV_LINKS = '.nav-link';\r\n  const SELECTOR_NAV_ITEMS = '.nav-item';\r\n  const SELECTOR_LIST_ITEMS = '.list-group-item';\r\n  const SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_NAV_ITEMS} > ${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`;\r\n  const SELECTOR_DROPDOWN = '.dropdown';\r\n  const SELECTOR_DROPDOWN_TOGGLE$1 = '.dropdown-toggle';\r\n  const Default$1 = {\r\n    offset: null,\r\n    // TODO: v6 @deprecated, keep it for backwards compatibility reasons\r\n    rootMargin: '0px 0px -25%',\r\n    smoothScroll: false,\r\n    target: null,\r\n    threshold: [0.1, 0.5, 1]\r\n  };\r\n  const DefaultType$1 = {\r\n    offset: '(number|null)',\r\n    // TODO v6 @deprecated, keep it for backwards compatibility reasons\r\n    rootMargin: 'string',\r\n    smoothScroll: 'boolean',\r\n    target: 'element',\r\n    threshold: 'array'\r\n  };\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class ScrollSpy extends BaseComponent {\r\n    constructor(element, config) {\r\n      super(element, config);\r\n\r\n      // this._element is the observablesContainer and config.target the menu links wrapper\r\n      this._targetLinks = new Map();\r\n      this._observableSections = new Map();\r\n      this._rootElement = getComputedStyle(this._element).overflowY === 'visible' ? null : this._element;\r\n      this._activeTarget = null;\r\n      this._observer = null;\r\n      this._previousScrollData = {\r\n        visibleEntryTop: 0,\r\n        parentScrollTop: 0\r\n      };\r\n      this.refresh(); // initialize\r\n    }\r\n\r\n    // Getters\r\n    static get Default() {\r\n      return Default$1;\r\n    }\r\n    static get DefaultType() {\r\n      return DefaultType$1;\r\n    }\r\n    static get NAME() {\r\n      return NAME$2;\r\n    }\r\n\r\n    // Public\r\n    refresh() {\r\n      this._initializeTargetsAndObservables();\r\n      this._maybeEnableSmoothScroll();\r\n      if (this._observer) {\r\n        this._observer.disconnect();\r\n      } else {\r\n        this._observer = this._getNewObserver();\r\n      }\r\n      for (const section of this._observableSections.values()) {\r\n        this._observer.observe(section);\r\n      }\r\n    }\r\n    dispose() {\r\n      this._observer.disconnect();\r\n      super.dispose();\r\n    }\r\n\r\n    // Private\r\n    _configAfterMerge(config) {\r\n      // TODO: on v6 target should be given explicitly & remove the {target: 'ss-target'} case\r\n      config.target = getElement(config.target) || document.body;\r\n\r\n      // TODO: v6 Only for backwards compatibility reasons. Use rootMargin only\r\n      config.rootMargin = config.offset ? `${config.offset}px 0px -30%` : config.rootMargin;\r\n      if (typeof config.threshold === 'string') {\r\n        config.threshold = config.threshold.split(',').map(value => Number.parseFloat(value));\r\n      }\r\n      return config;\r\n    }\r\n    _maybeEnableSmoothScroll() {\r\n      if (!this._config.smoothScroll) {\r\n        return;\r\n      }\r\n\r\n      // unregister any previous listeners\r\n      EventHandler.off(this._config.target, EVENT_CLICK);\r\n      EventHandler.on(this._config.target, EVENT_CLICK, SELECTOR_TARGET_LINKS, event => {\r\n        const observableSection = this._observableSections.get(event.target.hash);\r\n        if (observableSection) {\r\n          event.preventDefault();\r\n          const root = this._rootElement || window;\r\n          const height = observableSection.offsetTop - this._element.offsetTop;\r\n          if (root.scrollTo) {\r\n            root.scrollTo({\r\n              top: height,\r\n              behavior: 'smooth'\r\n            });\r\n            return;\r\n          }\r\n\r\n          // Chrome 60 doesn't support `scrollTo`\r\n          root.scrollTop = height;\r\n        }\r\n      });\r\n    }\r\n    _getNewObserver() {\r\n      const options = {\r\n        root: this._rootElement,\r\n        threshold: this._config.threshold,\r\n        rootMargin: this._config.rootMargin\r\n      };\r\n      return new IntersectionObserver(entries => this._observerCallback(entries), options);\r\n    }\r\n\r\n    // The logic of selection\r\n    _observerCallback(entries) {\r\n      const targetElement = entry => this._targetLinks.get(`#${entry.target.id}`);\r\n      const activate = entry => {\r\n        this._previousScrollData.visibleEntryTop = entry.target.offsetTop;\r\n        this._process(targetElement(entry));\r\n      };\r\n      const parentScrollTop = (this._rootElement || document.documentElement).scrollTop;\r\n      const userScrollsDown = parentScrollTop >= this._previousScrollData.parentScrollTop;\r\n      this._previousScrollData.parentScrollTop = parentScrollTop;\r\n      for (const entry of entries) {\r\n        if (!entry.isIntersecting) {\r\n          this._activeTarget = null;\r\n          this._clearActiveClass(targetElement(entry));\r\n          continue;\r\n        }\r\n        const entryIsLowerThanPrevious = entry.target.offsetTop >= this._previousScrollData.visibleEntryTop;\r\n        // if we are scrolling down, pick the bigger offsetTop\r\n        if (userScrollsDown && entryIsLowerThanPrevious) {\r\n          activate(entry);\r\n          // if parent isn't scrolled, let's keep the first visible item, breaking the iteration\r\n          if (!parentScrollTop) {\r\n            return;\r\n          }\r\n          continue;\r\n        }\r\n\r\n        // if we are scrolling up, pick the smallest offsetTop\r\n        if (!userScrollsDown && !entryIsLowerThanPrevious) {\r\n          activate(entry);\r\n        }\r\n      }\r\n    }\r\n    _initializeTargetsAndObservables() {\r\n      this._targetLinks = new Map();\r\n      this._observableSections = new Map();\r\n      const targetLinks = SelectorEngine.find(SELECTOR_TARGET_LINKS, this._config.target);\r\n      for (const anchor of targetLinks) {\r\n        // ensure that the anchor has an id and is not disabled\r\n        if (!anchor.hash || isDisabled(anchor)) {\r\n          continue;\r\n        }\r\n        const observableSection = SelectorEngine.findOne(decodeURI(anchor.hash), this._element);\r\n\r\n        // ensure that the observableSection exists & is visible\r\n        if (isVisible(observableSection)) {\r\n          this._targetLinks.set(decodeURI(anchor.hash), anchor);\r\n          this._observableSections.set(anchor.hash, observableSection);\r\n        }\r\n      }\r\n    }\r\n    _process(target) {\r\n      if (this._activeTarget === target) {\r\n        return;\r\n      }\r\n      this._clearActiveClass(this._config.target);\r\n      this._activeTarget = target;\r\n      target.classList.add(CLASS_NAME_ACTIVE$1);\r\n      this._activateParents(target);\r\n      EventHandler.trigger(this._element, EVENT_ACTIVATE, {\r\n        relatedTarget: target\r\n      });\r\n    }\r\n    _activateParents(target) {\r\n      // Activate dropdown parents\r\n      if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {\r\n        SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, target.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE$1);\r\n        return;\r\n      }\r\n      for (const listGroup of SelectorEngine.parents(target, SELECTOR_NAV_LIST_GROUP)) {\r\n        // Set triggered links parents as active\r\n        // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor\r\n        for (const item of SelectorEngine.prev(listGroup, SELECTOR_LINK_ITEMS)) {\r\n          item.classList.add(CLASS_NAME_ACTIVE$1);\r\n        }\r\n      }\r\n    }\r\n    _clearActiveClass(parent) {\r\n      parent.classList.remove(CLASS_NAME_ACTIVE$1);\r\n      const activeNodes = SelectorEngine.find(`${SELECTOR_TARGET_LINKS}.${CLASS_NAME_ACTIVE$1}`, parent);\r\n      for (const node of activeNodes) {\r\n        node.classList.remove(CLASS_NAME_ACTIVE$1);\r\n      }\r\n    }\r\n\r\n    // Static\r\n    static jQueryInterface(config) {\r\n      return this.each(function () {\r\n        const data = ScrollSpy.getOrCreateInstance(this, config);\r\n        if (typeof config !== 'string') {\r\n          return;\r\n        }\r\n        if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\r\n          throw new TypeError(`No method named \"${config}\"`);\r\n        }\r\n        data[config]();\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Data API implementation\r\n   */\r\n\r\n  EventHandler.on(window, EVENT_LOAD_DATA_API$1, () => {\r\n    for (const spy of SelectorEngine.find(SELECTOR_DATA_SPY)) {\r\n      ScrollSpy.getOrCreateInstance(spy);\r\n    }\r\n  });\r\n\r\n  /**\r\n   * jQuery\r\n   */\r\n\r\n  defineJQueryPlugin(ScrollSpy);\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap tab.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const NAME$1 = 'tab';\r\n  const DATA_KEY$1 = 'bs.tab';\r\n  const EVENT_KEY$1 = `.${DATA_KEY$1}`;\r\n  const EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;\r\n  const EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;\r\n  const EVENT_SHOW$1 = `show${EVENT_KEY$1}`;\r\n  const EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;\r\n  const EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}`;\r\n  const EVENT_KEYDOWN = `keydown${EVENT_KEY$1}`;\r\n  const EVENT_LOAD_DATA_API = `load${EVENT_KEY$1}`;\r\n  const ARROW_LEFT_KEY = 'ArrowLeft';\r\n  const ARROW_RIGHT_KEY = 'ArrowRight';\r\n  const ARROW_UP_KEY = 'ArrowUp';\r\n  const ARROW_DOWN_KEY = 'ArrowDown';\r\n  const HOME_KEY = 'Home';\r\n  const END_KEY = 'End';\r\n  const CLASS_NAME_ACTIVE = 'active';\r\n  const CLASS_NAME_FADE$1 = 'fade';\r\n  const CLASS_NAME_SHOW$1 = 'show';\r\n  const CLASS_DROPDOWN = 'dropdown';\r\n  const SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle';\r\n  const SELECTOR_DROPDOWN_MENU = '.dropdown-menu';\r\n  const NOT_SELECTOR_DROPDOWN_TOGGLE = `:not(${SELECTOR_DROPDOWN_TOGGLE})`;\r\n  const SELECTOR_TAB_PANEL = '.list-group, .nav, [role=\"tablist\"]';\r\n  const SELECTOR_OUTER = '.nav-item, .list-group-item';\r\n  const SELECTOR_INNER = `.nav-link${NOT_SELECTOR_DROPDOWN_TOGGLE}, .list-group-item${NOT_SELECTOR_DROPDOWN_TOGGLE}, [role=\"tab\"]${NOT_SELECTOR_DROPDOWN_TOGGLE}`;\r\n  const SELECTOR_DATA_TOGGLE = '[data-bs-toggle=\"tab\"], [data-bs-toggle=\"pill\"], [data-bs-toggle=\"list\"]'; // TODO: could only be `tab` in v6\r\n  const SELECTOR_INNER_ELEM = `${SELECTOR_INNER}, ${SELECTOR_DATA_TOGGLE}`;\r\n  const SELECTOR_DATA_TOGGLE_ACTIVE = `.${CLASS_NAME_ACTIVE}[data-bs-toggle=\"tab\"], .${CLASS_NAME_ACTIVE}[data-bs-toggle=\"pill\"], .${CLASS_NAME_ACTIVE}[data-bs-toggle=\"list\"]`;\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class Tab extends BaseComponent {\r\n    constructor(element) {\r\n      super(element);\r\n      this._parent = this._element.closest(SELECTOR_TAB_PANEL);\r\n      if (!this._parent) {\r\n        return;\r\n        // TODO: should throw exception in v6\r\n        // throw new TypeError(`${element.outerHTML} has not a valid parent ${SELECTOR_INNER_ELEM}`)\r\n      }\r\n\r\n      // Set up initial aria attributes\r\n      this._setInitialAttributes(this._parent, this._getChildren());\r\n      EventHandler.on(this._element, EVENT_KEYDOWN, event => this._keydown(event));\r\n    }\r\n\r\n    // Getters\r\n    static get NAME() {\r\n      return NAME$1;\r\n    }\r\n\r\n    // Public\r\n    show() {\r\n      // Shows this elem and deactivate the active sibling if exists\r\n      const innerElem = this._element;\r\n      if (this._elemIsActive(innerElem)) {\r\n        return;\r\n      }\r\n\r\n      // Search for active tab on same parent to deactivate it\r\n      const active = this._getActiveElem();\r\n      const hideEvent = active ? EventHandler.trigger(active, EVENT_HIDE$1, {\r\n        relatedTarget: innerElem\r\n      }) : null;\r\n      const showEvent = EventHandler.trigger(innerElem, EVENT_SHOW$1, {\r\n        relatedTarget: active\r\n      });\r\n      if (showEvent.defaultPrevented || hideEvent && hideEvent.defaultPrevented) {\r\n        return;\r\n      }\r\n      this._deactivate(active, innerElem);\r\n      this._activate(innerElem, active);\r\n    }\r\n\r\n    // Private\r\n    _activate(element, relatedElem) {\r\n      if (!element) {\r\n        return;\r\n      }\r\n      element.classList.add(CLASS_NAME_ACTIVE);\r\n      this._activate(SelectorEngine.getElementFromSelector(element)); // Search and activate/show the proper section\r\n\r\n      const complete = () => {\r\n        if (element.getAttribute('role') !== 'tab') {\r\n          element.classList.add(CLASS_NAME_SHOW$1);\r\n          return;\r\n        }\r\n        element.removeAttribute('tabindex');\r\n        element.setAttribute('aria-selected', true);\r\n        this._toggleDropDown(element, true);\r\n        EventHandler.trigger(element, EVENT_SHOWN$1, {\r\n          relatedTarget: relatedElem\r\n        });\r\n      };\r\n      this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));\r\n    }\r\n    _deactivate(element, relatedElem) {\r\n      if (!element) {\r\n        return;\r\n      }\r\n      element.classList.remove(CLASS_NAME_ACTIVE);\r\n      element.blur();\r\n      this._deactivate(SelectorEngine.getElementFromSelector(element)); // Search and deactivate the shown section too\r\n\r\n      const complete = () => {\r\n        if (element.getAttribute('role') !== 'tab') {\r\n          element.classList.remove(CLASS_NAME_SHOW$1);\r\n          return;\r\n        }\r\n        element.setAttribute('aria-selected', false);\r\n        element.setAttribute('tabindex', '-1');\r\n        this._toggleDropDown(element, false);\r\n        EventHandler.trigger(element, EVENT_HIDDEN$1, {\r\n          relatedTarget: relatedElem\r\n        });\r\n      };\r\n      this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));\r\n    }\r\n    _keydown(event) {\r\n      if (![ARROW_LEFT_KEY, ARROW_RIGHT_KEY, ARROW_UP_KEY, ARROW_DOWN_KEY, HOME_KEY, END_KEY].includes(event.key)) {\r\n        return;\r\n      }\r\n      event.stopPropagation(); // stopPropagation/preventDefault both added to support up/down keys without scrolling the page\r\n      event.preventDefault();\r\n      const children = this._getChildren().filter(element => !isDisabled(element));\r\n      let nextActiveElement;\r\n      if ([HOME_KEY, END_KEY].includes(event.key)) {\r\n        nextActiveElement = children[event.key === HOME_KEY ? 0 : children.length - 1];\r\n      } else {\r\n        const isNext = [ARROW_RIGHT_KEY, ARROW_DOWN_KEY].includes(event.key);\r\n        nextActiveElement = getNextActiveElement(children, event.target, isNext, true);\r\n      }\r\n      if (nextActiveElement) {\r\n        nextActiveElement.focus({\r\n          preventScroll: true\r\n        });\r\n        Tab.getOrCreateInstance(nextActiveElement).show();\r\n      }\r\n    }\r\n    _getChildren() {\r\n      // collection of inner elements\r\n      return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent);\r\n    }\r\n    _getActiveElem() {\r\n      return this._getChildren().find(child => this._elemIsActive(child)) || null;\r\n    }\r\n    _setInitialAttributes(parent, children) {\r\n      this._setAttributeIfNotExists(parent, 'role', 'tablist');\r\n      for (const child of children) {\r\n        this._setInitialAttributesOnChild(child);\r\n      }\r\n    }\r\n    _setInitialAttributesOnChild(child) {\r\n      child = this._getInnerElement(child);\r\n      const isActive = this._elemIsActive(child);\r\n      const outerElem = this._getOuterElement(child);\r\n      child.setAttribute('aria-selected', isActive);\r\n      if (outerElem !== child) {\r\n        this._setAttributeIfNotExists(outerElem, 'role', 'presentation');\r\n      }\r\n      if (!isActive) {\r\n        child.setAttribute('tabindex', '-1');\r\n      }\r\n      this._setAttributeIfNotExists(child, 'role', 'tab');\r\n\r\n      // set attributes to the related panel too\r\n      this._setInitialAttributesOnTargetPanel(child);\r\n    }\r\n    _setInitialAttributesOnTargetPanel(child) {\r\n      const target = SelectorEngine.getElementFromSelector(child);\r\n      if (!target) {\r\n        return;\r\n      }\r\n      this._setAttributeIfNotExists(target, 'role', 'tabpanel');\r\n      if (child.id) {\r\n        this._setAttributeIfNotExists(target, 'aria-labelledby', `${child.id}`);\r\n      }\r\n    }\r\n    _toggleDropDown(element, open) {\r\n      const outerElem = this._getOuterElement(element);\r\n      if (!outerElem.classList.contains(CLASS_DROPDOWN)) {\r\n        return;\r\n      }\r\n      const toggle = (selector, className) => {\r\n        const element = SelectorEngine.findOne(selector, outerElem);\r\n        if (element) {\r\n          element.classList.toggle(className, open);\r\n        }\r\n      };\r\n      toggle(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE);\r\n      toggle(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$1);\r\n      outerElem.setAttribute('aria-expanded', open);\r\n    }\r\n    _setAttributeIfNotExists(element, attribute, value) {\r\n      if (!element.hasAttribute(attribute)) {\r\n        element.setAttribute(attribute, value);\r\n      }\r\n    }\r\n    _elemIsActive(elem) {\r\n      return elem.classList.contains(CLASS_NAME_ACTIVE);\r\n    }\r\n\r\n    // Try to get the inner element (usually the .nav-link)\r\n    _getInnerElement(elem) {\r\n      return elem.matches(SELECTOR_INNER_ELEM) ? elem : SelectorEngine.findOne(SELECTOR_INNER_ELEM, elem);\r\n    }\r\n\r\n    // Try to get the outer element (usually the .nav-item)\r\n    _getOuterElement(elem) {\r\n      return elem.closest(SELECTOR_OUTER) || elem;\r\n    }\r\n\r\n    // Static\r\n    static jQueryInterface(config) {\r\n      return this.each(function () {\r\n        const data = Tab.getOrCreateInstance(this);\r\n        if (typeof config !== 'string') {\r\n          return;\r\n        }\r\n        if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\r\n          throw new TypeError(`No method named \"${config}\"`);\r\n        }\r\n        data[config]();\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Data API implementation\r\n   */\r\n\r\n  EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {\r\n    if (['A', 'AREA'].includes(this.tagName)) {\r\n      event.preventDefault();\r\n    }\r\n    if (isDisabled(this)) {\r\n      return;\r\n    }\r\n    Tab.getOrCreateInstance(this).show();\r\n  });\r\n\r\n  /**\r\n   * Initialize on focus\r\n   */\r\n  EventHandler.on(window, EVENT_LOAD_DATA_API, () => {\r\n    for (const element of SelectorEngine.find(SELECTOR_DATA_TOGGLE_ACTIVE)) {\r\n      Tab.getOrCreateInstance(element);\r\n    }\r\n  });\r\n  /**\r\n   * jQuery\r\n   */\r\n\r\n  defineJQueryPlugin(Tab);\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap toast.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const NAME = 'toast';\r\n  const DATA_KEY = 'bs.toast';\r\n  const EVENT_KEY = `.${DATA_KEY}`;\r\n  const EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;\r\n  const EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;\r\n  const EVENT_FOCUSIN = `focusin${EVENT_KEY}`;\r\n  const EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;\r\n  const EVENT_HIDE = `hide${EVENT_KEY}`;\r\n  const EVENT_HIDDEN = `hidden${EVENT_KEY}`;\r\n  const EVENT_SHOW = `show${EVENT_KEY}`;\r\n  const EVENT_SHOWN = `shown${EVENT_KEY}`;\r\n  const CLASS_NAME_FADE = 'fade';\r\n  const CLASS_NAME_HIDE = 'hide'; // @deprecated - kept here only for backwards compatibility\r\n  const CLASS_NAME_SHOW = 'show';\r\n  const CLASS_NAME_SHOWING = 'showing';\r\n  const DefaultType = {\r\n    animation: 'boolean',\r\n    autohide: 'boolean',\r\n    delay: 'number'\r\n  };\r\n  const Default = {\r\n    animation: true,\r\n    autohide: true,\r\n    delay: 5000\r\n  };\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class Toast extends BaseComponent {\r\n    constructor(element, config) {\r\n      super(element, config);\r\n      this._timeout = null;\r\n      this._hasMouseInteraction = false;\r\n      this._hasKeyboardInteraction = false;\r\n      this._setListeners();\r\n    }\r\n\r\n    // Getters\r\n    static get Default() {\r\n      return Default;\r\n    }\r\n    static get DefaultType() {\r\n      return DefaultType;\r\n    }\r\n    static get NAME() {\r\n      return NAME;\r\n    }\r\n\r\n    // Public\r\n    show() {\r\n      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);\r\n      if (showEvent.defaultPrevented) {\r\n        return;\r\n      }\r\n      this._clearTimeout();\r\n      if (this._config.animation) {\r\n        this._element.classList.add(CLASS_NAME_FADE);\r\n      }\r\n      const complete = () => {\r\n        this._element.classList.remove(CLASS_NAME_SHOWING);\r\n        EventHandler.trigger(this._element, EVENT_SHOWN);\r\n        this._maybeScheduleHide();\r\n      };\r\n      this._element.classList.remove(CLASS_NAME_HIDE); // @deprecated\r\n      reflow(this._element);\r\n      this._element.classList.add(CLASS_NAME_SHOW, CLASS_NAME_SHOWING);\r\n      this._queueCallback(complete, this._element, this._config.animation);\r\n    }\r\n    hide() {\r\n      if (!this.isShown()) {\r\n        return;\r\n      }\r\n      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);\r\n      if (hideEvent.defaultPrevented) {\r\n        return;\r\n      }\r\n      const complete = () => {\r\n        this._element.classList.add(CLASS_NAME_HIDE); // @deprecated\r\n        this._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW);\r\n        EventHandler.trigger(this._element, EVENT_HIDDEN);\r\n      };\r\n      this._element.classList.add(CLASS_NAME_SHOWING);\r\n      this._queueCallback(complete, this._element, this._config.animation);\r\n    }\r\n    dispose() {\r\n      this._clearTimeout();\r\n      if (this.isShown()) {\r\n        this._element.classList.remove(CLASS_NAME_SHOW);\r\n      }\r\n      super.dispose();\r\n    }\r\n    isShown() {\r\n      return this._element.classList.contains(CLASS_NAME_SHOW);\r\n    }\r\n\r\n    // Private\r\n\r\n    _maybeScheduleHide() {\r\n      if (!this._config.autohide) {\r\n        return;\r\n      }\r\n      if (this._hasMouseInteraction || this._hasKeyboardInteraction) {\r\n        return;\r\n      }\r\n      this._timeout = setTimeout(() => {\r\n        this.hide();\r\n      }, this._config.delay);\r\n    }\r\n    _onInteraction(event, isInteracting) {\r\n      switch (event.type) {\r\n        case 'mouseover':\r\n        case 'mouseout':\r\n          {\r\n            this._hasMouseInteraction = isInteracting;\r\n            break;\r\n          }\r\n        case 'focusin':\r\n        case 'focusout':\r\n          {\r\n            this._hasKeyboardInteraction = isInteracting;\r\n            break;\r\n          }\r\n      }\r\n      if (isInteracting) {\r\n        this._clearTimeout();\r\n        return;\r\n      }\r\n      const nextElement = event.relatedTarget;\r\n      if (this._element === nextElement || this._element.contains(nextElement)) {\r\n        return;\r\n      }\r\n      this._maybeScheduleHide();\r\n    }\r\n    _setListeners() {\r\n      EventHandler.on(this._element, EVENT_MOUSEOVER, event => this._onInteraction(event, true));\r\n      EventHandler.on(this._element, EVENT_MOUSEOUT, event => this._onInteraction(event, false));\r\n      EventHandler.on(this._element, EVENT_FOCUSIN, event => this._onInteraction(event, true));\r\n      EventHandler.on(this._element, EVENT_FOCUSOUT, event => this._onInteraction(event, false));\r\n    }\r\n    _clearTimeout() {\r\n      clearTimeout(this._timeout);\r\n      this._timeout = null;\r\n    }\r\n\r\n    // Static\r\n    static jQueryInterface(config) {\r\n      return this.each(function () {\r\n        const data = Toast.getOrCreateInstance(this, config);\r\n        if (typeof config === 'string') {\r\n          if (typeof data[config] === 'undefined') {\r\n            throw new TypeError(`No method named \"${config}\"`);\r\n          }\r\n          data[config](this);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Data API implementation\r\n   */\r\n\r\n  enableDismissTrigger(Toast);\r\n\r\n  /**\r\n   * jQuery\r\n   */\r\n\r\n  defineJQueryPlugin(Toast);\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap index.umd.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n  const index_umd = {\r\n    Alert,\r\n    Button,\r\n    Carousel,\r\n    Collapse,\r\n    Dropdown,\r\n    Modal,\r\n    Offcanvas,\r\n    Popover,\r\n    ScrollSpy,\r\n    Tab,\r\n    Toast,\r\n    Tooltip\r\n  };\r\n\r\n  return index_umd;\r\n\r\n}));\r\n//# sourceMappingURL=bootstrap.bundle.js.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL2Rpc3QvanMvYm9vdHN0cmFwLmJ1bmRsZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEtBQTREO0FBQzlELEVBQUUsQ0FDd0c7QUFDMUcsQ0FBQyx1QkFBdUI7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUdBQXFHLGtDQUFrQztBQUN2STtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGVBQWU7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsSUFBSSxJQUFJLFdBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxTQUFTLDJCQUEyQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGtCQUFrQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQXNCO0FBQzVELEtBQUs7QUFDTDtBQUNBLHlDQUF5QyxzQkFBc0I7QUFDL0QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDJEQUEyRCxzQkFBc0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RCw4RUFBOEU7QUFDOUUsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG9DQUFvQyxZQUFZLFNBQVMsbUJBQW1CLFVBQVUsdUJBQXVCLGNBQWM7QUFDNUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUssRUFBRSxlQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDRCQUE0QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0pBQWdKLFNBQVM7QUFDeko7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLG9CQUFvQjtBQUMzRDtBQUNBLCtEQUErRCxLQUFLO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixLQUFLO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFdBQVc7QUFDckMsOEJBQThCLFlBQVk7QUFDMUMsZ0NBQWdDLFlBQVk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELE9BQU87QUFDekQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFdBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFlBQVksRUFBRSxlQUFlO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFlBQVk7QUFDcEQsc0NBQXNDLFlBQVk7QUFDbEQsb0NBQW9DLFlBQVk7QUFDaEQsMENBQTBDLFlBQVk7QUFDdEQsc0NBQXNDLFlBQVk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFlBQVk7QUFDMUMsNEJBQTRCLFlBQVk7QUFDeEMsb0NBQW9DLFlBQVk7QUFDaEQsMENBQTBDLFlBQVk7QUFDdEQsMENBQTBDLFlBQVk7QUFDdEQsdUNBQXVDLFlBQVk7QUFDbkQsdUNBQXVDLFlBQVksRUFBRSxlQUFlO0FBQ3BFLHlDQUF5QyxZQUFZLEVBQUUsZUFBZTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsTUFBTTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxPQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsV0FBVztBQUNyQztBQUNBLDhCQUE4QixZQUFZO0FBQzFDLGdDQUFnQyxZQUFZO0FBQzVDLDhCQUE4QixZQUFZO0FBQzFDLGtDQUFrQyxZQUFZO0FBQzlDLHlDQUF5QyxZQUFZLEVBQUUsZUFBZTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxxQkFBcUIsR0FBRyxvQkFBb0I7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MscUJBQXFCO0FBQ3ZEO0FBQ0EsMENBQTBDLDBCQUEwQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxpREFBaUQ7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsT0FBTztBQUMzRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRyxPQUFPO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUhBQXlIO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJLEdBQUc7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG9DQUFvQztBQUNqRTtBQUNBO0FBQ0EsMkJBQTJCLHFDQUFxQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsbURBQW1EO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxrREFBa0Q7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw0REFBNEQ7QUFDNUQsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEY7QUFDOUY7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RCxpQ0FBaUM7QUFDakMsOEJBQThCO0FBQzlCLE9BQU87QUFDUDtBQUNBLEtBQUssSUFBSSxHQUFHO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxvSEFBb0g7QUFDcEg7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQSwrQ0FBK0MsS0FBSztBQUNwRDtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFLFdBQVc7QUFDWDtBQUNBLDhCQUE4Qix1Q0FBdUM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEdBQUc7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEdBQUc7QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyx3QkFBd0IsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSw4QkFBOEIsWUFBWTtBQUMxQyxrQ0FBa0MsWUFBWTtBQUM5Qyw4QkFBOEIsWUFBWTtBQUMxQyxnQ0FBZ0MsWUFBWTtBQUM1Qyx5Q0FBeUMsWUFBWSxFQUFFLGVBQWU7QUFDdEUsMkNBQTJDLFlBQVksRUFBRSxlQUFlO0FBQ3hFLHVDQUF1QyxZQUFZLEVBQUUsZUFBZTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx1QkFBdUIsR0FBRyxrQkFBa0I7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscUJBQXFCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxPQUFPO0FBQ3pEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsV0FBVztBQUNyQyxvQ0FBb0MsWUFBWTtBQUNoRCwwQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELDZDQUE2QztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsV0FBVztBQUNyQztBQUNBO0FBQ0EsOEJBQThCLFlBQVk7QUFDMUMsaURBQWlELFlBQVk7QUFDN0Qsa0NBQWtDLFlBQVk7QUFDOUMsOEJBQThCLFlBQVk7QUFDMUMsZ0NBQWdDLFlBQVk7QUFDNUMsa0NBQWtDLFlBQVk7QUFDOUMsOENBQThDLFlBQVk7QUFDMUQsc0RBQXNELFlBQVk7QUFDbEUsb0RBQW9ELFlBQVk7QUFDaEUseUNBQXlDLFlBQVksRUFBRSxlQUFlO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxlQUFlO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxlQUFlO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxPQUFPO0FBQ3pEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFdBQVc7QUFDckM7QUFDQSx1Q0FBdUMsWUFBWSxFQUFFLGVBQWU7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFlBQVk7QUFDMUMsZ0NBQWdDLFlBQVk7QUFDNUMsOEJBQThCLFlBQVk7QUFDMUMsK0NBQStDLFlBQVk7QUFDM0Qsa0NBQWtDLFlBQVk7QUFDOUMsZ0NBQWdDLFlBQVk7QUFDNUMseUNBQXlDLFlBQVksRUFBRSxlQUFlO0FBQ3RFLGtEQUFrRCxZQUFZO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELE9BQU87QUFDekQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQkFBaUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0JBQXNCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EseUJBQXlCLHNCQUFzQjtBQUMvQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELE9BQU87QUFDekQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELE9BQU87QUFDekQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFdBQVc7QUFDckM7QUFDQSxvQ0FBb0MsWUFBWTtBQUNoRCw4QkFBOEIsWUFBWTtBQUMxQyx1Q0FBdUMsWUFBWSxFQUFFLGFBQWE7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxtQkFBbUIsSUFBSSxvQkFBb0IsSUFBSSxtQkFBbUIsSUFBSSxvQkFBb0I7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUscUJBQXFCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxjQUFjO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsZ0JBQWdCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsc0JBQXNCLEdBQUcsb0JBQW9CO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELE9BQU87QUFDekQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixXQUFXO0FBQ3JDLDhCQUE4QixZQUFZO0FBQzFDLGtDQUFrQyxZQUFZO0FBQzlDLDhCQUE4QixZQUFZO0FBQzFDLGdDQUFnQyxZQUFZO0FBQzVDLHVDQUF1QyxZQUFZO0FBQ25ELGtDQUFrQyxZQUFZO0FBQzlDLHFDQUFxQyxZQUFZO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx5QkFBeUI7QUFDeEU7QUFDQTtBQUNBLHFDQUFxQyw2QkFBNkIsb0JBQW9CLDZCQUE2QixnQkFBZ0IsNkJBQTZCO0FBQ2hLLDJHQUEyRztBQUMzRyxpQ0FBaUMsZUFBZSxJQUFJLHFCQUFxQjtBQUN6RSwwQ0FBMEMsa0JBQWtCLDJCQUEyQixrQkFBa0IsNEJBQTRCLGtCQUFrQjtBQUN2SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsbUJBQW1CLHlCQUF5QixvQkFBb0I7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsU0FBUztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELE9BQU87QUFDekQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakMsc0NBQXNDLFVBQVU7QUFDaEQsb0NBQW9DLFVBQVU7QUFDOUMsa0NBQWtDLFVBQVU7QUFDNUMsb0NBQW9DLFVBQVU7QUFDOUMsNEJBQTRCLFVBQVU7QUFDdEMsZ0NBQWdDLFVBQVU7QUFDMUMsNEJBQTRCLFVBQVU7QUFDdEMsOEJBQThCLFVBQVU7QUFDeEM7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsT0FBTztBQUMzRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL2Rpc3QvanMvYm9vdHN0cmFwLmJ1bmRsZS5qcz8zZjMwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxyXG4gICogQm9vdHN0cmFwIHY1LjMuMyAoaHR0cHM6Ly9nZXRib290c3RyYXAuY29tLylcclxuICAqIENvcHlyaWdodCAyMDExLTIwMjQgVGhlIEJvb3RzdHJhcCBBdXRob3JzIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvZ3JhcGhzL2NvbnRyaWJ1dG9ycylcclxuICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxyXG4gICovXHJcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxyXG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XHJcbiAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLmJvb3RzdHJhcCA9IGZhY3RvcnkoKSk7XHJcbn0pKHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgLyoqXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKiBCb290c3RyYXAgZG9tL2RhdGEuanNcclxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBDb25zdGFudHNcclxuICAgKi9cclxuXHJcbiAgY29uc3QgZWxlbWVudE1hcCA9IG5ldyBNYXAoKTtcclxuICBjb25zdCBEYXRhID0ge1xyXG4gICAgc2V0KGVsZW1lbnQsIGtleSwgaW5zdGFuY2UpIHtcclxuICAgICAgaWYgKCFlbGVtZW50TWFwLmhhcyhlbGVtZW50KSkge1xyXG4gICAgICAgIGVsZW1lbnRNYXAuc2V0KGVsZW1lbnQsIG5ldyBNYXAoKSk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgaW5zdGFuY2VNYXAgPSBlbGVtZW50TWFwLmdldChlbGVtZW50KTtcclxuXHJcbiAgICAgIC8vIG1ha2UgaXQgY2xlYXIgd2Ugb25seSB3YW50IG9uZSBpbnN0YW5jZSBwZXIgZWxlbWVudFxyXG4gICAgICAvLyBjYW4gYmUgcmVtb3ZlZCBsYXRlciB3aGVuIG11bHRpcGxlIGtleS9pbnN0YW5jZXMgYXJlIGZpbmUgdG8gYmUgdXNlZFxyXG4gICAgICBpZiAoIWluc3RhbmNlTWFwLmhhcyhrZXkpICYmIGluc3RhbmNlTWFwLnNpemUgIT09IDApIHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEJvb3RzdHJhcCBkb2Vzbid0IGFsbG93IG1vcmUgdGhhbiBvbmUgaW5zdGFuY2UgcGVyIGVsZW1lbnQuIEJvdW5kIGluc3RhbmNlOiAke0FycmF5LmZyb20oaW5zdGFuY2VNYXAua2V5cygpKVswXX0uYCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGluc3RhbmNlTWFwLnNldChrZXksIGluc3RhbmNlKTtcclxuICAgIH0sXHJcbiAgICBnZXQoZWxlbWVudCwga2V5KSB7XHJcbiAgICAgIGlmIChlbGVtZW50TWFwLmhhcyhlbGVtZW50KSkge1xyXG4gICAgICAgIHJldHVybiBlbGVtZW50TWFwLmdldChlbGVtZW50KS5nZXQoa2V5KSB8fCBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSxcclxuICAgIHJlbW92ZShlbGVtZW50LCBrZXkpIHtcclxuICAgICAgaWYgKCFlbGVtZW50TWFwLmhhcyhlbGVtZW50KSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBpbnN0YW5jZU1hcCA9IGVsZW1lbnRNYXAuZ2V0KGVsZW1lbnQpO1xyXG4gICAgICBpbnN0YW5jZU1hcC5kZWxldGUoa2V5KTtcclxuXHJcbiAgICAgIC8vIGZyZWUgdXAgZWxlbWVudCByZWZlcmVuY2VzIGlmIHRoZXJlIGFyZSBubyBpbnN0YW5jZXMgbGVmdCBmb3IgYW4gZWxlbWVudFxyXG4gICAgICBpZiAoaW5zdGFuY2VNYXAuc2l6ZSA9PT0gMCkge1xyXG4gICAgICAgIGVsZW1lbnRNYXAuZGVsZXRlKGVsZW1lbnQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKiBCb290c3RyYXAgdXRpbC9pbmRleC5qc1xyXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICovXHJcblxyXG4gIGNvbnN0IE1BWF9VSUQgPSAxMDAwMDAwO1xyXG4gIGNvbnN0IE1JTExJU0VDT05EU19NVUxUSVBMSUVSID0gMTAwMDtcclxuICBjb25zdCBUUkFOU0lUSU9OX0VORCA9ICd0cmFuc2l0aW9uZW5kJztcclxuXHJcbiAgLyoqXHJcbiAgICogUHJvcGVybHkgZXNjYXBlIElEcyBzZWxlY3RvcnMgdG8gaGFuZGxlIHdlaXJkIElEc1xyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICovXHJcbiAgY29uc3QgcGFyc2VTZWxlY3RvciA9IHNlbGVjdG9yID0+IHtcclxuICAgIGlmIChzZWxlY3RvciAmJiB3aW5kb3cuQ1NTICYmIHdpbmRvdy5DU1MuZXNjYXBlKSB7XHJcbiAgICAgIC8vIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IgbmVlZHMgZXNjYXBpbmcgdG8gaGFuZGxlIElEcyAoaHRtbDUrKSBjb250YWluaW5nIGZvciBpbnN0YW5jZSAvXHJcbiAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZSgvIyhbXlxcc1wiIyddKykvZywgKG1hdGNoLCBpZCkgPT4gYCMke0NTUy5lc2NhcGUoaWQpfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNlbGVjdG9yO1xyXG4gIH07XHJcblxyXG4gIC8vIFNob3V0LW91dCBBbmd1cyBDcm9sbCAoaHR0cHM6Ly9nb28uZ2wvcHh3UUdwKVxyXG4gIGNvbnN0IHRvVHlwZSA9IG9iamVjdCA9PiB7XHJcbiAgICBpZiAob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJldHVybiBgJHtvYmplY3R9YDtcclxuICAgIH1cclxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KS5tYXRjaCgvXFxzKFthLXpdKykvaSlbMV0udG9Mb3dlckNhc2UoKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBQdWJsaWMgVXRpbCBBUElcclxuICAgKi9cclxuXHJcbiAgY29uc3QgZ2V0VUlEID0gcHJlZml4ID0+IHtcclxuICAgIGRvIHtcclxuICAgICAgcHJlZml4ICs9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIE1BWF9VSUQpO1xyXG4gICAgfSB3aGlsZSAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocHJlZml4KSk7XHJcbiAgICByZXR1cm4gcHJlZml4O1xyXG4gIH07XHJcbiAgY29uc3QgZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQgPSBlbGVtZW50ID0+IHtcclxuICAgIGlmICghZWxlbWVudCkge1xyXG4gICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBHZXQgdHJhbnNpdGlvbi1kdXJhdGlvbiBvZiB0aGUgZWxlbWVudFxyXG4gICAgbGV0IHtcclxuICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uLFxyXG4gICAgICB0cmFuc2l0aW9uRGVsYXlcclxuICAgIH0gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcclxuICAgIGNvbnN0IGZsb2F0VHJhbnNpdGlvbkR1cmF0aW9uID0gTnVtYmVyLnBhcnNlRmxvYXQodHJhbnNpdGlvbkR1cmF0aW9uKTtcclxuICAgIGNvbnN0IGZsb2F0VHJhbnNpdGlvbkRlbGF5ID0gTnVtYmVyLnBhcnNlRmxvYXQodHJhbnNpdGlvbkRlbGF5KTtcclxuXHJcbiAgICAvLyBSZXR1cm4gMCBpZiBlbGVtZW50IG9yIHRyYW5zaXRpb24gZHVyYXRpb24gaXMgbm90IGZvdW5kXHJcbiAgICBpZiAoIWZsb2F0VHJhbnNpdGlvbkR1cmF0aW9uICYmICFmbG9hdFRyYW5zaXRpb25EZWxheSkge1xyXG4gICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiBtdWx0aXBsZSBkdXJhdGlvbnMgYXJlIGRlZmluZWQsIHRha2UgdGhlIGZpcnN0XHJcbiAgICB0cmFuc2l0aW9uRHVyYXRpb24gPSB0cmFuc2l0aW9uRHVyYXRpb24uc3BsaXQoJywnKVswXTtcclxuICAgIHRyYW5zaXRpb25EZWxheSA9IHRyYW5zaXRpb25EZWxheS5zcGxpdCgnLCcpWzBdO1xyXG4gICAgcmV0dXJuIChOdW1iZXIucGFyc2VGbG9hdCh0cmFuc2l0aW9uRHVyYXRpb24pICsgTnVtYmVyLnBhcnNlRmxvYXQodHJhbnNpdGlvbkRlbGF5KSkgKiBNSUxMSVNFQ09ORFNfTVVMVElQTElFUjtcclxuICB9O1xyXG4gIGNvbnN0IHRyaWdnZXJUcmFuc2l0aW9uRW5kID0gZWxlbWVudCA9PiB7XHJcbiAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFRSQU5TSVRJT05fRU5EKSk7XHJcbiAgfTtcclxuICBjb25zdCBpc0VsZW1lbnQkMSA9IG9iamVjdCA9PiB7XHJcbiAgICBpZiAoIW9iamVjdCB8fCB0eXBlb2Ygb2JqZWN0ICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIG9iamVjdC5qcXVlcnkgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIG9iamVjdCA9IG9iamVjdFswXTtcclxuICAgIH1cclxuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0Lm5vZGVUeXBlICE9PSAndW5kZWZpbmVkJztcclxuICB9O1xyXG4gIGNvbnN0IGdldEVsZW1lbnQgPSBvYmplY3QgPT4ge1xyXG4gICAgLy8gaXQncyBhIGpRdWVyeSBvYmplY3Qgb3IgYSBub2RlIGVsZW1lbnRcclxuICAgIGlmIChpc0VsZW1lbnQkMShvYmplY3QpKSB7XHJcbiAgICAgIHJldHVybiBvYmplY3QuanF1ZXJ5ID8gb2JqZWN0WzBdIDogb2JqZWN0O1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdzdHJpbmcnICYmIG9iamVjdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHBhcnNlU2VsZWN0b3Iob2JqZWN0KSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9O1xyXG4gIGNvbnN0IGlzVmlzaWJsZSA9IGVsZW1lbnQgPT4ge1xyXG4gICAgaWYgKCFpc0VsZW1lbnQkMShlbGVtZW50KSB8fCBlbGVtZW50LmdldENsaWVudFJlY3RzKCkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGNvbnN0IGVsZW1lbnRJc1Zpc2libGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoJ3Zpc2liaWxpdHknKSA9PT0gJ3Zpc2libGUnO1xyXG4gICAgLy8gSGFuZGxlIGBkZXRhaWxzYCBlbGVtZW50IGFzIGl0cyBjb250ZW50IG1heSBmYWxzaWUgYXBwZWFyIHZpc2libGUgd2hlbiBpdCBpcyBjbG9zZWRcclxuICAgIGNvbnN0IGNsb3NlZERldGFpbHMgPSBlbGVtZW50LmNsb3Nlc3QoJ2RldGFpbHM6bm90KFtvcGVuXSknKTtcclxuICAgIGlmICghY2xvc2VkRGV0YWlscykge1xyXG4gICAgICByZXR1cm4gZWxlbWVudElzVmlzaWJsZTtcclxuICAgIH1cclxuICAgIGlmIChjbG9zZWREZXRhaWxzICE9PSBlbGVtZW50KSB7XHJcbiAgICAgIGNvbnN0IHN1bW1hcnkgPSBlbGVtZW50LmNsb3Nlc3QoJ3N1bW1hcnknKTtcclxuICAgICAgaWYgKHN1bW1hcnkgJiYgc3VtbWFyeS5wYXJlbnROb2RlICE9PSBjbG9zZWREZXRhaWxzKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzdW1tYXJ5ID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZWxlbWVudElzVmlzaWJsZTtcclxuICB9O1xyXG4gIGNvbnN0IGlzRGlzYWJsZWQgPSBlbGVtZW50ID0+IHtcclxuICAgIGlmICghZWxlbWVudCB8fCBlbGVtZW50Lm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnZGlzYWJsZWQnKSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgZWxlbWVudC5kaXNhYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgcmV0dXJuIGVsZW1lbnQuZGlzYWJsZWQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgJiYgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgIT09ICdmYWxzZSc7XHJcbiAgfTtcclxuICBjb25zdCBmaW5kU2hhZG93Um9vdCA9IGVsZW1lbnQgPT4ge1xyXG4gICAgaWYgKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXR0YWNoU2hhZG93KSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENhbiBmaW5kIHRoZSBzaGFkb3cgcm9vdCBvdGhlcndpc2UgaXQnbGwgcmV0dXJuIHRoZSBkb2N1bWVudFxyXG4gICAgaWYgKHR5cGVvZiBlbGVtZW50LmdldFJvb3ROb2RlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIGNvbnN0IHJvb3QgPSBlbGVtZW50LmdldFJvb3ROb2RlKCk7XHJcbiAgICAgIHJldHVybiByb290IGluc3RhbmNlb2YgU2hhZG93Um9vdCA/IHJvb3QgOiBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XHJcbiAgICAgIHJldHVybiBlbGVtZW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHdoZW4gd2UgZG9uJ3QgZmluZCBhIHNoYWRvdyByb290XHJcbiAgICBpZiAoIWVsZW1lbnQucGFyZW50Tm9kZSkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiBmaW5kU2hhZG93Um9vdChlbGVtZW50LnBhcmVudE5vZGUpO1xyXG4gIH07XHJcbiAgY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xyXG5cclxuICAvKipcclxuICAgKiBUcmljayB0byByZXN0YXJ0IGFuIGVsZW1lbnQncyBhbmltYXRpb25cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcclxuICAgKiBAcmV0dXJuIHZvaWRcclxuICAgKlxyXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cuY2hhcmlzdGhlby5pby9ibG9nLzIwMjEvMDIvcmVzdGFydC1hLWNzcy1hbmltYXRpb24td2l0aC1qYXZhc2NyaXB0LyNyZXN0YXJ0aW5nLWEtY3NzLWFuaW1hdGlvblxyXG4gICAqL1xyXG4gIGNvbnN0IHJlZmxvdyA9IGVsZW1lbnQgPT4ge1xyXG4gICAgZWxlbWVudC5vZmZzZXRIZWlnaHQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXHJcbiAgfTtcclxuICBjb25zdCBnZXRqUXVlcnkgPSAoKSA9PiB7XHJcbiAgICBpZiAod2luZG93LmpRdWVyeSAmJiAhZG9jdW1lbnQuYm9keS5oYXNBdHRyaWJ1dGUoJ2RhdGEtYnMtbm8tanF1ZXJ5JykpIHtcclxuICAgICAgcmV0dXJuIHdpbmRvdy5qUXVlcnk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9O1xyXG4gIGNvbnN0IERPTUNvbnRlbnRMb2FkZWRDYWxsYmFja3MgPSBbXTtcclxuICBjb25zdCBvbkRPTUNvbnRlbnRMb2FkZWQgPSBjYWxsYmFjayA9PiB7XHJcbiAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XHJcbiAgICAgIC8vIGFkZCBsaXN0ZW5lciBvbiB0aGUgZmlyc3QgY2FsbCB3aGVuIHRoZSBkb2N1bWVudCBpcyBpbiBsb2FkaW5nIHN0YXRlXHJcbiAgICAgIGlmICghRE9NQ29udGVudExvYWRlZENhbGxiYWNrcy5sZW5ndGgpIHtcclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xyXG4gICAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBET01Db250ZW50TG9hZGVkQ2FsbGJhY2tzKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgRE9NQ29udGVudExvYWRlZENhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICB9XHJcbiAgfTtcclxuICBjb25zdCBpc1JUTCA9ICgpID0+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kaXIgPT09ICdydGwnO1xyXG4gIGNvbnN0IGRlZmluZUpRdWVyeVBsdWdpbiA9IHBsdWdpbiA9PiB7XHJcbiAgICBvbkRPTUNvbnRlbnRMb2FkZWQoKCkgPT4ge1xyXG4gICAgICBjb25zdCAkID0gZ2V0alF1ZXJ5KCk7XHJcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICBpZiAoJCkge1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSBwbHVnaW4uTkFNRTtcclxuICAgICAgICBjb25zdCBKUVVFUllfTk9fQ09ORkxJQ1QgPSAkLmZuW25hbWVdO1xyXG4gICAgICAgICQuZm5bbmFtZV0gPSBwbHVnaW4ualF1ZXJ5SW50ZXJmYWNlO1xyXG4gICAgICAgICQuZm5bbmFtZV0uQ29uc3RydWN0b3IgPSBwbHVnaW47XHJcbiAgICAgICAgJC5mbltuYW1lXS5ub0NvbmZsaWN0ID0gKCkgPT4ge1xyXG4gICAgICAgICAgJC5mbltuYW1lXSA9IEpRVUVSWV9OT19DT05GTElDVDtcclxuICAgICAgICAgIHJldHVybiBwbHVnaW4ualF1ZXJ5SW50ZXJmYWNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH07XHJcbiAgY29uc3QgZXhlY3V0ZSA9IChwb3NzaWJsZUNhbGxiYWNrLCBhcmdzID0gW10sIGRlZmF1bHRWYWx1ZSA9IHBvc3NpYmxlQ2FsbGJhY2spID0+IHtcclxuICAgIHJldHVybiB0eXBlb2YgcG9zc2libGVDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IHBvc3NpYmxlQ2FsbGJhY2soLi4uYXJncykgOiBkZWZhdWx0VmFsdWU7XHJcbiAgfTtcclxuICBjb25zdCBleGVjdXRlQWZ0ZXJUcmFuc2l0aW9uID0gKGNhbGxiYWNrLCB0cmFuc2l0aW9uRWxlbWVudCwgd2FpdEZvclRyYW5zaXRpb24gPSB0cnVlKSA9PiB7XHJcbiAgICBpZiAoIXdhaXRGb3JUcmFuc2l0aW9uKSB7XHJcbiAgICAgIGV4ZWN1dGUoY2FsbGJhY2spO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBkdXJhdGlvblBhZGRpbmcgPSA1O1xyXG4gICAgY29uc3QgZW11bGF0ZWREdXJhdGlvbiA9IGdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRyYW5zaXRpb25FbGVtZW50KSArIGR1cmF0aW9uUGFkZGluZztcclxuICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcclxuICAgIGNvbnN0IGhhbmRsZXIgPSAoe1xyXG4gICAgICB0YXJnZXRcclxuICAgIH0pID0+IHtcclxuICAgICAgaWYgKHRhcmdldCAhPT0gdHJhbnNpdGlvbkVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY2FsbGVkID0gdHJ1ZTtcclxuICAgICAgdHJhbnNpdGlvbkVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihUUkFOU0lUSU9OX0VORCwgaGFuZGxlcik7XHJcbiAgICAgIGV4ZWN1dGUoY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIHRyYW5zaXRpb25FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoVFJBTlNJVElPTl9FTkQsIGhhbmRsZXIpO1xyXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIGlmICghY2FsbGVkKSB7XHJcbiAgICAgICAgdHJpZ2dlclRyYW5zaXRpb25FbmQodHJhbnNpdGlvbkVsZW1lbnQpO1xyXG4gICAgICB9XHJcbiAgICB9LCBlbXVsYXRlZER1cmF0aW9uKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gdGhlIHByZXZpb3VzL25leHQgZWxlbWVudCBvZiBhIGxpc3QuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2FycmF5fSBsaXN0ICAgIFRoZSBsaXN0IG9mIGVsZW1lbnRzXHJcbiAgICogQHBhcmFtIGFjdGl2ZUVsZW1lbnQgICBUaGUgYWN0aXZlIGVsZW1lbnRcclxuICAgKiBAcGFyYW0gc2hvdWxkR2V0TmV4dCAgIENob29zZSB0byBnZXQgbmV4dCBvciBwcmV2aW91cyBlbGVtZW50XHJcbiAgICogQHBhcmFtIGlzQ3ljbGVBbGxvd2VkXHJcbiAgICogQHJldHVybiB7RWxlbWVudHxlbGVtfSBUaGUgcHJvcGVyIGVsZW1lbnRcclxuICAgKi9cclxuICBjb25zdCBnZXROZXh0QWN0aXZlRWxlbWVudCA9IChsaXN0LCBhY3RpdmVFbGVtZW50LCBzaG91bGRHZXROZXh0LCBpc0N5Y2xlQWxsb3dlZCkgPT4ge1xyXG4gICAgY29uc3QgbGlzdExlbmd0aCA9IGxpc3QubGVuZ3RoO1xyXG4gICAgbGV0IGluZGV4ID0gbGlzdC5pbmRleE9mKGFjdGl2ZUVsZW1lbnQpO1xyXG5cclxuICAgIC8vIGlmIHRoZSBlbGVtZW50IGRvZXMgbm90IGV4aXN0IGluIHRoZSBsaXN0IHJldHVybiBhbiBlbGVtZW50XHJcbiAgICAvLyBkZXBlbmRpbmcgb24gdGhlIGRpcmVjdGlvbiBhbmQgaWYgY3ljbGUgaXMgYWxsb3dlZFxyXG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICByZXR1cm4gIXNob3VsZEdldE5leHQgJiYgaXNDeWNsZUFsbG93ZWQgPyBsaXN0W2xpc3RMZW5ndGggLSAxXSA6IGxpc3RbMF07XHJcbiAgICB9XHJcbiAgICBpbmRleCArPSBzaG91bGRHZXROZXh0ID8gMSA6IC0xO1xyXG4gICAgaWYgKGlzQ3ljbGVBbGxvd2VkKSB7XHJcbiAgICAgIGluZGV4ID0gKGluZGV4ICsgbGlzdExlbmd0aCkgJSBsaXN0TGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxpc3RbTWF0aC5tYXgoMCwgTWF0aC5taW4oaW5kZXgsIGxpc3RMZW5ndGggLSAxKSldO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICogQm9vdHN0cmFwIGRvbS9ldmVudC1oYW5kbGVyLmpzXHJcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKi9cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0YW50c1xyXG4gICAqL1xyXG5cclxuICBjb25zdCBuYW1lc3BhY2VSZWdleCA9IC9bXi5dKig/PVxcLi4qKVxcLnwuKi87XHJcbiAgY29uc3Qgc3RyaXBOYW1lUmVnZXggPSAvXFwuLiovO1xyXG4gIGNvbnN0IHN0cmlwVWlkUmVnZXggPSAvOjpcXGQrJC87XHJcbiAgY29uc3QgZXZlbnRSZWdpc3RyeSA9IHt9OyAvLyBFdmVudHMgc3RvcmFnZVxyXG4gIGxldCB1aWRFdmVudCA9IDE7XHJcbiAgY29uc3QgY3VzdG9tRXZlbnRzID0ge1xyXG4gICAgbW91c2VlbnRlcjogJ21vdXNlb3ZlcicsXHJcbiAgICBtb3VzZWxlYXZlOiAnbW91c2VvdXQnXHJcbiAgfTtcclxuICBjb25zdCBuYXRpdmVFdmVudHMgPSBuZXcgU2V0KFsnY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2V1cCcsICdtb3VzZWRvd24nLCAnY29udGV4dG1lbnUnLCAnbW91c2V3aGVlbCcsICdET01Nb3VzZVNjcm9sbCcsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnLCAnbW91c2Vtb3ZlJywgJ3NlbGVjdHN0YXJ0JywgJ3NlbGVjdGVuZCcsICdrZXlkb3duJywgJ2tleXByZXNzJywgJ2tleXVwJywgJ29yaWVudGF0aW9uY2hhbmdlJywgJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJywgJ3RvdWNoZW5kJywgJ3RvdWNoY2FuY2VsJywgJ3BvaW50ZXJkb3duJywgJ3BvaW50ZXJtb3ZlJywgJ3BvaW50ZXJ1cCcsICdwb2ludGVybGVhdmUnLCAncG9pbnRlcmNhbmNlbCcsICdnZXN0dXJlc3RhcnQnLCAnZ2VzdHVyZWNoYW5nZScsICdnZXN0dXJlZW5kJywgJ2ZvY3VzJywgJ2JsdXInLCAnY2hhbmdlJywgJ3Jlc2V0JywgJ3NlbGVjdCcsICdzdWJtaXQnLCAnZm9jdXNpbicsICdmb2N1c291dCcsICdsb2FkJywgJ3VubG9hZCcsICdiZWZvcmV1bmxvYWQnLCAncmVzaXplJywgJ21vdmUnLCAnRE9NQ29udGVudExvYWRlZCcsICdyZWFkeXN0YXRlY2hhbmdlJywgJ2Vycm9yJywgJ2Fib3J0JywgJ3Njcm9sbCddKTtcclxuXHJcbiAgLyoqXHJcbiAgICogUHJpdmF0ZSBtZXRob2RzXHJcbiAgICovXHJcblxyXG4gIGZ1bmN0aW9uIG1ha2VFdmVudFVpZChlbGVtZW50LCB1aWQpIHtcclxuICAgIHJldHVybiB1aWQgJiYgYCR7dWlkfTo6JHt1aWRFdmVudCsrfWAgfHwgZWxlbWVudC51aWRFdmVudCB8fCB1aWRFdmVudCsrO1xyXG4gIH1cclxuICBmdW5jdGlvbiBnZXRFbGVtZW50RXZlbnRzKGVsZW1lbnQpIHtcclxuICAgIGNvbnN0IHVpZCA9IG1ha2VFdmVudFVpZChlbGVtZW50KTtcclxuICAgIGVsZW1lbnQudWlkRXZlbnQgPSB1aWQ7XHJcbiAgICBldmVudFJlZ2lzdHJ5W3VpZF0gPSBldmVudFJlZ2lzdHJ5W3VpZF0gfHwge307XHJcbiAgICByZXR1cm4gZXZlbnRSZWdpc3RyeVt1aWRdO1xyXG4gIH1cclxuICBmdW5jdGlvbiBib290c3RyYXBIYW5kbGVyKGVsZW1lbnQsIGZuKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlcihldmVudCkge1xyXG4gICAgICBoeWRyYXRlT2JqKGV2ZW50LCB7XHJcbiAgICAgICAgZGVsZWdhdGVUYXJnZXQ6IGVsZW1lbnRcclxuICAgICAgfSk7XHJcbiAgICAgIGlmIChoYW5kbGVyLm9uZU9mZikge1xyXG4gICAgICAgIEV2ZW50SGFuZGxlci5vZmYoZWxlbWVudCwgZXZlbnQudHlwZSwgZm4pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmbi5hcHBseShlbGVtZW50LCBbZXZlbnRdKTtcclxuICAgIH07XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGJvb3RzdHJhcERlbGVnYXRpb25IYW5kbGVyKGVsZW1lbnQsIHNlbGVjdG9yLCBmbikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGhhbmRsZXIoZXZlbnQpIHtcclxuICAgICAgY29uc3QgZG9tRWxlbWVudHMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xyXG4gICAgICBmb3IgKGxldCB7XHJcbiAgICAgICAgdGFyZ2V0XHJcbiAgICAgIH0gPSBldmVudDsgdGFyZ2V0ICYmIHRhcmdldCAhPT0gdGhpczsgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGUpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGRvbUVsZW1lbnQgb2YgZG9tRWxlbWVudHMpIHtcclxuICAgICAgICAgIGlmIChkb21FbGVtZW50ICE9PSB0YXJnZXQpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBoeWRyYXRlT2JqKGV2ZW50LCB7XHJcbiAgICAgICAgICAgIGRlbGVnYXRlVGFyZ2V0OiB0YXJnZXRcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgaWYgKGhhbmRsZXIub25lT2ZmKSB7XHJcbiAgICAgICAgICAgIEV2ZW50SGFuZGxlci5vZmYoZWxlbWVudCwgZXZlbnQudHlwZSwgc2VsZWN0b3IsIGZuKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0YXJnZXQsIFtldmVudF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcbiAgZnVuY3Rpb24gZmluZEhhbmRsZXIoZXZlbnRzLCBjYWxsYWJsZSwgZGVsZWdhdGlvblNlbGVjdG9yID0gbnVsbCkge1xyXG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoZXZlbnRzKS5maW5kKGV2ZW50ID0+IGV2ZW50LmNhbGxhYmxlID09PSBjYWxsYWJsZSAmJiBldmVudC5kZWxlZ2F0aW9uU2VsZWN0b3IgPT09IGRlbGVnYXRpb25TZWxlY3Rvcik7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVBhcmFtZXRlcnMob3JpZ2luYWxUeXBlRXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25GdW5jdGlvbikge1xyXG4gICAgY29uc3QgaXNEZWxlZ2F0ZWQgPSB0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZyc7XHJcbiAgICAvLyBUT0RPOiB0b29sdGlwIHBhc3NlcyBgZmFsc2VgIGluc3RlYWQgb2Ygc2VsZWN0b3IsIHNvIHdlIG5lZWQgdG8gY2hlY2tcclxuICAgIGNvbnN0IGNhbGxhYmxlID0gaXNEZWxlZ2F0ZWQgPyBkZWxlZ2F0aW9uRnVuY3Rpb24gOiBoYW5kbGVyIHx8IGRlbGVnYXRpb25GdW5jdGlvbjtcclxuICAgIGxldCB0eXBlRXZlbnQgPSBnZXRUeXBlRXZlbnQob3JpZ2luYWxUeXBlRXZlbnQpO1xyXG4gICAgaWYgKCFuYXRpdmVFdmVudHMuaGFzKHR5cGVFdmVudCkpIHtcclxuICAgICAgdHlwZUV2ZW50ID0gb3JpZ2luYWxUeXBlRXZlbnQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW2lzRGVsZWdhdGVkLCBjYWxsYWJsZSwgdHlwZUV2ZW50XTtcclxuICB9XHJcbiAgZnVuY3Rpb24gYWRkSGFuZGxlcihlbGVtZW50LCBvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uLCBvbmVPZmYpIHtcclxuICAgIGlmICh0eXBlb2Ygb3JpZ2luYWxUeXBlRXZlbnQgIT09ICdzdHJpbmcnIHx8ICFlbGVtZW50KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGxldCBbaXNEZWxlZ2F0ZWQsIGNhbGxhYmxlLCB0eXBlRXZlbnRdID0gbm9ybWFsaXplUGFyYW1ldGVycyhvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uKTtcclxuXHJcbiAgICAvLyBpbiBjYXNlIG9mIG1vdXNlZW50ZXIgb3IgbW91c2VsZWF2ZSB3cmFwIHRoZSBoYW5kbGVyIHdpdGhpbiBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGZvciBpdHMgRE9NIHBvc2l0aW9uXHJcbiAgICAvLyB0aGlzIHByZXZlbnRzIHRoZSBoYW5kbGVyIGZyb20gYmVpbmcgZGlzcGF0Y2hlZCB0aGUgc2FtZSB3YXkgYXMgbW91c2VvdmVyIG9yIG1vdXNlb3V0IGRvZXNcclxuICAgIGlmIChvcmlnaW5hbFR5cGVFdmVudCBpbiBjdXN0b21FdmVudHMpIHtcclxuICAgICAgY29uc3Qgd3JhcEZ1bmN0aW9uID0gZm4gPT4ge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgIGlmICghZXZlbnQucmVsYXRlZFRhcmdldCB8fCBldmVudC5yZWxhdGVkVGFyZ2V0ICE9PSBldmVudC5kZWxlZ2F0ZVRhcmdldCAmJiAhZXZlbnQuZGVsZWdhdGVUYXJnZXQuY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgZXZlbnQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgIH07XHJcbiAgICAgIGNhbGxhYmxlID0gd3JhcEZ1bmN0aW9uKGNhbGxhYmxlKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGV2ZW50cyA9IGdldEVsZW1lbnRFdmVudHMoZWxlbWVudCk7XHJcbiAgICBjb25zdCBoYW5kbGVycyA9IGV2ZW50c1t0eXBlRXZlbnRdIHx8IChldmVudHNbdHlwZUV2ZW50XSA9IHt9KTtcclxuICAgIGNvbnN0IHByZXZpb3VzRnVuY3Rpb24gPSBmaW5kSGFuZGxlcihoYW5kbGVycywgY2FsbGFibGUsIGlzRGVsZWdhdGVkID8gaGFuZGxlciA6IG51bGwpO1xyXG4gICAgaWYgKHByZXZpb3VzRnVuY3Rpb24pIHtcclxuICAgICAgcHJldmlvdXNGdW5jdGlvbi5vbmVPZmYgPSBwcmV2aW91c0Z1bmN0aW9uLm9uZU9mZiAmJiBvbmVPZmY7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHVpZCA9IG1ha2VFdmVudFVpZChjYWxsYWJsZSwgb3JpZ2luYWxUeXBlRXZlbnQucmVwbGFjZShuYW1lc3BhY2VSZWdleCwgJycpKTtcclxuICAgIGNvbnN0IGZuID0gaXNEZWxlZ2F0ZWQgPyBib290c3RyYXBEZWxlZ2F0aW9uSGFuZGxlcihlbGVtZW50LCBoYW5kbGVyLCBjYWxsYWJsZSkgOiBib290c3RyYXBIYW5kbGVyKGVsZW1lbnQsIGNhbGxhYmxlKTtcclxuICAgIGZuLmRlbGVnYXRpb25TZWxlY3RvciA9IGlzRGVsZWdhdGVkID8gaGFuZGxlciA6IG51bGw7XHJcbiAgICBmbi5jYWxsYWJsZSA9IGNhbGxhYmxlO1xyXG4gICAgZm4ub25lT2ZmID0gb25lT2ZmO1xyXG4gICAgZm4udWlkRXZlbnQgPSB1aWQ7XHJcbiAgICBoYW5kbGVyc1t1aWRdID0gZm47XHJcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZUV2ZW50LCBmbiwgaXNEZWxlZ2F0ZWQpO1xyXG4gIH1cclxuICBmdW5jdGlvbiByZW1vdmVIYW5kbGVyKGVsZW1lbnQsIGV2ZW50cywgdHlwZUV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uU2VsZWN0b3IpIHtcclxuICAgIGNvbnN0IGZuID0gZmluZEhhbmRsZXIoZXZlbnRzW3R5cGVFdmVudF0sIGhhbmRsZXIsIGRlbGVnYXRpb25TZWxlY3Rvcik7XHJcbiAgICBpZiAoIWZuKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlRXZlbnQsIGZuLCBCb29sZWFuKGRlbGVnYXRpb25TZWxlY3RvcikpO1xyXG4gICAgZGVsZXRlIGV2ZW50c1t0eXBlRXZlbnRdW2ZuLnVpZEV2ZW50XTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcmVtb3ZlTmFtZXNwYWNlZEhhbmRsZXJzKGVsZW1lbnQsIGV2ZW50cywgdHlwZUV2ZW50LCBuYW1lc3BhY2UpIHtcclxuICAgIGNvbnN0IHN0b3JlRWxlbWVudEV2ZW50ID0gZXZlbnRzW3R5cGVFdmVudF0gfHwge307XHJcbiAgICBmb3IgKGNvbnN0IFtoYW5kbGVyS2V5LCBldmVudF0gb2YgT2JqZWN0LmVudHJpZXMoc3RvcmVFbGVtZW50RXZlbnQpKSB7XHJcbiAgICAgIGlmIChoYW5kbGVyS2V5LmluY2x1ZGVzKG5hbWVzcGFjZSkpIHtcclxuICAgICAgICByZW1vdmVIYW5kbGVyKGVsZW1lbnQsIGV2ZW50cywgdHlwZUV2ZW50LCBldmVudC5jYWxsYWJsZSwgZXZlbnQuZGVsZWdhdGlvblNlbGVjdG9yKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBnZXRUeXBlRXZlbnQoZXZlbnQpIHtcclxuICAgIC8vIGFsbG93IHRvIGdldCB0aGUgbmF0aXZlIGV2ZW50cyBmcm9tIG5hbWVzcGFjZWQgZXZlbnRzICgnY2xpY2suYnMuYnV0dG9uJyAtLT4gJ2NsaWNrJylcclxuICAgIGV2ZW50ID0gZXZlbnQucmVwbGFjZShzdHJpcE5hbWVSZWdleCwgJycpO1xyXG4gICAgcmV0dXJuIGN1c3RvbUV2ZW50c1tldmVudF0gfHwgZXZlbnQ7XHJcbiAgfVxyXG4gIGNvbnN0IEV2ZW50SGFuZGxlciA9IHtcclxuICAgIG9uKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRnVuY3Rpb24pIHtcclxuICAgICAgYWRkSGFuZGxlcihlbGVtZW50LCBldmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uLCBmYWxzZSk7XHJcbiAgICB9LFxyXG4gICAgb25lKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRnVuY3Rpb24pIHtcclxuICAgICAgYWRkSGFuZGxlcihlbGVtZW50LCBldmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uLCB0cnVlKTtcclxuICAgIH0sXHJcbiAgICBvZmYoZWxlbWVudCwgb3JpZ2luYWxUeXBlRXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25GdW5jdGlvbikge1xyXG4gICAgICBpZiAodHlwZW9mIG9yaWdpbmFsVHlwZUV2ZW50ICE9PSAnc3RyaW5nJyB8fCAhZWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBbaXNEZWxlZ2F0ZWQsIGNhbGxhYmxlLCB0eXBlRXZlbnRdID0gbm9ybWFsaXplUGFyYW1ldGVycyhvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uKTtcclxuICAgICAgY29uc3QgaW5OYW1lc3BhY2UgPSB0eXBlRXZlbnQgIT09IG9yaWdpbmFsVHlwZUV2ZW50O1xyXG4gICAgICBjb25zdCBldmVudHMgPSBnZXRFbGVtZW50RXZlbnRzKGVsZW1lbnQpO1xyXG4gICAgICBjb25zdCBzdG9yZUVsZW1lbnRFdmVudCA9IGV2ZW50c1t0eXBlRXZlbnRdIHx8IHt9O1xyXG4gICAgICBjb25zdCBpc05hbWVzcGFjZSA9IG9yaWdpbmFsVHlwZUV2ZW50LnN0YXJ0c1dpdGgoJy4nKTtcclxuICAgICAgaWYgKHR5cGVvZiBjYWxsYWJsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAvLyBTaW1wbGVzdCBjYXNlOiBoYW5kbGVyIGlzIHBhc3NlZCwgcmVtb3ZlIHRoYXQgbGlzdGVuZXIgT05MWS5cclxuICAgICAgICBpZiAoIU9iamVjdC5rZXlzKHN0b3JlRWxlbWVudEV2ZW50KS5sZW5ndGgpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVtb3ZlSGFuZGxlcihlbGVtZW50LCBldmVudHMsIHR5cGVFdmVudCwgY2FsbGFibGUsIGlzRGVsZWdhdGVkID8gaGFuZGxlciA6IG51bGwpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaXNOYW1lc3BhY2UpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnRFdmVudCBvZiBPYmplY3Qua2V5cyhldmVudHMpKSB7XHJcbiAgICAgICAgICByZW1vdmVOYW1lc3BhY2VkSGFuZGxlcnMoZWxlbWVudCwgZXZlbnRzLCBlbGVtZW50RXZlbnQsIG9yaWdpbmFsVHlwZUV2ZW50LnNsaWNlKDEpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZm9yIChjb25zdCBba2V5SGFuZGxlcnMsIGV2ZW50XSBvZiBPYmplY3QuZW50cmllcyhzdG9yZUVsZW1lbnRFdmVudCkpIHtcclxuICAgICAgICBjb25zdCBoYW5kbGVyS2V5ID0ga2V5SGFuZGxlcnMucmVwbGFjZShzdHJpcFVpZFJlZ2V4LCAnJyk7XHJcbiAgICAgICAgaWYgKCFpbk5hbWVzcGFjZSB8fCBvcmlnaW5hbFR5cGVFdmVudC5pbmNsdWRlcyhoYW5kbGVyS2V5KSkge1xyXG4gICAgICAgICAgcmVtb3ZlSGFuZGxlcihlbGVtZW50LCBldmVudHMsIHR5cGVFdmVudCwgZXZlbnQuY2FsbGFibGUsIGV2ZW50LmRlbGVnYXRpb25TZWxlY3Rvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgdHJpZ2dlcihlbGVtZW50LCBldmVudCwgYXJncykge1xyXG4gICAgICBpZiAodHlwZW9mIGV2ZW50ICE9PSAnc3RyaW5nJyB8fCAhZWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0ICQgPSBnZXRqUXVlcnkoKTtcclxuICAgICAgY29uc3QgdHlwZUV2ZW50ID0gZ2V0VHlwZUV2ZW50KGV2ZW50KTtcclxuICAgICAgY29uc3QgaW5OYW1lc3BhY2UgPSBldmVudCAhPT0gdHlwZUV2ZW50O1xyXG4gICAgICBsZXQgalF1ZXJ5RXZlbnQgPSBudWxsO1xyXG4gICAgICBsZXQgYnViYmxlcyA9IHRydWU7XHJcbiAgICAgIGxldCBuYXRpdmVEaXNwYXRjaCA9IHRydWU7XHJcbiAgICAgIGxldCBkZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XHJcbiAgICAgIGlmIChpbk5hbWVzcGFjZSAmJiAkKSB7XHJcbiAgICAgICAgalF1ZXJ5RXZlbnQgPSAkLkV2ZW50KGV2ZW50LCBhcmdzKTtcclxuICAgICAgICAkKGVsZW1lbnQpLnRyaWdnZXIoalF1ZXJ5RXZlbnQpO1xyXG4gICAgICAgIGJ1YmJsZXMgPSAhalF1ZXJ5RXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKTtcclxuICAgICAgICBuYXRpdmVEaXNwYXRjaCA9ICFqUXVlcnlFdmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpO1xyXG4gICAgICAgIGRlZmF1bHRQcmV2ZW50ZWQgPSBqUXVlcnlFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBldnQgPSBoeWRyYXRlT2JqKG5ldyBFdmVudChldmVudCwge1xyXG4gICAgICAgIGJ1YmJsZXMsXHJcbiAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxyXG4gICAgICB9KSwgYXJncyk7XHJcbiAgICAgIGlmIChkZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG5hdGl2ZURpc3BhdGNoKSB7XHJcbiAgICAgICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2dCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGV2dC5kZWZhdWx0UHJldmVudGVkICYmIGpRdWVyeUV2ZW50KSB7XHJcbiAgICAgICAgalF1ZXJ5RXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZXZ0O1xyXG4gICAgfVxyXG4gIH07XHJcbiAgZnVuY3Rpb24gaHlkcmF0ZU9iaihvYmosIG1ldGEgPSB7fSkge1xyXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobWV0YSkpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xyXG4gICAgICB9IGNhdGNoIChfdW51c2VkKSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XHJcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICBnZXQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9iajtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICogQm9vdHN0cmFwIGRvbS9tYW5pcHVsYXRvci5qc1xyXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICovXHJcblxyXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZURhdGEodmFsdWUpIHtcclxuICAgIGlmICh2YWx1ZSA9PT0gJ3RydWUnKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHZhbHVlID09PSAnZmFsc2UnKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmICh2YWx1ZSA9PT0gTnVtYmVyKHZhbHVlKS50b1N0cmluZygpKSB7XHJcbiAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgaWYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gJ251bGwnKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XHJcbiAgICB9IGNhdGNoIChfdW51c2VkKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICB9XHJcbiAgZnVuY3Rpb24gbm9ybWFsaXplRGF0YUtleShrZXkpIHtcclxuICAgIHJldHVybiBrZXkucmVwbGFjZSgvW0EtWl0vZywgY2hyID0+IGAtJHtjaHIudG9Mb3dlckNhc2UoKX1gKTtcclxuICB9XHJcbiAgY29uc3QgTWFuaXB1bGF0b3IgPSB7XHJcbiAgICBzZXREYXRhQXR0cmlidXRlKGVsZW1lbnQsIGtleSwgdmFsdWUpIHtcclxuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYGRhdGEtYnMtJHtub3JtYWxpemVEYXRhS2V5KGtleSl9YCwgdmFsdWUpO1xyXG4gICAgfSxcclxuICAgIHJlbW92ZURhdGFBdHRyaWJ1dGUoZWxlbWVudCwga2V5KSB7XHJcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGBkYXRhLWJzLSR7bm9ybWFsaXplRGF0YUtleShrZXkpfWApO1xyXG4gICAgfSxcclxuICAgIGdldERhdGFBdHRyaWJ1dGVzKGVsZW1lbnQpIHtcclxuICAgICAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcclxuICAgICAgY29uc3QgYnNLZXlzID0gT2JqZWN0LmtleXMoZWxlbWVudC5kYXRhc2V0KS5maWx0ZXIoa2V5ID0+IGtleS5zdGFydHNXaXRoKCdicycpICYmICFrZXkuc3RhcnRzV2l0aCgnYnNDb25maWcnKSk7XHJcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGJzS2V5cykge1xyXG4gICAgICAgIGxldCBwdXJlS2V5ID0ga2V5LnJlcGxhY2UoL15icy8sICcnKTtcclxuICAgICAgICBwdXJlS2V5ID0gcHVyZUtleS5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHB1cmVLZXkuc2xpY2UoMSwgcHVyZUtleS5sZW5ndGgpO1xyXG4gICAgICAgIGF0dHJpYnV0ZXNbcHVyZUtleV0gPSBub3JtYWxpemVEYXRhKGVsZW1lbnQuZGF0YXNldFtrZXldKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYXR0cmlidXRlcztcclxuICAgIH0sXHJcbiAgICBnZXREYXRhQXR0cmlidXRlKGVsZW1lbnQsIGtleSkge1xyXG4gICAgICByZXR1cm4gbm9ybWFsaXplRGF0YShlbGVtZW50LmdldEF0dHJpYnV0ZShgZGF0YS1icy0ke25vcm1hbGl6ZURhdGFLZXkoa2V5KX1gKSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKiBCb290c3RyYXAgdXRpbC9jb25maWcuanNcclxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqL1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxyXG4gICAqL1xyXG5cclxuICBjbGFzcyBDb25maWcge1xyXG4gICAgLy8gR2V0dGVyc1xyXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xyXG4gICAgICByZXR1cm4ge307XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xyXG4gICAgICByZXR1cm4ge307XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGhhdmUgdG8gaW1wbGVtZW50IHRoZSBzdGF0aWMgbWV0aG9kIFwiTkFNRVwiLCBmb3IgZWFjaCBjb21wb25lbnQhJyk7XHJcbiAgICB9XHJcbiAgICBfZ2V0Q29uZmlnKGNvbmZpZykge1xyXG4gICAgICBjb25maWcgPSB0aGlzLl9tZXJnZUNvbmZpZ09iaihjb25maWcpO1xyXG4gICAgICBjb25maWcgPSB0aGlzLl9jb25maWdBZnRlck1lcmdlKGNvbmZpZyk7XHJcbiAgICAgIHRoaXMuX3R5cGVDaGVja0NvbmZpZyhjb25maWcpO1xyXG4gICAgICByZXR1cm4gY29uZmlnO1xyXG4gICAgfVxyXG4gICAgX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKSB7XHJcbiAgICAgIHJldHVybiBjb25maWc7XHJcbiAgICB9XHJcbiAgICBfbWVyZ2VDb25maWdPYmooY29uZmlnLCBlbGVtZW50KSB7XHJcbiAgICAgIGNvbnN0IGpzb25Db25maWcgPSBpc0VsZW1lbnQkMShlbGVtZW50KSA/IE1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGUoZWxlbWVudCwgJ2NvbmZpZycpIDoge307IC8vIHRyeSB0byBwYXJzZVxyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICAuLi50aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHQsXHJcbiAgICAgICAgLi4uKHR5cGVvZiBqc29uQ29uZmlnID09PSAnb2JqZWN0JyA/IGpzb25Db25maWcgOiB7fSksXHJcbiAgICAgICAgLi4uKGlzRWxlbWVudCQxKGVsZW1lbnQpID8gTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZXMoZWxlbWVudCkgOiB7fSksXHJcbiAgICAgICAgLi4uKHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnID8gY29uZmlnIDoge30pXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBfdHlwZUNoZWNrQ29uZmlnKGNvbmZpZywgY29uZmlnVHlwZXMgPSB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlKSB7XHJcbiAgICAgIGZvciAoY29uc3QgW3Byb3BlcnR5LCBleHBlY3RlZFR5cGVzXSBvZiBPYmplY3QuZW50cmllcyhjb25maWdUeXBlcykpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IGNvbmZpZ1twcm9wZXJ0eV07XHJcbiAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gaXNFbGVtZW50JDEodmFsdWUpID8gJ2VsZW1lbnQnIDogdG9UeXBlKHZhbHVlKTtcclxuICAgICAgICBpZiAoIW5ldyBSZWdFeHAoZXhwZWN0ZWRUeXBlcykudGVzdCh2YWx1ZVR5cGUpKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke3RoaXMuY29uc3RydWN0b3IuTkFNRS50b1VwcGVyQ2FzZSgpfTogT3B0aW9uIFwiJHtwcm9wZXJ0eX1cIiBwcm92aWRlZCB0eXBlIFwiJHt2YWx1ZVR5cGV9XCIgYnV0IGV4cGVjdGVkIHR5cGUgXCIke2V4cGVjdGVkVHlwZXN9XCIuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqIEJvb3RzdHJhcCBiYXNlLWNvbXBvbmVudC5qc1xyXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICovXHJcblxyXG5cclxuICAvKipcclxuICAgKiBDb25zdGFudHNcclxuICAgKi9cclxuXHJcbiAgY29uc3QgVkVSU0lPTiA9ICc1LjMuMyc7XHJcblxyXG4gIC8qKlxyXG4gICAqIENsYXNzIGRlZmluaXRpb25cclxuICAgKi9cclxuXHJcbiAgY2xhc3MgQmFzZUNvbXBvbmVudCBleHRlbmRzIENvbmZpZyB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgZWxlbWVudCA9IGdldEVsZW1lbnQoZWxlbWVudCk7XHJcbiAgICAgIGlmICghZWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcclxuICAgICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XHJcbiAgICAgIERhdGEuc2V0KHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVksIHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFB1YmxpY1xyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgRGF0YS5yZW1vdmUodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWSk7XHJcbiAgICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5FVkVOVF9LRVkpO1xyXG4gICAgICBmb3IgKGNvbnN0IHByb3BlcnR5TmFtZSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSkge1xyXG4gICAgICAgIHRoaXNbcHJvcGVydHlOYW1lXSA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIF9xdWV1ZUNhbGxiYWNrKGNhbGxiYWNrLCBlbGVtZW50LCBpc0FuaW1hdGVkID0gdHJ1ZSkge1xyXG4gICAgICBleGVjdXRlQWZ0ZXJUcmFuc2l0aW9uKGNhbGxiYWNrLCBlbGVtZW50LCBpc0FuaW1hdGVkKTtcclxuICAgIH1cclxuICAgIF9nZXRDb25maWcoY29uZmlnKSB7XHJcbiAgICAgIGNvbmZpZyA9IHRoaXMuX21lcmdlQ29uZmlnT2JqKGNvbmZpZywgdGhpcy5fZWxlbWVudCk7XHJcbiAgICAgIGNvbmZpZyA9IHRoaXMuX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKTtcclxuICAgICAgdGhpcy5fdHlwZUNoZWNrQ29uZmlnKGNvbmZpZyk7XHJcbiAgICAgIHJldHVybiBjb25maWc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU3RhdGljXHJcbiAgICBzdGF0aWMgZ2V0SW5zdGFuY2UoZWxlbWVudCkge1xyXG4gICAgICByZXR1cm4gRGF0YS5nZXQoZ2V0RWxlbWVudChlbGVtZW50KSwgdGhpcy5EQVRBX0tFWSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZShlbGVtZW50LCBjb25maWcgPSB7fSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZShlbGVtZW50KSB8fCBuZXcgdGhpcyhlbGVtZW50LCB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyA/IGNvbmZpZyA6IG51bGwpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBWRVJTSU9OKCkge1xyXG4gICAgICByZXR1cm4gVkVSU0lPTjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXQgREFUQV9LRVkoKSB7XHJcbiAgICAgIHJldHVybiBgYnMuJHt0aGlzLk5BTUV9YDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXQgRVZFTlRfS0VZKCkge1xyXG4gICAgICByZXR1cm4gYC4ke3RoaXMuREFUQV9LRVl9YDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBldmVudE5hbWUobmFtZSkge1xyXG4gICAgICByZXR1cm4gYCR7bmFtZX0ke3RoaXMuRVZFTlRfS0VZfWA7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqIEJvb3RzdHJhcCBkb20vc2VsZWN0b3ItZW5naW5lLmpzXHJcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKi9cclxuXHJcbiAgY29uc3QgZ2V0U2VsZWN0b3IgPSBlbGVtZW50ID0+IHtcclxuICAgIGxldCBzZWxlY3RvciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWJzLXRhcmdldCcpO1xyXG4gICAgaWYgKCFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gJyMnKSB7XHJcbiAgICAgIGxldCBocmVmQXR0cmlidXRlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcclxuXHJcbiAgICAgIC8vIFRoZSBvbmx5IHZhbGlkIGNvbnRlbnQgdGhhdCBjb3VsZCBkb3VibGUgYXMgYSBzZWxlY3RvciBhcmUgSURzIG9yIGNsYXNzZXMsXHJcbiAgICAgIC8vIHNvIGV2ZXJ5dGhpbmcgc3RhcnRpbmcgd2l0aCBgI2Agb3IgYC5gLiBJZiBhIFwicmVhbFwiIFVSTCBpcyB1c2VkIGFzIHRoZSBzZWxlY3RvcixcclxuICAgICAgLy8gYGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JgIHdpbGwgcmlnaHRmdWxseSBjb21wbGFpbiBpdCBpcyBpbnZhbGlkLlxyXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2lzc3Vlcy8zMjI3M1xyXG4gICAgICBpZiAoIWhyZWZBdHRyaWJ1dGUgfHwgIWhyZWZBdHRyaWJ1dGUuaW5jbHVkZXMoJyMnKSAmJiAhaHJlZkF0dHJpYnV0ZS5zdGFydHNXaXRoKCcuJykpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSnVzdCBpbiBjYXNlIHNvbWUgQ01TIHB1dHMgb3V0IGEgZnVsbCBVUkwgd2l0aCB0aGUgYW5jaG9yIGFwcGVuZGVkXHJcbiAgICAgIGlmIChocmVmQXR0cmlidXRlLmluY2x1ZGVzKCcjJykgJiYgIWhyZWZBdHRyaWJ1dGUuc3RhcnRzV2l0aCgnIycpKSB7XHJcbiAgICAgICAgaHJlZkF0dHJpYnV0ZSA9IGAjJHtocmVmQXR0cmlidXRlLnNwbGl0KCcjJylbMV19YDtcclxuICAgICAgfVxyXG4gICAgICBzZWxlY3RvciA9IGhyZWZBdHRyaWJ1dGUgJiYgaHJlZkF0dHJpYnV0ZSAhPT0gJyMnID8gaHJlZkF0dHJpYnV0ZS50cmltKCkgOiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNlbGVjdG9yID8gc2VsZWN0b3Iuc3BsaXQoJywnKS5tYXAoc2VsID0+IHBhcnNlU2VsZWN0b3Ioc2VsKSkuam9pbignLCcpIDogbnVsbDtcclxuICB9O1xyXG4gIGNvbnN0IFNlbGVjdG9yRW5naW5lID0ge1xyXG4gICAgZmluZChzZWxlY3RvciwgZWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xyXG4gICAgICByZXR1cm4gW10uY29uY2F0KC4uLkVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3JBbGwuY2FsbChlbGVtZW50LCBzZWxlY3RvcikpO1xyXG4gICAgfSxcclxuICAgIGZpbmRPbmUoc2VsZWN0b3IsIGVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcclxuICAgICAgcmV0dXJuIEVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3IuY2FsbChlbGVtZW50LCBzZWxlY3Rvcik7XHJcbiAgICB9LFxyXG4gICAgY2hpbGRyZW4oZWxlbWVudCwgc2VsZWN0b3IpIHtcclxuICAgICAgcmV0dXJuIFtdLmNvbmNhdCguLi5lbGVtZW50LmNoaWxkcmVuKS5maWx0ZXIoY2hpbGQgPT4gY2hpbGQubWF0Y2hlcyhzZWxlY3RvcikpO1xyXG4gICAgfSxcclxuICAgIHBhcmVudHMoZWxlbWVudCwgc2VsZWN0b3IpIHtcclxuICAgICAgY29uc3QgcGFyZW50cyA9IFtdO1xyXG4gICAgICBsZXQgYW5jZXN0b3IgPSBlbGVtZW50LnBhcmVudE5vZGUuY2xvc2VzdChzZWxlY3Rvcik7XHJcbiAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xyXG4gICAgICAgIHBhcmVudHMucHVzaChhbmNlc3Rvcik7XHJcbiAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnROb2RlLmNsb3Nlc3Qoc2VsZWN0b3IpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBwYXJlbnRzO1xyXG4gICAgfSxcclxuICAgIHByZXYoZWxlbWVudCwgc2VsZWN0b3IpIHtcclxuICAgICAgbGV0IHByZXZpb3VzID0gZWxlbWVudC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xyXG4gICAgICB3aGlsZSAocHJldmlvdXMpIHtcclxuICAgICAgICBpZiAocHJldmlvdXMubWF0Y2hlcyhzZWxlY3RvcikpIHtcclxuICAgICAgICAgIHJldHVybiBbcHJldmlvdXNdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcmV2aW91cyA9IHByZXZpb3VzLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfSxcclxuICAgIC8vIFRPRE86IHRoaXMgaXMgbm93IHVudXNlZDsgcmVtb3ZlIGxhdGVyIGFsb25nIHdpdGggcHJldigpXHJcbiAgICBuZXh0KGVsZW1lbnQsIHNlbGVjdG9yKSB7XHJcbiAgICAgIGxldCBuZXh0ID0gZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmc7XHJcbiAgICAgIHdoaWxlIChuZXh0KSB7XHJcbiAgICAgICAgaWYgKG5leHQubWF0Y2hlcyhzZWxlY3RvcikpIHtcclxuICAgICAgICAgIHJldHVybiBbbmV4dF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5leHQgPSBuZXh0Lm5leHRFbGVtZW50U2libGluZztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9LFxyXG4gICAgZm9jdXNhYmxlQ2hpbGRyZW4oZWxlbWVudCkge1xyXG4gICAgICBjb25zdCBmb2N1c2FibGVzID0gWydhJywgJ2J1dHRvbicsICdpbnB1dCcsICd0ZXh0YXJlYScsICdzZWxlY3QnLCAnZGV0YWlscycsICdbdGFiaW5kZXhdJywgJ1tjb250ZW50ZWRpdGFibGU9XCJ0cnVlXCJdJ10ubWFwKHNlbGVjdG9yID0+IGAke3NlbGVjdG9yfTpub3QoW3RhYmluZGV4Xj1cIi1cIl0pYCkuam9pbignLCcpO1xyXG4gICAgICByZXR1cm4gdGhpcy5maW5kKGZvY3VzYWJsZXMsIGVsZW1lbnQpLmZpbHRlcihlbCA9PiAhaXNEaXNhYmxlZChlbCkgJiYgaXNWaXNpYmxlKGVsKSk7XHJcbiAgICB9LFxyXG4gICAgZ2V0U2VsZWN0b3JGcm9tRWxlbWVudChlbGVtZW50KSB7XHJcbiAgICAgIGNvbnN0IHNlbGVjdG9yID0gZ2V0U2VsZWN0b3IoZWxlbWVudCk7XHJcbiAgICAgIGlmIChzZWxlY3Rvcikge1xyXG4gICAgICAgIHJldHVybiBTZWxlY3RvckVuZ2luZS5maW5kT25lKHNlbGVjdG9yKSA/IHNlbGVjdG9yIDogbnVsbDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH0sXHJcbiAgICBnZXRFbGVtZW50RnJvbVNlbGVjdG9yKGVsZW1lbnQpIHtcclxuICAgICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRTZWxlY3RvcihlbGVtZW50KTtcclxuICAgICAgcmV0dXJuIHNlbGVjdG9yID8gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShzZWxlY3RvcikgOiBudWxsO1xyXG4gICAgfSxcclxuICAgIGdldE11bHRpcGxlRWxlbWVudHNGcm9tU2VsZWN0b3IoZWxlbWVudCkge1xyXG4gICAgICBjb25zdCBzZWxlY3RvciA9IGdldFNlbGVjdG9yKGVsZW1lbnQpO1xyXG4gICAgICByZXR1cm4gc2VsZWN0b3IgPyBTZWxlY3RvckVuZ2luZS5maW5kKHNlbGVjdG9yKSA6IFtdO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICogQm9vdHN0cmFwIHV0aWwvY29tcG9uZW50LWZ1bmN0aW9ucy5qc1xyXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICovXHJcblxyXG4gIGNvbnN0IGVuYWJsZURpc21pc3NUcmlnZ2VyID0gKGNvbXBvbmVudCwgbWV0aG9kID0gJ2hpZGUnKSA9PiB7XHJcbiAgICBjb25zdCBjbGlja0V2ZW50ID0gYGNsaWNrLmRpc21pc3Mke2NvbXBvbmVudC5FVkVOVF9LRVl9YDtcclxuICAgIGNvbnN0IG5hbWUgPSBjb21wb25lbnQuTkFNRTtcclxuICAgIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgY2xpY2tFdmVudCwgYFtkYXRhLWJzLWRpc21pc3M9XCIke25hbWV9XCJdYCwgZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgIGlmIChbJ0EnLCAnQVJFQSddLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkpIHtcclxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc0Rpc2FibGVkKHRoaXMpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHRhcmdldCA9IFNlbGVjdG9yRW5naW5lLmdldEVsZW1lbnRGcm9tU2VsZWN0b3IodGhpcykgfHwgdGhpcy5jbG9zZXN0KGAuJHtuYW1lfWApO1xyXG4gICAgICBjb25zdCBpbnN0YW5jZSA9IGNvbXBvbmVudC5nZXRPckNyZWF0ZUluc3RhbmNlKHRhcmdldCk7XHJcblxyXG4gICAgICAvLyBNZXRob2QgYXJndW1lbnQgaXMgbGVmdCwgZm9yIEFsZXJ0IGFuZCBvbmx5LCBhcyBpdCBkb2Vzbid0IGltcGxlbWVudCB0aGUgJ2hpZGUnIG1ldGhvZFxyXG4gICAgICBpbnN0YW5jZVttZXRob2RdKCk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqIEJvb3RzdHJhcCBhbGVydC5qc1xyXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICovXHJcblxyXG5cclxuICAvKipcclxuICAgKiBDb25zdGFudHNcclxuICAgKi9cclxuXHJcbiAgY29uc3QgTkFNRSRmID0gJ2FsZXJ0JztcclxuICBjb25zdCBEQVRBX0tFWSRhID0gJ2JzLmFsZXJ0JztcclxuICBjb25zdCBFVkVOVF9LRVkkYiA9IGAuJHtEQVRBX0tFWSRhfWA7XHJcbiAgY29uc3QgRVZFTlRfQ0xPU0UgPSBgY2xvc2Uke0VWRU5UX0tFWSRifWA7XHJcbiAgY29uc3QgRVZFTlRfQ0xPU0VEID0gYGNsb3NlZCR7RVZFTlRfS0VZJGJ9YDtcclxuICBjb25zdCBDTEFTU19OQU1FX0ZBREUkNSA9ICdmYWRlJztcclxuICBjb25zdCBDTEFTU19OQU1FX1NIT1ckOCA9ICdzaG93JztcclxuXHJcbiAgLyoqXHJcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxyXG4gICAqL1xyXG5cclxuICBjbGFzcyBBbGVydCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xyXG4gICAgLy8gR2V0dGVyc1xyXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xyXG4gICAgICByZXR1cm4gTkFNRSRmO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFB1YmxpY1xyXG4gICAgY2xvc2UoKSB7XHJcbiAgICAgIGNvbnN0IGNsb3NlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9DTE9TRSk7XHJcbiAgICAgIGlmIChjbG9zZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQ4KTtcclxuICAgICAgY29uc3QgaXNBbmltYXRlZCA9IHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRkFERSQ1KTtcclxuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjaygoKSA9PiB0aGlzLl9kZXN0cm95RWxlbWVudCgpLCB0aGlzLl9lbGVtZW50LCBpc0FuaW1hdGVkKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQcml2YXRlXHJcbiAgICBfZGVzdHJveUVsZW1lbnQoKSB7XHJcbiAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlKCk7XHJcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0NMT1NFRCk7XHJcbiAgICAgIHRoaXMuZGlzcG9zZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFN0YXRpY1xyXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IEFsZXJ0LmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcyk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkYXRhW2NvbmZpZ10gPT09IHVuZGVmaW5lZCB8fCBjb25maWcuc3RhcnRzV2l0aCgnXycpIHx8IGNvbmZpZyA9PT0gJ2NvbnN0cnVjdG9yJykge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGF0YVtjb25maWddKHRoaXMpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXHJcbiAgICovXHJcblxyXG4gIGVuYWJsZURpc21pc3NUcmlnZ2VyKEFsZXJ0LCAnY2xvc2UnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogalF1ZXJ5XHJcbiAgICovXHJcblxyXG4gIGRlZmluZUpRdWVyeVBsdWdpbihBbGVydCk7XHJcblxyXG4gIC8qKlxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICogQm9vdHN0cmFwIGJ1dHRvbi5qc1xyXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICovXHJcblxyXG5cclxuICAvKipcclxuICAgKiBDb25zdGFudHNcclxuICAgKi9cclxuXHJcbiAgY29uc3QgTkFNRSRlID0gJ2J1dHRvbic7XHJcbiAgY29uc3QgREFUQV9LRVkkOSA9ICdicy5idXR0b24nO1xyXG4gIGNvbnN0IEVWRU5UX0tFWSRhID0gYC4ke0RBVEFfS0VZJDl9YDtcclxuICBjb25zdCBEQVRBX0FQSV9LRVkkNiA9ICcuZGF0YS1hcGknO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfQUNUSVZFJDMgPSAnYWN0aXZlJztcclxuICBjb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ1ID0gJ1tkYXRhLWJzLXRvZ2dsZT1cImJ1dHRvblwiXSc7XHJcbiAgY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNiA9IGBjbGljayR7RVZFTlRfS0VZJGF9JHtEQVRBX0FQSV9LRVkkNn1gO1xyXG5cclxuICAvKipcclxuICAgKiBDbGFzcyBkZWZpbml0aW9uXHJcbiAgICovXHJcblxyXG4gIGNsYXNzIEJ1dHRvbiBleHRlbmRzIEJhc2VDb21wb25lbnQge1xyXG4gICAgLy8gR2V0dGVyc1xyXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xyXG4gICAgICByZXR1cm4gTkFNRSRlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFB1YmxpY1xyXG4gICAgdG9nZ2xlKCkge1xyXG4gICAgICAvLyBUb2dnbGUgY2xhc3MgYW5kIHN5bmMgdGhlIGBhcmlhLXByZXNzZWRgIGF0dHJpYnV0ZSB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGAudG9nZ2xlKClgIG1ldGhvZFxyXG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1wcmVzc2VkJywgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKENMQVNTX05BTUVfQUNUSVZFJDMpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTdGF0aWNcclxuICAgIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBCdXR0b24uZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKTtcclxuICAgICAgICBpZiAoY29uZmlnID09PSAndG9nZ2xlJykge1xyXG4gICAgICAgICAgZGF0YVtjb25maWddKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXHJcbiAgICovXHJcblxyXG4gIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNiwgU0VMRUNUT1JfREFUQV9UT0dHTEUkNSwgZXZlbnQgPT4ge1xyXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIGNvbnN0IGJ1dHRvbiA9IGV2ZW50LnRhcmdldC5jbG9zZXN0KFNFTEVDVE9SX0RBVEFfVE9HR0xFJDUpO1xyXG4gICAgY29uc3QgZGF0YSA9IEJ1dHRvbi5nZXRPckNyZWF0ZUluc3RhbmNlKGJ1dHRvbik7XHJcbiAgICBkYXRhLnRvZ2dsZSgpO1xyXG4gIH0pO1xyXG5cclxuICAvKipcclxuICAgKiBqUXVlcnlcclxuICAgKi9cclxuXHJcbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luKEJ1dHRvbik7XHJcblxyXG4gIC8qKlxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICogQm9vdHN0cmFwIHV0aWwvc3dpcGUuanNcclxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqL1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RhbnRzXHJcbiAgICovXHJcblxyXG4gIGNvbnN0IE5BTUUkZCA9ICdzd2lwZSc7XHJcbiAgY29uc3QgRVZFTlRfS0VZJDkgPSAnLmJzLnN3aXBlJztcclxuICBjb25zdCBFVkVOVF9UT1VDSFNUQVJUID0gYHRvdWNoc3RhcnQke0VWRU5UX0tFWSQ5fWA7XHJcbiAgY29uc3QgRVZFTlRfVE9VQ0hNT1ZFID0gYHRvdWNobW92ZSR7RVZFTlRfS0VZJDl9YDtcclxuICBjb25zdCBFVkVOVF9UT1VDSEVORCA9IGB0b3VjaGVuZCR7RVZFTlRfS0VZJDl9YDtcclxuICBjb25zdCBFVkVOVF9QT0lOVEVSRE9XTiA9IGBwb2ludGVyZG93biR7RVZFTlRfS0VZJDl9YDtcclxuICBjb25zdCBFVkVOVF9QT0lOVEVSVVAgPSBgcG9pbnRlcnVwJHtFVkVOVF9LRVkkOX1gO1xyXG4gIGNvbnN0IFBPSU5URVJfVFlQRV9UT1VDSCA9ICd0b3VjaCc7XHJcbiAgY29uc3QgUE9JTlRFUl9UWVBFX1BFTiA9ICdwZW4nO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfUE9JTlRFUl9FVkVOVCA9ICdwb2ludGVyLWV2ZW50JztcclxuICBjb25zdCBTV0lQRV9USFJFU0hPTEQgPSA0MDtcclxuICBjb25zdCBEZWZhdWx0JGMgPSB7XHJcbiAgICBlbmRDYWxsYmFjazogbnVsbCxcclxuICAgIGxlZnRDYWxsYmFjazogbnVsbCxcclxuICAgIHJpZ2h0Q2FsbGJhY2s6IG51bGxcclxuICB9O1xyXG4gIGNvbnN0IERlZmF1bHRUeXBlJGMgPSB7XHJcbiAgICBlbmRDYWxsYmFjazogJyhmdW5jdGlvbnxudWxsKScsXHJcbiAgICBsZWZ0Q2FsbGJhY2s6ICcoZnVuY3Rpb258bnVsbCknLFxyXG4gICAgcmlnaHRDYWxsYmFjazogJyhmdW5jdGlvbnxudWxsKSdcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDbGFzcyBkZWZpbml0aW9uXHJcbiAgICovXHJcblxyXG4gIGNsYXNzIFN3aXBlIGV4dGVuZHMgQ29uZmlnIHtcclxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcclxuICAgICAgaWYgKCFlbGVtZW50IHx8ICFTd2lwZS5pc1N1cHBvcnRlZCgpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xyXG4gICAgICB0aGlzLl9kZWx0YVggPSAwO1xyXG4gICAgICB0aGlzLl9zdXBwb3J0UG9pbnRlckV2ZW50cyA9IEJvb2xlYW4od2luZG93LlBvaW50ZXJFdmVudCk7XHJcbiAgICAgIHRoaXMuX2luaXRFdmVudHMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBHZXR0ZXJzXHJcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XHJcbiAgICAgIHJldHVybiBEZWZhdWx0JGM7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xyXG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGUkYztcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcclxuICAgICAgcmV0dXJuIE5BTUUkZDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQdWJsaWNcclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fZWxlbWVudCwgRVZFTlRfS0VZJDkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFByaXZhdGVcclxuICAgIF9zdGFydChldmVudCkge1xyXG4gICAgICBpZiAoIXRoaXMuX3N1cHBvcnRQb2ludGVyRXZlbnRzKSB7XHJcbiAgICAgICAgdGhpcy5fZGVsdGFYID0gZXZlbnQudG91Y2hlc1swXS5jbGllbnRYO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5fZXZlbnRJc1BvaW50ZXJQZW5Ub3VjaChldmVudCkpIHtcclxuICAgICAgICB0aGlzLl9kZWx0YVggPSBldmVudC5jbGllbnRYO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBfZW5kKGV2ZW50KSB7XHJcbiAgICAgIGlmICh0aGlzLl9ldmVudElzUG9pbnRlclBlblRvdWNoKGV2ZW50KSkge1xyXG4gICAgICAgIHRoaXMuX2RlbHRhWCA9IGV2ZW50LmNsaWVudFggLSB0aGlzLl9kZWx0YVg7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5faGFuZGxlU3dpcGUoKTtcclxuICAgICAgZXhlY3V0ZSh0aGlzLl9jb25maWcuZW5kQ2FsbGJhY2spO1xyXG4gICAgfVxyXG4gICAgX21vdmUoZXZlbnQpIHtcclxuICAgICAgdGhpcy5fZGVsdGFYID0gZXZlbnQudG91Y2hlcyAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA+IDEgPyAwIDogZXZlbnQudG91Y2hlc1swXS5jbGllbnRYIC0gdGhpcy5fZGVsdGFYO1xyXG4gICAgfVxyXG4gICAgX2hhbmRsZVN3aXBlKCkge1xyXG4gICAgICBjb25zdCBhYnNEZWx0YVggPSBNYXRoLmFicyh0aGlzLl9kZWx0YVgpO1xyXG4gICAgICBpZiAoYWJzRGVsdGFYIDw9IFNXSVBFX1RIUkVTSE9MRCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSBhYnNEZWx0YVggLyB0aGlzLl9kZWx0YVg7XHJcbiAgICAgIHRoaXMuX2RlbHRhWCA9IDA7XHJcbiAgICAgIGlmICghZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGV4ZWN1dGUoZGlyZWN0aW9uID4gMCA/IHRoaXMuX2NvbmZpZy5yaWdodENhbGxiYWNrIDogdGhpcy5fY29uZmlnLmxlZnRDYWxsYmFjayk7XHJcbiAgICB9XHJcbiAgICBfaW5pdEV2ZW50cygpIHtcclxuICAgICAgaWYgKHRoaXMuX3N1cHBvcnRQb2ludGVyRXZlbnRzKSB7XHJcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1BPSU5URVJET1dOLCBldmVudCA9PiB0aGlzLl9zdGFydChldmVudCkpO1xyXG4gICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9QT0lOVEVSVVAsIGV2ZW50ID0+IHRoaXMuX2VuZChldmVudCkpO1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1BPSU5URVJfRVZFTlQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9UT1VDSFNUQVJULCBldmVudCA9PiB0aGlzLl9zdGFydChldmVudCkpO1xyXG4gICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9UT1VDSE1PVkUsIGV2ZW50ID0+IHRoaXMuX21vdmUoZXZlbnQpKTtcclxuICAgICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfVE9VQ0hFTkQsIGV2ZW50ID0+IHRoaXMuX2VuZChldmVudCkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBfZXZlbnRJc1BvaW50ZXJQZW5Ub3VjaChldmVudCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fc3VwcG9ydFBvaW50ZXJFdmVudHMgJiYgKGV2ZW50LnBvaW50ZXJUeXBlID09PSBQT0lOVEVSX1RZUEVfUEVOIHx8IGV2ZW50LnBvaW50ZXJUeXBlID09PSBQT0lOVEVSX1RZUEVfVE9VQ0gpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFN0YXRpY1xyXG4gICAgc3RhdGljIGlzU3VwcG9ydGVkKCkge1xyXG4gICAgICByZXR1cm4gJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDA7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqIEJvb3RzdHJhcCBjYXJvdXNlbC5qc1xyXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICovXHJcblxyXG5cclxuICAvKipcclxuICAgKiBDb25zdGFudHNcclxuICAgKi9cclxuXHJcbiAgY29uc3QgTkFNRSRjID0gJ2Nhcm91c2VsJztcclxuICBjb25zdCBEQVRBX0tFWSQ4ID0gJ2JzLmNhcm91c2VsJztcclxuICBjb25zdCBFVkVOVF9LRVkkOCA9IGAuJHtEQVRBX0tFWSQ4fWA7XHJcbiAgY29uc3QgREFUQV9BUElfS0VZJDUgPSAnLmRhdGEtYXBpJztcclxuICBjb25zdCBBUlJPV19MRUZUX0tFWSQxID0gJ0Fycm93TGVmdCc7XHJcbiAgY29uc3QgQVJST1dfUklHSFRfS0VZJDEgPSAnQXJyb3dSaWdodCc7XHJcbiAgY29uc3QgVE9VQ0hFVkVOVF9DT01QQVRfV0FJVCA9IDUwMDsgLy8gVGltZSBmb3IgbW91c2UgY29tcGF0IGV2ZW50cyB0byBmaXJlIGFmdGVyIHRvdWNoXHJcblxyXG4gIGNvbnN0IE9SREVSX05FWFQgPSAnbmV4dCc7XHJcbiAgY29uc3QgT1JERVJfUFJFViA9ICdwcmV2JztcclxuICBjb25zdCBESVJFQ1RJT05fTEVGVCA9ICdsZWZ0JztcclxuICBjb25zdCBESVJFQ1RJT05fUklHSFQgPSAncmlnaHQnO1xyXG4gIGNvbnN0IEVWRU5UX1NMSURFID0gYHNsaWRlJHtFVkVOVF9LRVkkOH1gO1xyXG4gIGNvbnN0IEVWRU5UX1NMSUQgPSBgc2xpZCR7RVZFTlRfS0VZJDh9YDtcclxuICBjb25zdCBFVkVOVF9LRVlET1dOJDEgPSBga2V5ZG93biR7RVZFTlRfS0VZJDh9YDtcclxuICBjb25zdCBFVkVOVF9NT1VTRUVOVEVSJDEgPSBgbW91c2VlbnRlciR7RVZFTlRfS0VZJDh9YDtcclxuICBjb25zdCBFVkVOVF9NT1VTRUxFQVZFJDEgPSBgbW91c2VsZWF2ZSR7RVZFTlRfS0VZJDh9YDtcclxuICBjb25zdCBFVkVOVF9EUkFHX1NUQVJUID0gYGRyYWdzdGFydCR7RVZFTlRfS0VZJDh9YDtcclxuICBjb25zdCBFVkVOVF9MT0FEX0RBVEFfQVBJJDMgPSBgbG9hZCR7RVZFTlRfS0VZJDh9JHtEQVRBX0FQSV9LRVkkNX1gO1xyXG4gIGNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJJDUgPSBgY2xpY2ske0VWRU5UX0tFWSQ4fSR7REFUQV9BUElfS0VZJDV9YDtcclxuICBjb25zdCBDTEFTU19OQU1FX0NBUk9VU0VMID0gJ2Nhcm91c2VsJztcclxuICBjb25zdCBDTEFTU19OQU1FX0FDVElWRSQyID0gJ2FjdGl2ZSc7XHJcbiAgY29uc3QgQ0xBU1NfTkFNRV9TTElERSA9ICdzbGlkZSc7XHJcbiAgY29uc3QgQ0xBU1NfTkFNRV9FTkQgPSAnY2Fyb3VzZWwtaXRlbS1lbmQnO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfU1RBUlQgPSAnY2Fyb3VzZWwtaXRlbS1zdGFydCc7XHJcbiAgY29uc3QgQ0xBU1NfTkFNRV9ORVhUID0gJ2Nhcm91c2VsLWl0ZW0tbmV4dCc7XHJcbiAgY29uc3QgQ0xBU1NfTkFNRV9QUkVWID0gJ2Nhcm91c2VsLWl0ZW0tcHJldic7XHJcbiAgY29uc3QgU0VMRUNUT1JfQUNUSVZFID0gJy5hY3RpdmUnO1xyXG4gIGNvbnN0IFNFTEVDVE9SX0lURU0gPSAnLmNhcm91c2VsLWl0ZW0nO1xyXG4gIGNvbnN0IFNFTEVDVE9SX0FDVElWRV9JVEVNID0gU0VMRUNUT1JfQUNUSVZFICsgU0VMRUNUT1JfSVRFTTtcclxuICBjb25zdCBTRUxFQ1RPUl9JVEVNX0lNRyA9ICcuY2Fyb3VzZWwtaXRlbSBpbWcnO1xyXG4gIGNvbnN0IFNFTEVDVE9SX0lORElDQVRPUlMgPSAnLmNhcm91c2VsLWluZGljYXRvcnMnO1xyXG4gIGNvbnN0IFNFTEVDVE9SX0RBVEFfU0xJREUgPSAnW2RhdGEtYnMtc2xpZGVdLCBbZGF0YS1icy1zbGlkZS10b10nO1xyXG4gIGNvbnN0IFNFTEVDVE9SX0RBVEFfUklERSA9ICdbZGF0YS1icy1yaWRlPVwiY2Fyb3VzZWxcIl0nO1xyXG4gIGNvbnN0IEtFWV9UT19ESVJFQ1RJT04gPSB7XHJcbiAgICBbQVJST1dfTEVGVF9LRVkkMV06IERJUkVDVElPTl9SSUdIVCxcclxuICAgIFtBUlJPV19SSUdIVF9LRVkkMV06IERJUkVDVElPTl9MRUZUXHJcbiAgfTtcclxuICBjb25zdCBEZWZhdWx0JGIgPSB7XHJcbiAgICBpbnRlcnZhbDogNTAwMCxcclxuICAgIGtleWJvYXJkOiB0cnVlLFxyXG4gICAgcGF1c2U6ICdob3ZlcicsXHJcbiAgICByaWRlOiBmYWxzZSxcclxuICAgIHRvdWNoOiB0cnVlLFxyXG4gICAgd3JhcDogdHJ1ZVxyXG4gIH07XHJcbiAgY29uc3QgRGVmYXVsdFR5cGUkYiA9IHtcclxuICAgIGludGVydmFsOiAnKG51bWJlcnxib29sZWFuKScsXHJcbiAgICAvLyBUT0RPOnY2IHJlbW92ZSBib29sZWFuIHN1cHBvcnRcclxuICAgIGtleWJvYXJkOiAnYm9vbGVhbicsXHJcbiAgICBwYXVzZTogJyhzdHJpbmd8Ym9vbGVhbiknLFxyXG4gICAgcmlkZTogJyhib29sZWFufHN0cmluZyknLFxyXG4gICAgdG91Y2g6ICdib29sZWFuJyxcclxuICAgIHdyYXA6ICdib29sZWFuJ1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENsYXNzIGRlZmluaXRpb25cclxuICAgKi9cclxuXHJcbiAgY2xhc3MgQ2Fyb3VzZWwgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xyXG4gICAgICBzdXBlcihlbGVtZW50LCBjb25maWcpO1xyXG4gICAgICB0aGlzLl9pbnRlcnZhbCA9IG51bGw7XHJcbiAgICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBudWxsO1xyXG4gICAgICB0aGlzLl9pc1NsaWRpbmcgPSBmYWxzZTtcclxuICAgICAgdGhpcy50b3VjaFRpbWVvdXQgPSBudWxsO1xyXG4gICAgICB0aGlzLl9zd2lwZUhlbHBlciA9IG51bGw7XHJcbiAgICAgIHRoaXMuX2luZGljYXRvcnNFbGVtZW50ID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9JTkRJQ0FUT1JTLCB0aGlzLl9lbGVtZW50KTtcclxuICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcclxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5yaWRlID09PSBDTEFTU19OQU1FX0NBUk9VU0VMKSB7XHJcbiAgICAgICAgdGhpcy5jeWNsZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gR2V0dGVyc1xyXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xyXG4gICAgICByZXR1cm4gRGVmYXVsdCRiO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcclxuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJGI7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XHJcbiAgICAgIHJldHVybiBOQU1FJGM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHVibGljXHJcbiAgICBuZXh0KCkge1xyXG4gICAgICB0aGlzLl9zbGlkZShPUkRFUl9ORVhUKTtcclxuICAgIH1cclxuICAgIG5leHRXaGVuVmlzaWJsZSgpIHtcclxuICAgICAgLy8gRklYTUUgVE9ETyB1c2UgYGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZWBcclxuICAgICAgLy8gRG9uJ3QgY2FsbCBuZXh0IHdoZW4gdGhlIHBhZ2UgaXNuJ3QgdmlzaWJsZVxyXG4gICAgICAvLyBvciB0aGUgY2Fyb3VzZWwgb3IgaXRzIHBhcmVudCBpc24ndCB2aXNpYmxlXHJcbiAgICAgIGlmICghZG9jdW1lbnQuaGlkZGVuICYmIGlzVmlzaWJsZSh0aGlzLl9lbGVtZW50KSkge1xyXG4gICAgICAgIHRoaXMubmV4dCgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBwcmV2KCkge1xyXG4gICAgICB0aGlzLl9zbGlkZShPUkRFUl9QUkVWKTtcclxuICAgIH1cclxuICAgIHBhdXNlKCkge1xyXG4gICAgICBpZiAodGhpcy5faXNTbGlkaW5nKSB7XHJcbiAgICAgICAgdHJpZ2dlclRyYW5zaXRpb25FbmQodGhpcy5fZWxlbWVudCk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fY2xlYXJJbnRlcnZhbCgpO1xyXG4gICAgfVxyXG4gICAgY3ljbGUoKSB7XHJcbiAgICAgIHRoaXMuX2NsZWFySW50ZXJ2YWwoKTtcclxuICAgICAgdGhpcy5fdXBkYXRlSW50ZXJ2YWwoKTtcclxuICAgICAgdGhpcy5faW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLm5leHRXaGVuVmlzaWJsZSgpLCB0aGlzLl9jb25maWcuaW50ZXJ2YWwpO1xyXG4gICAgfVxyXG4gICAgX21heWJlRW5hYmxlQ3ljbGUoKSB7XHJcbiAgICAgIGlmICghdGhpcy5fY29uZmlnLnJpZGUpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuX2lzU2xpZGluZykge1xyXG4gICAgICAgIEV2ZW50SGFuZGxlci5vbmUodGhpcy5fZWxlbWVudCwgRVZFTlRfU0xJRCwgKCkgPT4gdGhpcy5jeWNsZSgpKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5jeWNsZSgpO1xyXG4gICAgfVxyXG4gICAgdG8oaW5kZXgpIHtcclxuICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLl9nZXRJdGVtcygpO1xyXG4gICAgICBpZiAoaW5kZXggPiBpdGVtcy5sZW5ndGggLSAxIHx8IGluZGV4IDwgMCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5faXNTbGlkaW5nKSB7XHJcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uZSh0aGlzLl9lbGVtZW50LCBFVkVOVF9TTElELCAoKSA9PiB0aGlzLnRvKGluZGV4KSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGFjdGl2ZUluZGV4ID0gdGhpcy5fZ2V0SXRlbUluZGV4KHRoaXMuX2dldEFjdGl2ZSgpKTtcclxuICAgICAgaWYgKGFjdGl2ZUluZGV4ID09PSBpbmRleCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBvcmRlciA9IGluZGV4ID4gYWN0aXZlSW5kZXggPyBPUkRFUl9ORVhUIDogT1JERVJfUFJFVjtcclxuICAgICAgdGhpcy5fc2xpZGUob3JkZXIsIGl0ZW1zW2luZGV4XSk7XHJcbiAgICB9XHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICBpZiAodGhpcy5fc3dpcGVIZWxwZXIpIHtcclxuICAgICAgICB0aGlzLl9zd2lwZUhlbHBlci5kaXNwb3NlKCk7XHJcbiAgICAgIH1cclxuICAgICAgc3VwZXIuZGlzcG9zZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFByaXZhdGVcclxuICAgIF9jb25maWdBZnRlck1lcmdlKGNvbmZpZykge1xyXG4gICAgICBjb25maWcuZGVmYXVsdEludGVydmFsID0gY29uZmlnLmludGVydmFsO1xyXG4gICAgICByZXR1cm4gY29uZmlnO1xyXG4gICAgfVxyXG4gICAgX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xyXG4gICAgICBpZiAodGhpcy5fY29uZmlnLmtleWJvYXJkKSB7XHJcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0tFWURPV04kMSwgZXZlbnQgPT4gdGhpcy5fa2V5ZG93bihldmVudCkpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLl9jb25maWcucGF1c2UgPT09ICdob3ZlcicpIHtcclxuICAgICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfTU9VU0VFTlRFUiQxLCAoKSA9PiB0aGlzLnBhdXNlKCkpO1xyXG4gICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9NT1VTRUxFQVZFJDEsICgpID0+IHRoaXMuX21heWJlRW5hYmxlQ3ljbGUoKSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy50b3VjaCAmJiBTd2lwZS5pc1N1cHBvcnRlZCgpKSB7XHJcbiAgICAgICAgdGhpcy5fYWRkVG91Y2hFdmVudExpc3RlbmVycygpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBfYWRkVG91Y2hFdmVudExpc3RlbmVycygpIHtcclxuICAgICAgZm9yIChjb25zdCBpbWcgb2YgU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9JVEVNX0lNRywgdGhpcy5fZWxlbWVudCkpIHtcclxuICAgICAgICBFdmVudEhhbmRsZXIub24oaW1nLCBFVkVOVF9EUkFHX1NUQVJULCBldmVudCA9PiBldmVudC5wcmV2ZW50RGVmYXVsdCgpKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBlbmRDYWxsQmFjayA9ICgpID0+IHtcclxuICAgICAgICBpZiAodGhpcy5fY29uZmlnLnBhdXNlICE9PSAnaG92ZXInKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiBpdCdzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2UsIG1vdXNlZW50ZXIvbGVhdmUgYXJlIGZpcmVkIGFzXHJcbiAgICAgICAgLy8gcGFydCBvZiB0aGUgbW91c2UgY29tcGF0aWJpbGl0eSBldmVudHMgb24gZmlyc3QgdGFwIC0gdGhlIGNhcm91c2VsXHJcbiAgICAgICAgLy8gd291bGQgc3RvcCBjeWNsaW5nIHVudGlsIHVzZXIgdGFwcGVkIG91dCBvZiBpdDtcclxuICAgICAgICAvLyBoZXJlLCB3ZSBsaXN0ZW4gZm9yIHRvdWNoZW5kLCBleHBsaWNpdGx5IHBhdXNlIHRoZSBjYXJvdXNlbFxyXG4gICAgICAgIC8vIChhcyBpZiBpdCdzIHRoZSBzZWNvbmQgdGltZSB3ZSB0YXAgb24gaXQsIG1vdXNlZW50ZXIgY29tcGF0IGV2ZW50XHJcbiAgICAgICAgLy8gaXMgTk9UIGZpcmVkKSBhbmQgYWZ0ZXIgYSB0aW1lb3V0ICh0byBhbGxvdyBmb3IgbW91c2UgY29tcGF0aWJpbGl0eVxyXG4gICAgICAgIC8vIGV2ZW50cyB0byBmaXJlKSB3ZSBleHBsaWNpdGx5IHJlc3RhcnQgY3ljbGluZ1xyXG5cclxuICAgICAgICB0aGlzLnBhdXNlKCk7XHJcbiAgICAgICAgaWYgKHRoaXMudG91Y2hUaW1lb3V0KSB7XHJcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50b3VjaFRpbWVvdXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRvdWNoVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5fbWF5YmVFbmFibGVDeWNsZSgpLCBUT1VDSEVWRU5UX0NPTVBBVF9XQUlUICsgdGhpcy5fY29uZmlnLmludGVydmFsKTtcclxuICAgICAgfTtcclxuICAgICAgY29uc3Qgc3dpcGVDb25maWcgPSB7XHJcbiAgICAgICAgbGVmdENhbGxiYWNrOiAoKSA9PiB0aGlzLl9zbGlkZSh0aGlzLl9kaXJlY3Rpb25Ub09yZGVyKERJUkVDVElPTl9MRUZUKSksXHJcbiAgICAgICAgcmlnaHRDYWxsYmFjazogKCkgPT4gdGhpcy5fc2xpZGUodGhpcy5fZGlyZWN0aW9uVG9PcmRlcihESVJFQ1RJT05fUklHSFQpKSxcclxuICAgICAgICBlbmRDYWxsYmFjazogZW5kQ2FsbEJhY2tcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5fc3dpcGVIZWxwZXIgPSBuZXcgU3dpcGUodGhpcy5fZWxlbWVudCwgc3dpcGVDb25maWcpO1xyXG4gICAgfVxyXG4gICAgX2tleWRvd24oZXZlbnQpIHtcclxuICAgICAgaWYgKC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IEtFWV9UT19ESVJFQ1RJT05bZXZlbnQua2V5XTtcclxuICAgICAgaWYgKGRpcmVjdGlvbikge1xyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgdGhpcy5fc2xpZGUodGhpcy5fZGlyZWN0aW9uVG9PcmRlcihkaXJlY3Rpb24pKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2dldEl0ZW1JbmRleChlbGVtZW50KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9nZXRJdGVtcygpLmluZGV4T2YoZWxlbWVudCk7XHJcbiAgICB9XHJcbiAgICBfc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudChpbmRleCkge1xyXG4gICAgICBpZiAoIXRoaXMuX2luZGljYXRvcnNFbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGFjdGl2ZUluZGljYXRvciA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfQUNUSVZFLCB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCk7XHJcbiAgICAgIGFjdGl2ZUluZGljYXRvci5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFJDIpO1xyXG4gICAgICBhY3RpdmVJbmRpY2F0b3IucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWN1cnJlbnQnKTtcclxuICAgICAgY29uc3QgbmV3QWN0aXZlSW5kaWNhdG9yID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShgW2RhdGEtYnMtc2xpZGUtdG89XCIke2luZGV4fVwiXWAsIHRoaXMuX2luZGljYXRvcnNFbGVtZW50KTtcclxuICAgICAgaWYgKG5ld0FjdGl2ZUluZGljYXRvcikge1xyXG4gICAgICAgIG5ld0FjdGl2ZUluZGljYXRvci5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFJDIpO1xyXG4gICAgICAgIG5ld0FjdGl2ZUluZGljYXRvci5zZXRBdHRyaWJ1dGUoJ2FyaWEtY3VycmVudCcsICd0cnVlJyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIF91cGRhdGVJbnRlcnZhbCgpIHtcclxuICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2FjdGl2ZUVsZW1lbnQgfHwgdGhpcy5fZ2V0QWN0aXZlKCk7XHJcbiAgICAgIGlmICghZWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBlbGVtZW50SW50ZXJ2YWwgPSBOdW1iZXIucGFyc2VJbnQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtaW50ZXJ2YWwnKSwgMTApO1xyXG4gICAgICB0aGlzLl9jb25maWcuaW50ZXJ2YWwgPSBlbGVtZW50SW50ZXJ2YWwgfHwgdGhpcy5fY29uZmlnLmRlZmF1bHRJbnRlcnZhbDtcclxuICAgIH1cclxuICAgIF9zbGlkZShvcmRlciwgZWxlbWVudCA9IG51bGwpIHtcclxuICAgICAgaWYgKHRoaXMuX2lzU2xpZGluZykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBhY3RpdmVFbGVtZW50ID0gdGhpcy5fZ2V0QWN0aXZlKCk7XHJcbiAgICAgIGNvbnN0IGlzTmV4dCA9IG9yZGVyID09PSBPUkRFUl9ORVhUO1xyXG4gICAgICBjb25zdCBuZXh0RWxlbWVudCA9IGVsZW1lbnQgfHwgZ2V0TmV4dEFjdGl2ZUVsZW1lbnQodGhpcy5fZ2V0SXRlbXMoKSwgYWN0aXZlRWxlbWVudCwgaXNOZXh0LCB0aGlzLl9jb25maWcud3JhcCk7XHJcbiAgICAgIGlmIChuZXh0RWxlbWVudCA9PT0gYWN0aXZlRWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBuZXh0RWxlbWVudEluZGV4ID0gdGhpcy5fZ2V0SXRlbUluZGV4KG5leHRFbGVtZW50KTtcclxuICAgICAgY29uc3QgdHJpZ2dlckV2ZW50ID0gZXZlbnROYW1lID0+IHtcclxuICAgICAgICByZXR1cm4gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgZXZlbnROYW1lLCB7XHJcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0OiBuZXh0RWxlbWVudCxcclxuICAgICAgICAgIGRpcmVjdGlvbjogdGhpcy5fb3JkZXJUb0RpcmVjdGlvbihvcmRlciksXHJcbiAgICAgICAgICBmcm9tOiB0aGlzLl9nZXRJdGVtSW5kZXgoYWN0aXZlRWxlbWVudCksXHJcbiAgICAgICAgICB0bzogbmV4dEVsZW1lbnRJbmRleFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9O1xyXG4gICAgICBjb25zdCBzbGlkZUV2ZW50ID0gdHJpZ2dlckV2ZW50KEVWRU5UX1NMSURFKTtcclxuICAgICAgaWYgKHNsaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWFjdGl2ZUVsZW1lbnQgfHwgIW5leHRFbGVtZW50KSB7XHJcbiAgICAgICAgLy8gU29tZSB3ZWlyZG5lc3MgaXMgaGFwcGVuaW5nLCBzbyB3ZSBiYWlsXHJcbiAgICAgICAgLy8gVE9ETzogY2hhbmdlIHRlc3RzIHRoYXQgdXNlIGVtcHR5IGRpdnMgdG8gYXZvaWQgdGhpcyBjaGVja1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBpc0N5Y2xpbmcgPSBCb29sZWFuKHRoaXMuX2ludGVydmFsKTtcclxuICAgICAgdGhpcy5wYXVzZSgpO1xyXG4gICAgICB0aGlzLl9pc1NsaWRpbmcgPSB0cnVlO1xyXG4gICAgICB0aGlzLl9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KG5leHRFbGVtZW50SW5kZXgpO1xyXG4gICAgICB0aGlzLl9hY3RpdmVFbGVtZW50ID0gbmV4dEVsZW1lbnQ7XHJcbiAgICAgIGNvbnN0IGRpcmVjdGlvbmFsQ2xhc3NOYW1lID0gaXNOZXh0ID8gQ0xBU1NfTkFNRV9TVEFSVCA6IENMQVNTX05BTUVfRU5EO1xyXG4gICAgICBjb25zdCBvcmRlckNsYXNzTmFtZSA9IGlzTmV4dCA/IENMQVNTX05BTUVfTkVYVCA6IENMQVNTX05BTUVfUFJFVjtcclxuICAgICAgbmV4dEVsZW1lbnQuY2xhc3NMaXN0LmFkZChvcmRlckNsYXNzTmFtZSk7XHJcbiAgICAgIHJlZmxvdyhuZXh0RWxlbWVudCk7XHJcbiAgICAgIGFjdGl2ZUVsZW1lbnQuY2xhc3NMaXN0LmFkZChkaXJlY3Rpb25hbENsYXNzTmFtZSk7XHJcbiAgICAgIG5leHRFbGVtZW50LmNsYXNzTGlzdC5hZGQoZGlyZWN0aW9uYWxDbGFzc05hbWUpO1xyXG4gICAgICBjb25zdCBjb21wbGV0ZUNhbGxCYWNrID0gKCkgPT4ge1xyXG4gICAgICAgIG5leHRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoZGlyZWN0aW9uYWxDbGFzc05hbWUsIG9yZGVyQ2xhc3NOYW1lKTtcclxuICAgICAgICBuZXh0RWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFJDIpO1xyXG4gICAgICAgIGFjdGl2ZUVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0FDVElWRSQyLCBvcmRlckNsYXNzTmFtZSwgZGlyZWN0aW9uYWxDbGFzc05hbWUpO1xyXG4gICAgICAgIHRoaXMuX2lzU2xpZGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRyaWdnZXJFdmVudChFVkVOVF9TTElEKTtcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZUNhbGxCYWNrLCBhY3RpdmVFbGVtZW50LCB0aGlzLl9pc0FuaW1hdGVkKCkpO1xyXG4gICAgICBpZiAoaXNDeWNsaW5nKSB7XHJcbiAgICAgICAgdGhpcy5jeWNsZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBfaXNBbmltYXRlZCgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0xJREUpO1xyXG4gICAgfVxyXG4gICAgX2dldEFjdGl2ZSgpIHtcclxuICAgICAgcmV0dXJuIFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfQUNUSVZFX0lURU0sIHRoaXMuX2VsZW1lbnQpO1xyXG4gICAgfVxyXG4gICAgX2dldEl0ZW1zKCkge1xyXG4gICAgICByZXR1cm4gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9JVEVNLCB0aGlzLl9lbGVtZW50KTtcclxuICAgIH1cclxuICAgIF9jbGVhckludGVydmFsKCkge1xyXG4gICAgICBpZiAodGhpcy5faW50ZXJ2YWwpIHtcclxuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKTtcclxuICAgICAgICB0aGlzLl9pbnRlcnZhbCA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIF9kaXJlY3Rpb25Ub09yZGVyKGRpcmVjdGlvbikge1xyXG4gICAgICBpZiAoaXNSVEwoKSkge1xyXG4gICAgICAgIHJldHVybiBkaXJlY3Rpb24gPT09IERJUkVDVElPTl9MRUZUID8gT1JERVJfUFJFViA6IE9SREVSX05FWFQ7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX0xFRlQgPyBPUkRFUl9ORVhUIDogT1JERVJfUFJFVjtcclxuICAgIH1cclxuICAgIF9vcmRlclRvRGlyZWN0aW9uKG9yZGVyKSB7XHJcbiAgICAgIGlmIChpc1JUTCgpKSB7XHJcbiAgICAgICAgcmV0dXJuIG9yZGVyID09PSBPUkRFUl9QUkVWID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG9yZGVyID09PSBPUkRFUl9QUkVWID8gRElSRUNUSU9OX1JJR0hUIDogRElSRUNUSU9OX0xFRlQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU3RhdGljXHJcbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xyXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCBkYXRhID0gQ2Fyb3VzZWwuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgZGF0YS50byhjb25maWcpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgIGlmIChkYXRhW2NvbmZpZ10gPT09IHVuZGVmaW5lZCB8fCBjb25maWcuc3RhcnRzV2l0aCgnXycpIHx8IGNvbmZpZyA9PT0gJ2NvbnN0cnVjdG9yJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZGF0YVtjb25maWddKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXHJcbiAgICovXHJcblxyXG4gIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNSwgU0VMRUNUT1JfREFUQV9TTElERSwgZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICBjb25zdCB0YXJnZXQgPSBTZWxlY3RvckVuZ2luZS5nZXRFbGVtZW50RnJvbVNlbGVjdG9yKHRoaXMpO1xyXG4gICAgaWYgKCF0YXJnZXQgfHwgIXRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9DQVJPVVNFTCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIGNvbnN0IGNhcm91c2VsID0gQ2Fyb3VzZWwuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0YXJnZXQpO1xyXG4gICAgY29uc3Qgc2xpZGVJbmRleCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdkYXRhLWJzLXNsaWRlLXRvJyk7XHJcbiAgICBpZiAoc2xpZGVJbmRleCkge1xyXG4gICAgICBjYXJvdXNlbC50byhzbGlkZUluZGV4KTtcclxuICAgICAgY2Fyb3VzZWwuX21heWJlRW5hYmxlQ3ljbGUoKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKE1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGUodGhpcywgJ3NsaWRlJykgPT09ICduZXh0Jykge1xyXG4gICAgICBjYXJvdXNlbC5uZXh0KCk7XHJcbiAgICAgIGNhcm91c2VsLl9tYXliZUVuYWJsZUN5Y2xlKCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNhcm91c2VsLnByZXYoKTtcclxuICAgIGNhcm91c2VsLl9tYXliZUVuYWJsZUN5Y2xlKCk7XHJcbiAgfSk7XHJcbiAgRXZlbnRIYW5kbGVyLm9uKHdpbmRvdywgRVZFTlRfTE9BRF9EQVRBX0FQSSQzLCAoKSA9PiB7XHJcbiAgICBjb25zdCBjYXJvdXNlbHMgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RBVEFfUklERSk7XHJcbiAgICBmb3IgKGNvbnN0IGNhcm91c2VsIG9mIGNhcm91c2Vscykge1xyXG4gICAgICBDYXJvdXNlbC5nZXRPckNyZWF0ZUluc3RhbmNlKGNhcm91c2VsKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgLyoqXHJcbiAgICogalF1ZXJ5XHJcbiAgICovXHJcblxyXG4gIGRlZmluZUpRdWVyeVBsdWdpbihDYXJvdXNlbCk7XHJcblxyXG4gIC8qKlxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICogQm9vdHN0cmFwIGNvbGxhcHNlLmpzXHJcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKi9cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0YW50c1xyXG4gICAqL1xyXG5cclxuICBjb25zdCBOQU1FJGIgPSAnY29sbGFwc2UnO1xyXG4gIGNvbnN0IERBVEFfS0VZJDcgPSAnYnMuY29sbGFwc2UnO1xyXG4gIGNvbnN0IEVWRU5UX0tFWSQ3ID0gYC4ke0RBVEFfS0VZJDd9YDtcclxuICBjb25zdCBEQVRBX0FQSV9LRVkkNCA9ICcuZGF0YS1hcGknO1xyXG4gIGNvbnN0IEVWRU5UX1NIT1ckNiA9IGBzaG93JHtFVkVOVF9LRVkkN31gO1xyXG4gIGNvbnN0IEVWRU5UX1NIT1dOJDYgPSBgc2hvd24ke0VWRU5UX0tFWSQ3fWA7XHJcbiAgY29uc3QgRVZFTlRfSElERSQ2ID0gYGhpZGUke0VWRU5UX0tFWSQ3fWA7XHJcbiAgY29uc3QgRVZFTlRfSElEREVOJDYgPSBgaGlkZGVuJHtFVkVOVF9LRVkkN31gO1xyXG4gIGNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJJDQgPSBgY2xpY2ske0VWRU5UX0tFWSQ3fSR7REFUQV9BUElfS0VZJDR9YDtcclxuICBjb25zdCBDTEFTU19OQU1FX1NIT1ckNyA9ICdzaG93JztcclxuICBjb25zdCBDTEFTU19OQU1FX0NPTExBUFNFID0gJ2NvbGxhcHNlJztcclxuICBjb25zdCBDTEFTU19OQU1FX0NPTExBUFNJTkcgPSAnY29sbGFwc2luZyc7XHJcbiAgY29uc3QgQ0xBU1NfTkFNRV9DT0xMQVBTRUQgPSAnY29sbGFwc2VkJztcclxuICBjb25zdCBDTEFTU19OQU1FX0RFRVBFUl9DSElMRFJFTiA9IGA6c2NvcGUgLiR7Q0xBU1NfTkFNRV9DT0xMQVBTRX0gLiR7Q0xBU1NfTkFNRV9DT0xMQVBTRX1gO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfSE9SSVpPTlRBTCA9ICdjb2xsYXBzZS1ob3Jpem9udGFsJztcclxuICBjb25zdCBXSURUSCA9ICd3aWR0aCc7XHJcbiAgY29uc3QgSEVJR0hUID0gJ2hlaWdodCc7XHJcbiAgY29uc3QgU0VMRUNUT1JfQUNUSVZFUyA9ICcuY29sbGFwc2Uuc2hvdywgLmNvbGxhcHNlLmNvbGxhcHNpbmcnO1xyXG4gIGNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFJDQgPSAnW2RhdGEtYnMtdG9nZ2xlPVwiY29sbGFwc2VcIl0nO1xyXG4gIGNvbnN0IERlZmF1bHQkYSA9IHtcclxuICAgIHBhcmVudDogbnVsbCxcclxuICAgIHRvZ2dsZTogdHJ1ZVxyXG4gIH07XHJcbiAgY29uc3QgRGVmYXVsdFR5cGUkYSA9IHtcclxuICAgIHBhcmVudDogJyhudWxsfGVsZW1lbnQpJyxcclxuICAgIHRvZ2dsZTogJ2Jvb2xlYW4nXHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxyXG4gICAqL1xyXG5cclxuICBjbGFzcyBDb2xsYXBzZSBleHRlbmRzIEJhc2VDb21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XHJcbiAgICAgIHN1cGVyKGVsZW1lbnQsIGNvbmZpZyk7XHJcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xyXG4gICAgICB0aGlzLl90cmlnZ2VyQXJyYXkgPSBbXTtcclxuICAgICAgY29uc3QgdG9nZ2xlTGlzdCA9IFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfREFUQV9UT0dHTEUkNCk7XHJcbiAgICAgIGZvciAoY29uc3QgZWxlbSBvZiB0b2dnbGVMaXN0KSB7XHJcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBTZWxlY3RvckVuZ2luZS5nZXRTZWxlY3RvckZyb21FbGVtZW50KGVsZW0pO1xyXG4gICAgICAgIGNvbnN0IGZpbHRlckVsZW1lbnQgPSBTZWxlY3RvckVuZ2luZS5maW5kKHNlbGVjdG9yKS5maWx0ZXIoZm91bmRFbGVtZW50ID0+IGZvdW5kRWxlbWVudCA9PT0gdGhpcy5fZWxlbWVudCk7XHJcbiAgICAgICAgaWYgKHNlbGVjdG9yICE9PSBudWxsICYmIGZpbHRlckVsZW1lbnQubGVuZ3RoKSB7XHJcbiAgICAgICAgICB0aGlzLl90cmlnZ2VyQXJyYXkucHVzaChlbGVtKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5faW5pdGlhbGl6ZUNoaWxkcmVuKCk7XHJcbiAgICAgIGlmICghdGhpcy5fY29uZmlnLnBhcmVudCkge1xyXG4gICAgICAgIHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0aGlzLl90cmlnZ2VyQXJyYXksIHRoaXMuX2lzU2hvd24oKSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy50b2dnbGUpIHtcclxuICAgICAgICB0aGlzLnRvZ2dsZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gR2V0dGVyc1xyXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xyXG4gICAgICByZXR1cm4gRGVmYXVsdCRhO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcclxuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJGE7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XHJcbiAgICAgIHJldHVybiBOQU1FJGI7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHVibGljXHJcbiAgICB0b2dnbGUoKSB7XHJcbiAgICAgIGlmICh0aGlzLl9pc1Nob3duKCkpIHtcclxuICAgICAgICB0aGlzLmhpZGUoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLnNob3coKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2hvdygpIHtcclxuICAgICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZyB8fCB0aGlzLl9pc1Nob3duKCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgbGV0IGFjdGl2ZUNoaWxkcmVuID0gW107XHJcblxyXG4gICAgICAvLyBmaW5kIGFjdGl2ZSBjaGlsZHJlblxyXG4gICAgICBpZiAodGhpcy5fY29uZmlnLnBhcmVudCkge1xyXG4gICAgICAgIGFjdGl2ZUNoaWxkcmVuID0gdGhpcy5fZ2V0Rmlyc3RMZXZlbENoaWxkcmVuKFNFTEVDVE9SX0FDVElWRVMpLmZpbHRlcihlbGVtZW50ID0+IGVsZW1lbnQgIT09IHRoaXMuX2VsZW1lbnQpLm1hcChlbGVtZW50ID0+IENvbGxhcHNlLmdldE9yQ3JlYXRlSW5zdGFuY2UoZWxlbWVudCwge1xyXG4gICAgICAgICAgdG9nZ2xlOiBmYWxzZVxyXG4gICAgICAgIH0pKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoYWN0aXZlQ2hpbGRyZW4ubGVuZ3RoICYmIGFjdGl2ZUNoaWxkcmVuWzBdLl9pc1RyYW5zaXRpb25pbmcpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qgc3RhcnRFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1ckNik7XHJcbiAgICAgIGlmIChzdGFydEV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgZm9yIChjb25zdCBhY3RpdmVJbnN0YW5jZSBvZiBhY3RpdmVDaGlsZHJlbikge1xyXG4gICAgICAgIGFjdGl2ZUluc3RhbmNlLmhpZGUoKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBkaW1lbnNpb24gPSB0aGlzLl9nZXREaW1lbnNpb24oKTtcclxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQ09MTEFQU0UpO1xyXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9DT0xMQVBTSU5HKTtcclxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gMDtcclxuICAgICAgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKHRoaXMuX3RyaWdnZXJBcnJheSwgdHJ1ZSk7XHJcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IHRydWU7XHJcbiAgICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0NPTExBUFNJTkcpO1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0NPTExBUFNFLCBDTEFTU19OQU1FX1NIT1ckNyk7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gJyc7XHJcbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPV04kNik7XHJcbiAgICAgIH07XHJcbiAgICAgIGNvbnN0IGNhcGl0YWxpemVkRGltZW5zaW9uID0gZGltZW5zaW9uWzBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoMSk7XHJcbiAgICAgIGNvbnN0IHNjcm9sbFNpemUgPSBgc2Nyb2xsJHtjYXBpdGFsaXplZERpbWVuc2lvbn1gO1xyXG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCB0aGlzLl9lbGVtZW50LCB0cnVlKTtcclxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gYCR7dGhpcy5fZWxlbWVudFtzY3JvbGxTaXplXX1weGA7XHJcbiAgICB9XHJcbiAgICBoaWRlKCkge1xyXG4gICAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8ICF0aGlzLl9pc1Nob3duKCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qgc3RhcnRFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREUkNik7XHJcbiAgICAgIGlmIChzdGFydEV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgZGltZW5zaW9uID0gdGhpcy5fZ2V0RGltZW5zaW9uKCk7XHJcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9IGAke3RoaXMuX2VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbZGltZW5zaW9uXX1weGA7XHJcbiAgICAgIHJlZmxvdyh0aGlzLl9lbGVtZW50KTtcclxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQ09MTEFQU0lORyk7XHJcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0NPTExBUFNFLCBDTEFTU19OQU1FX1NIT1ckNyk7XHJcbiAgICAgIGZvciAoY29uc3QgdHJpZ2dlciBvZiB0aGlzLl90cmlnZ2VyQXJyYXkpIHtcclxuICAgICAgICBjb25zdCBlbGVtZW50ID0gU2VsZWN0b3JFbmdpbmUuZ2V0RWxlbWVudEZyb21TZWxlY3Rvcih0cmlnZ2VyKTtcclxuICAgICAgICBpZiAoZWxlbWVudCAmJiAhdGhpcy5faXNTaG93bihlbGVtZW50KSkge1xyXG4gICAgICAgICAgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKFt0cmlnZ2VyXSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSB0cnVlO1xyXG4gICAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcclxuICAgICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9DT0xMQVBTSU5HKTtcclxuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9DT0xMQVBTRSk7XHJcbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElEREVOJDYpO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSAnJztcclxuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgdGhpcy5fZWxlbWVudCwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBfaXNTaG93bihlbGVtZW50ID0gdGhpcy5fZWxlbWVudCkge1xyXG4gICAgICByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XJDcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFByaXZhdGVcclxuICAgIF9jb25maWdBZnRlck1lcmdlKGNvbmZpZykge1xyXG4gICAgICBjb25maWcudG9nZ2xlID0gQm9vbGVhbihjb25maWcudG9nZ2xlKTsgLy8gQ29lcmNlIHN0cmluZyB2YWx1ZXNcclxuICAgICAgY29uZmlnLnBhcmVudCA9IGdldEVsZW1lbnQoY29uZmlnLnBhcmVudCk7XHJcbiAgICAgIHJldHVybiBjb25maWc7XHJcbiAgICB9XHJcbiAgICBfZ2V0RGltZW5zaW9uKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9IT1JJWk9OVEFMKSA/IFdJRFRIIDogSEVJR0hUO1xyXG4gICAgfVxyXG4gICAgX2luaXRpYWxpemVDaGlsZHJlbigpIHtcclxuICAgICAgaWYgKCF0aGlzLl9jb25maWcucGFyZW50KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5fZ2V0Rmlyc3RMZXZlbENoaWxkcmVuKFNFTEVDVE9SX0RBVEFfVE9HR0xFJDQpO1xyXG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgY2hpbGRyZW4pIHtcclxuICAgICAgICBjb25zdCBzZWxlY3RlZCA9IFNlbGVjdG9yRW5naW5lLmdldEVsZW1lbnRGcm9tU2VsZWN0b3IoZWxlbWVudCk7XHJcbiAgICAgICAgaWYgKHNlbGVjdGVkKSB7XHJcbiAgICAgICAgICB0aGlzLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MoW2VsZW1lbnRdLCB0aGlzLl9pc1Nob3duKHNlbGVjdGVkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBfZ2V0Rmlyc3RMZXZlbENoaWxkcmVuKHNlbGVjdG9yKSB7XHJcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gU2VsZWN0b3JFbmdpbmUuZmluZChDTEFTU19OQU1FX0RFRVBFUl9DSElMRFJFTiwgdGhpcy5fY29uZmlnLnBhcmVudCk7XHJcbiAgICAgIC8vIHJlbW92ZSBjaGlsZHJlbiBpZiBncmVhdGVyIGRlcHRoXHJcbiAgICAgIHJldHVybiBTZWxlY3RvckVuZ2luZS5maW5kKHNlbGVjdG9yLCB0aGlzLl9jb25maWcucGFyZW50KS5maWx0ZXIoZWxlbWVudCA9PiAhY2hpbGRyZW4uaW5jbHVkZXMoZWxlbWVudCkpO1xyXG4gICAgfVxyXG4gICAgX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0cmlnZ2VyQXJyYXksIGlzT3Blbikge1xyXG4gICAgICBpZiAoIXRyaWdnZXJBcnJheS5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRyaWdnZXJBcnJheSkge1xyXG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShDTEFTU19OQU1FX0NPTExBUFNFRCwgIWlzT3Blbik7XHJcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCBpc09wZW4pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU3RhdGljXHJcbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xyXG4gICAgICBjb25zdCBfY29uZmlnID0ge307XHJcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJyAmJiAvc2hvd3xoaWRlLy50ZXN0KGNvbmZpZykpIHtcclxuICAgICAgICBfY29uZmlnLnRvZ2dsZSA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBDb2xsYXBzZS5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIF9jb25maWcpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBkYXRhW2NvbmZpZ10oKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cclxuICAgKi9cclxuXHJcbiAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQ0LCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ0LCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgIC8vIHByZXZlbnREZWZhdWx0IG9ubHkgZm9yIDxhPiBlbGVtZW50cyAod2hpY2ggY2hhbmdlIHRoZSBVUkwpIG5vdCBpbnNpZGUgdGhlIGNvbGxhcHNpYmxlIGVsZW1lbnRcclxuICAgIGlmIChldmVudC50YXJnZXQudGFnTmFtZSA9PT0gJ0EnIHx8IGV2ZW50LmRlbGVnYXRlVGFyZ2V0ICYmIGV2ZW50LmRlbGVnYXRlVGFyZ2V0LnRhZ05hbWUgPT09ICdBJykge1xyXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIFNlbGVjdG9yRW5naW5lLmdldE11bHRpcGxlRWxlbWVudHNGcm9tU2VsZWN0b3IodGhpcykpIHtcclxuICAgICAgQ29sbGFwc2UuZ2V0T3JDcmVhdGVJbnN0YW5jZShlbGVtZW50LCB7XHJcbiAgICAgICAgdG9nZ2xlOiBmYWxzZVxyXG4gICAgICB9KS50b2dnbGUoKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgLyoqXHJcbiAgICogalF1ZXJ5XHJcbiAgICovXHJcblxyXG4gIGRlZmluZUpRdWVyeVBsdWdpbihDb2xsYXBzZSk7XHJcblxyXG4gIHZhciB0b3AgPSAndG9wJztcclxuICB2YXIgYm90dG9tID0gJ2JvdHRvbSc7XHJcbiAgdmFyIHJpZ2h0ID0gJ3JpZ2h0JztcclxuICB2YXIgbGVmdCA9ICdsZWZ0JztcclxuICB2YXIgYXV0byA9ICdhdXRvJztcclxuICB2YXIgYmFzZVBsYWNlbWVudHMgPSBbdG9wLCBib3R0b20sIHJpZ2h0LCBsZWZ0XTtcclxuICB2YXIgc3RhcnQgPSAnc3RhcnQnO1xyXG4gIHZhciBlbmQgPSAnZW5kJztcclxuICB2YXIgY2xpcHBpbmdQYXJlbnRzID0gJ2NsaXBwaW5nUGFyZW50cyc7XHJcbiAgdmFyIHZpZXdwb3J0ID0gJ3ZpZXdwb3J0JztcclxuICB2YXIgcG9wcGVyID0gJ3BvcHBlcic7XHJcbiAgdmFyIHJlZmVyZW5jZSA9ICdyZWZlcmVuY2UnO1xyXG4gIHZhciB2YXJpYXRpb25QbGFjZW1lbnRzID0gLyojX19QVVJFX18qL2Jhc2VQbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcclxuICAgIHJldHVybiBhY2MuY29uY2F0KFtwbGFjZW1lbnQgKyBcIi1cIiArIHN0YXJ0LCBwbGFjZW1lbnQgKyBcIi1cIiArIGVuZF0pO1xyXG4gIH0sIFtdKTtcclxuICB2YXIgcGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9bXS5jb25jYXQoYmFzZVBsYWNlbWVudHMsIFthdXRvXSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xyXG4gICAgcmV0dXJuIGFjYy5jb25jYXQoW3BsYWNlbWVudCwgcGxhY2VtZW50ICsgXCItXCIgKyBzdGFydCwgcGxhY2VtZW50ICsgXCItXCIgKyBlbmRdKTtcclxuICB9LCBbXSk7IC8vIG1vZGlmaWVycyB0aGF0IG5lZWQgdG8gcmVhZCB0aGUgRE9NXHJcblxyXG4gIHZhciBiZWZvcmVSZWFkID0gJ2JlZm9yZVJlYWQnO1xyXG4gIHZhciByZWFkID0gJ3JlYWQnO1xyXG4gIHZhciBhZnRlclJlYWQgPSAnYWZ0ZXJSZWFkJzsgLy8gcHVyZS1sb2dpYyBtb2RpZmllcnNcclxuXHJcbiAgdmFyIGJlZm9yZU1haW4gPSAnYmVmb3JlTWFpbic7XHJcbiAgdmFyIG1haW4gPSAnbWFpbic7XHJcbiAgdmFyIGFmdGVyTWFpbiA9ICdhZnRlck1haW4nOyAvLyBtb2RpZmllciB3aXRoIHRoZSBwdXJwb3NlIHRvIHdyaXRlIHRvIHRoZSBET00gKG9yIHdyaXRlIGludG8gYSBmcmFtZXdvcmsgc3RhdGUpXHJcblxyXG4gIHZhciBiZWZvcmVXcml0ZSA9ICdiZWZvcmVXcml0ZSc7XHJcbiAgdmFyIHdyaXRlID0gJ3dyaXRlJztcclxuICB2YXIgYWZ0ZXJXcml0ZSA9ICdhZnRlcldyaXRlJztcclxuICB2YXIgbW9kaWZpZXJQaGFzZXMgPSBbYmVmb3JlUmVhZCwgcmVhZCwgYWZ0ZXJSZWFkLCBiZWZvcmVNYWluLCBtYWluLCBhZnRlck1haW4sIGJlZm9yZVdyaXRlLCB3cml0ZSwgYWZ0ZXJXcml0ZV07XHJcblxyXG4gIGZ1bmN0aW9uIGdldE5vZGVOYW1lKGVsZW1lbnQpIHtcclxuICAgIHJldHVybiBlbGVtZW50ID8gKGVsZW1lbnQubm9kZU5hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcclxuICAgIGlmIChub2RlID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIHdpbmRvdztcclxuICAgIH1cclxuXHJcbiAgICBpZiAobm9kZS50b1N0cmluZygpICE9PSAnW29iamVjdCBXaW5kb3ddJykge1xyXG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9IG5vZGUub3duZXJEb2N1bWVudDtcclxuICAgICAgcmV0dXJuIG93bmVyRG9jdW1lbnQgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdyA6IHdpbmRvdztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbm9kZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGlzRWxlbWVudChub2RlKSB7XHJcbiAgICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5FbGVtZW50O1xyXG4gICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaXNIVE1MRWxlbWVudChub2RlKSB7XHJcbiAgICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5IVE1MRWxlbWVudDtcclxuICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpc1NoYWRvd1Jvb3Qobm9kZSkge1xyXG4gICAgLy8gSUUgMTEgaGFzIG5vIFNoYWRvd1Jvb3RcclxuICAgIGlmICh0eXBlb2YgU2hhZG93Um9vdCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLlNoYWRvd1Jvb3Q7XHJcbiAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3Q7XHJcbiAgfVxyXG5cclxuICAvLyBhbmQgYXBwbGllcyB0aGVtIHRvIHRoZSBIVE1MRWxlbWVudHMgc3VjaCBhcyBwb3BwZXIgYW5kIGFycm93XHJcblxyXG4gIGZ1bmN0aW9uIGFwcGx5U3R5bGVzKF9yZWYpIHtcclxuICAgIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGU7XHJcbiAgICBPYmplY3Qua2V5cyhzdGF0ZS5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICB2YXIgc3R5bGUgPSBzdGF0ZS5zdHlsZXNbbmFtZV0gfHwge307XHJcbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gc3RhdGUuYXR0cmlidXRlc1tuYW1lXSB8fCB7fTtcclxuICAgICAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1tuYW1lXTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXHJcblxyXG4gICAgICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgIWdldE5vZGVOYW1lKGVsZW1lbnQpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9IC8vIEZsb3cgZG9lc24ndCBzdXBwb3J0IHRvIGV4dGVuZCB0aGlzIHByb3BlcnR5LCBidXQgaXQncyB0aGUgbW9zdFxyXG4gICAgICAvLyBlZmZlY3RpdmUgd2F5IHRvIGFwcGx5IHN0eWxlcyB0byBhbiBIVE1MRWxlbWVudFxyXG4gICAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cclxuXHJcblxyXG4gICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcclxuICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNbbmFtZV07XHJcblxyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSA9PT0gdHJ1ZSA/ICcnIDogdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGVmZmVjdCQyKF9yZWYyKSB7XHJcbiAgICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZTtcclxuICAgIHZhciBpbml0aWFsU3R5bGVzID0ge1xyXG4gICAgICBwb3BwZXI6IHtcclxuICAgICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcclxuICAgICAgICBsZWZ0OiAnMCcsXHJcbiAgICAgICAgdG9wOiAnMCcsXHJcbiAgICAgICAgbWFyZ2luOiAnMCdcclxuICAgICAgfSxcclxuICAgICAgYXJyb3c6IHtcclxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xyXG4gICAgICB9LFxyXG4gICAgICByZWZlcmVuY2U6IHt9XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5wb3BwZXIuc3R5bGUsIGluaXRpYWxTdHlsZXMucG9wcGVyKTtcclxuICAgIHN0YXRlLnN0eWxlcyA9IGluaXRpYWxTdHlsZXM7XHJcblxyXG4gICAgaWYgKHN0YXRlLmVsZW1lbnRzLmFycm93KSB7XHJcbiAgICAgIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMuYXJyb3cuc3R5bGUsIGluaXRpYWxTdHlsZXMuYXJyb3cpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1tuYW1lXTtcclxuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XHJcbiAgICAgICAgdmFyIHN0eWxlUHJvcGVydGllcyA9IE9iamVjdC5rZXlzKHN0YXRlLnN0eWxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHN0YXRlLnN0eWxlc1tuYW1lXSA6IGluaXRpYWxTdHlsZXNbbmFtZV0pOyAvLyBTZXQgYWxsIHZhbHVlcyB0byBhbiBlbXB0eSBzdHJpbmcgdG8gdW5zZXQgdGhlbVxyXG5cclxuICAgICAgICB2YXIgc3R5bGUgPSBzdHlsZVByb3BlcnRpZXMucmVkdWNlKGZ1bmN0aW9uIChzdHlsZSwgcHJvcGVydHkpIHtcclxuICAgICAgICAgIHN0eWxlW3Byb3BlcnR5XSA9ICcnO1xyXG4gICAgICAgICAgcmV0dXJuIHN0eWxlO1xyXG4gICAgICAgIH0sIHt9KTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXHJcblxyXG4gICAgICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xyXG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xyXG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xyXG5cclxuXHJcbiAgY29uc3QgYXBwbHlTdHlsZXMkMSA9IHtcclxuICAgIG5hbWU6ICdhcHBseVN0eWxlcycsXHJcbiAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgcGhhc2U6ICd3cml0ZScsXHJcbiAgICBmbjogYXBwbHlTdHlsZXMsXHJcbiAgICBlZmZlY3Q6IGVmZmVjdCQyLFxyXG4gICAgcmVxdWlyZXM6IFsnY29tcHV0ZVN0eWxlcyddXHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcclxuICAgIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcclxuICB9XHJcblxyXG4gIHZhciBtYXggPSBNYXRoLm1heDtcclxuICB2YXIgbWluID0gTWF0aC5taW47XHJcbiAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcclxuXHJcbiAgZnVuY3Rpb24gZ2V0VUFTdHJpbmcoKSB7XHJcbiAgICB2YXIgdWFEYXRhID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGE7XHJcblxyXG4gICAgaWYgKHVhRGF0YSAhPSBudWxsICYmIHVhRGF0YS5icmFuZHMgJiYgQXJyYXkuaXNBcnJheSh1YURhdGEuYnJhbmRzKSkge1xyXG4gICAgICByZXR1cm4gdWFEYXRhLmJyYW5kcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICByZXR1cm4gaXRlbS5icmFuZCArIFwiL1wiICsgaXRlbS52ZXJzaW9uO1xyXG4gICAgICB9KS5qb2luKCcgJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpc0xheW91dFZpZXdwb3J0KCkge1xyXG4gICAgcmV0dXJuICEvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KGdldFVBU3RyaW5nKCkpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIGluY2x1ZGVTY2FsZSwgaXNGaXhlZFN0cmF0ZWd5KSB7XHJcbiAgICBpZiAoaW5jbHVkZVNjYWxlID09PSB2b2lkIDApIHtcclxuICAgICAgaW5jbHVkZVNjYWxlID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzRml4ZWRTdHJhdGVneSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgIGlzRml4ZWRTdHJhdGVneSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjbGllbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIHZhciBzY2FsZVggPSAxO1xyXG4gICAgdmFyIHNjYWxlWSA9IDE7XHJcblxyXG4gICAgaWYgKGluY2x1ZGVTY2FsZSAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XHJcbiAgICAgIHNjYWxlWCA9IGVsZW1lbnQub2Zmc2V0V2lkdGggPiAwID8gcm91bmQoY2xpZW50UmVjdC53aWR0aCkgLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDEgOiAxO1xyXG4gICAgICBzY2FsZVkgPSBlbGVtZW50Lm9mZnNldEhlaWdodCA+IDAgPyByb3VuZChjbGllbnRSZWN0LmhlaWdodCkgLyBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAxIDogMTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgX3JlZiA9IGlzRWxlbWVudChlbGVtZW50KSA/IGdldFdpbmRvdyhlbGVtZW50KSA6IHdpbmRvdyxcclxuICAgICAgICB2aXN1YWxWaWV3cG9ydCA9IF9yZWYudmlzdWFsVmlld3BvcnQ7XHJcblxyXG4gICAgdmFyIGFkZFZpc3VhbE9mZnNldHMgPSAhaXNMYXlvdXRWaWV3cG9ydCgpICYmIGlzRml4ZWRTdHJhdGVneTtcclxuICAgIHZhciB4ID0gKGNsaWVudFJlY3QubGVmdCArIChhZGRWaXN1YWxPZmZzZXRzICYmIHZpc3VhbFZpZXdwb3J0ID8gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdCA6IDApKSAvIHNjYWxlWDtcclxuICAgIHZhciB5ID0gKGNsaWVudFJlY3QudG9wICsgKGFkZFZpc3VhbE9mZnNldHMgJiYgdmlzdWFsVmlld3BvcnQgPyB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3AgOiAwKSkgLyBzY2FsZVk7XHJcbiAgICB2YXIgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoIC8gc2NhbGVYO1xyXG4gICAgdmFyIGhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0IC8gc2NhbGVZO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcclxuICAgICAgdG9wOiB5LFxyXG4gICAgICByaWdodDogeCArIHdpZHRoLFxyXG4gICAgICBib3R0b206IHkgKyBoZWlnaHQsXHJcbiAgICAgIGxlZnQ6IHgsXHJcbiAgICAgIHg6IHgsXHJcbiAgICAgIHk6IHlcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBtZWFucyBpdCBkb2Vzbid0IHRha2UgaW50byBhY2NvdW50IHRyYW5zZm9ybXMuXHJcblxyXG4gIGZ1bmN0aW9uIGdldExheW91dFJlY3QoZWxlbWVudCkge1xyXG4gICAgdmFyIGNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCk7IC8vIFVzZSB0aGUgY2xpZW50UmVjdCBzaXplcyBpZiBpdCdzIG5vdCBiZWVuIHRyYW5zZm9ybWVkLlxyXG4gICAgLy8gRml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy8xMjIzXHJcblxyXG4gICAgdmFyIHdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcclxuICAgIHZhciBoZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcclxuXHJcbiAgICBpZiAoTWF0aC5hYnMoY2xpZW50UmVjdC53aWR0aCAtIHdpZHRoKSA8PSAxKSB7XHJcbiAgICAgIHdpZHRoID0gY2xpZW50UmVjdC53aWR0aDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoTWF0aC5hYnMoY2xpZW50UmVjdC5oZWlnaHQgLSBoZWlnaHQpIDw9IDEpIHtcclxuICAgICAgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgeDogZWxlbWVudC5vZmZzZXRMZWZ0LFxyXG4gICAgICB5OiBlbGVtZW50Lm9mZnNldFRvcCxcclxuICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICBoZWlnaHQ6IGhlaWdodFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNvbnRhaW5zKHBhcmVudCwgY2hpbGQpIHtcclxuICAgIHZhciByb290Tm9kZSA9IGNoaWxkLmdldFJvb3ROb2RlICYmIGNoaWxkLmdldFJvb3ROb2RlKCk7IC8vIEZpcnN0LCBhdHRlbXB0IHdpdGggZmFzdGVyIG5hdGl2ZSBtZXRob2RcclxuXHJcbiAgICBpZiAocGFyZW50LmNvbnRhaW5zKGNoaWxkKSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0gLy8gdGhlbiBmYWxsYmFjayB0byBjdXN0b20gaW1wbGVtZW50YXRpb24gd2l0aCBTaGFkb3cgRE9NIHN1cHBvcnRcclxuICAgIGVsc2UgaWYgKHJvb3ROb2RlICYmIGlzU2hhZG93Um9vdChyb290Tm9kZSkpIHtcclxuICAgICAgICB2YXIgbmV4dCA9IGNoaWxkO1xyXG5cclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICBpZiAobmV4dCAmJiBwYXJlbnQuaXNTYW1lTm9kZShuZXh0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddOiBuZWVkIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcy4uLlxyXG5cclxuXHJcbiAgICAgICAgICBuZXh0ID0gbmV4dC5wYXJlbnROb2RlIHx8IG5leHQuaG9zdDtcclxuICAgICAgICB9IHdoaWxlIChuZXh0KTtcclxuICAgICAgfSAvLyBHaXZlIHVwLCB0aGUgcmVzdWx0IGlzIGZhbHNlXHJcblxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUkMShlbGVtZW50KSB7XHJcbiAgICByZXR1cm4gZ2V0V2luZG93KGVsZW1lbnQpLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpc1RhYmxlRWxlbWVudChlbGVtZW50KSB7XHJcbiAgICByZXR1cm4gWyd0YWJsZScsICd0ZCcsICd0aCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUoZWxlbWVudCkpID49IDA7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkge1xyXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogYXNzdW1lIGJvZHkgaXMgYWx3YXlzIGF2YWlsYWJsZVxyXG4gICAgcmV0dXJuICgoaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudC5vd25lckRvY3VtZW50IDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXHJcbiAgICBlbGVtZW50LmRvY3VtZW50KSB8fCB3aW5kb3cuZG9jdW1lbnQpLmRvY3VtZW50RWxlbWVudDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldFBhcmVudE5vZGUoZWxlbWVudCkge1xyXG4gICAgaWYgKGdldE5vZGVOYW1lKGVsZW1lbnQpID09PSAnaHRtbCcpIHtcclxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICgvLyB0aGlzIGlzIGEgcXVpY2tlciAoYnV0IGxlc3MgdHlwZSBzYWZlKSB3YXkgdG8gc2F2ZSBxdWl0ZSBzb21lIGJ5dGVzIGZyb20gdGhlIGJ1bmRsZVxyXG4gICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXHJcbiAgICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxyXG4gICAgICBlbGVtZW50LmFzc2lnbmVkU2xvdCB8fCAvLyBzdGVwIGludG8gdGhlIHNoYWRvdyBET00gb2YgdGhlIHBhcmVudCBvZiBhIHNsb3R0ZWQgbm9kZVxyXG4gICAgICBlbGVtZW50LnBhcmVudE5vZGUgfHwgKCAvLyBET00gRWxlbWVudCBkZXRlY3RlZFxyXG4gICAgICBpc1NoYWRvd1Jvb3QoZWxlbWVudCkgPyBlbGVtZW50Lmhvc3QgOiBudWxsKSB8fCAvLyBTaGFkb3dSb290IGRldGVjdGVkXHJcbiAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBIVE1MRWxlbWVudCBpcyBhIE5vZGVcclxuICAgICAgZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpIC8vIGZhbGxiYWNrXHJcblxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xyXG4gICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvODM3XHJcbiAgICBnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCkucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVsZW1lbnQub2Zmc2V0UGFyZW50O1xyXG4gIH0gLy8gYC5vZmZzZXRQYXJlbnRgIHJlcG9ydHMgYG51bGxgIGZvciBmaXhlZCBlbGVtZW50cywgd2hpbGUgYWJzb2x1dGUgZWxlbWVudHNcclxuICAvLyByZXR1cm4gdGhlIGNvbnRhaW5pbmcgYmxvY2tcclxuXHJcblxyXG4gIGZ1bmN0aW9uIGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB7XHJcbiAgICB2YXIgaXNGaXJlZm94ID0gL2ZpcmVmb3gvaS50ZXN0KGdldFVBU3RyaW5nKCkpO1xyXG4gICAgdmFyIGlzSUUgPSAvVHJpZGVudC9pLnRlc3QoZ2V0VUFTdHJpbmcoKSk7XHJcblxyXG4gICAgaWYgKGlzSUUgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xyXG4gICAgICAvLyBJbiBJRSA5LCAxMCBhbmQgMTEgZml4ZWQgZWxlbWVudHMgY29udGFpbmluZyBibG9jayBpcyBhbHdheXMgZXN0YWJsaXNoZWQgYnkgdGhlIHZpZXdwb3J0XHJcbiAgICAgIHZhciBlbGVtZW50Q3NzID0gZ2V0Q29tcHV0ZWRTdHlsZSQxKGVsZW1lbnQpO1xyXG5cclxuICAgICAgaWYgKGVsZW1lbnRDc3MucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XHJcblxyXG4gICAgaWYgKGlzU2hhZG93Um9vdChjdXJyZW50Tm9kZSkpIHtcclxuICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5ob3N0O1xyXG4gICAgfVxyXG5cclxuICAgIHdoaWxlIChpc0hUTUxFbGVtZW50KGN1cnJlbnROb2RlKSAmJiBbJ2h0bWwnLCAnYm9keSddLmluZGV4T2YoZ2V0Tm9kZU5hbWUoY3VycmVudE5vZGUpKSA8IDApIHtcclxuICAgICAgdmFyIGNzcyA9IGdldENvbXB1dGVkU3R5bGUkMShjdXJyZW50Tm9kZSk7IC8vIFRoaXMgaXMgbm9uLWV4aGF1c3RpdmUgYnV0IGNvdmVycyB0aGUgbW9zdCBjb21tb24gQ1NTIHByb3BlcnRpZXMgdGhhdFxyXG4gICAgICAvLyBjcmVhdGUgYSBjb250YWluaW5nIGJsb2NrLlxyXG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ29udGFpbmluZ19ibG9jayNpZGVudGlmeWluZ190aGVfY29udGFpbmluZ19ibG9ja1xyXG5cclxuICAgICAgaWYgKGNzcy50cmFuc2Zvcm0gIT09ICdub25lJyB8fCBjc3MucGVyc3BlY3RpdmUgIT09ICdub25lJyB8fCBjc3MuY29udGFpbiA9PT0gJ3BhaW50JyB8fCBbJ3RyYW5zZm9ybScsICdwZXJzcGVjdGl2ZSddLmluZGV4T2YoY3NzLndpbGxDaGFuZ2UpICE9PSAtMSB8fCBpc0ZpcmVmb3ggJiYgY3NzLndpbGxDaGFuZ2UgPT09ICdmaWx0ZXInIHx8IGlzRmlyZWZveCAmJiBjc3MuZmlsdGVyICYmIGNzcy5maWx0ZXIgIT09ICdub25lJykge1xyXG4gICAgICAgIHJldHVybiBjdXJyZW50Tm9kZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9IC8vIEdldHMgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgcG9zaXRpb25lZCBlbGVtZW50LiBIYW5kbGVzIHNvbWUgZWRnZSBjYXNlcyxcclxuICAvLyBzdWNoIGFzIHRhYmxlIGFuY2VzdG9ycyBhbmQgY3Jvc3MgYnJvd3NlciBidWdzLlxyXG5cclxuXHJcbiAgZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcclxuICAgIHZhciB3aW5kb3cgPSBnZXRXaW5kb3coZWxlbWVudCk7XHJcbiAgICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KTtcclxuXHJcbiAgICB3aGlsZSAob2Zmc2V0UGFyZW50ICYmIGlzVGFibGVFbGVtZW50KG9mZnNldFBhcmVudCkgJiYgZ2V0Q29tcHV0ZWRTdHlsZSQxKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XHJcbiAgICAgIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQob2Zmc2V0UGFyZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAob2Zmc2V0UGFyZW50ICYmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnaHRtbCcgfHwgZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2JvZHknICYmIGdldENvbXB1dGVkU3R5bGUkMShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJykpIHtcclxuICAgICAgcmV0dXJuIHdpbmRvdztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB8fCB3aW5kb3c7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQocGxhY2VtZW50KSB7XHJcbiAgICByZXR1cm4gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpID49IDAgPyAneCcgOiAneSc7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB3aXRoaW4obWluJDEsIHZhbHVlLCBtYXgkMSkge1xyXG4gICAgcmV0dXJuIG1heChtaW4kMSwgbWluKHZhbHVlLCBtYXgkMSkpO1xyXG4gIH1cclxuICBmdW5jdGlvbiB3aXRoaW5NYXhDbGFtcChtaW4sIHZhbHVlLCBtYXgpIHtcclxuICAgIHZhciB2ID0gd2l0aGluKG1pbiwgdmFsdWUsIG1heCk7XHJcbiAgICByZXR1cm4gdiA+IG1heCA/IG1heCA6IHY7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRGcmVzaFNpZGVPYmplY3QoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0b3A6IDAsXHJcbiAgICAgIHJpZ2h0OiAwLFxyXG4gICAgICBib3R0b206IDAsXHJcbiAgICAgIGxlZnQ6IDBcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBtZXJnZVBhZGRpbmdPYmplY3QocGFkZGluZ09iamVjdCkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGdldEZyZXNoU2lkZU9iamVjdCgpLCBwYWRkaW5nT2JqZWN0KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGV4cGFuZFRvSGFzaE1hcCh2YWx1ZSwga2V5cykge1xyXG4gICAgcmV0dXJuIGtleXMucmVkdWNlKGZ1bmN0aW9uIChoYXNoTWFwLCBrZXkpIHtcclxuICAgICAgaGFzaE1hcFtrZXldID0gdmFsdWU7XHJcbiAgICAgIHJldHVybiBoYXNoTWFwO1xyXG4gICAgfSwge30pO1xyXG4gIH1cclxuXHJcbiAgdmFyIHRvUGFkZGluZ09iamVjdCA9IGZ1bmN0aW9uIHRvUGFkZGluZ09iamVjdChwYWRkaW5nLCBzdGF0ZSkge1xyXG4gICAgcGFkZGluZyA9IHR5cGVvZiBwYWRkaW5nID09PSAnZnVuY3Rpb24nID8gcGFkZGluZyhPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5yZWN0cywge1xyXG4gICAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxyXG4gICAgfSkpIDogcGFkZGluZztcclxuICAgIHJldHVybiBtZXJnZVBhZGRpbmdPYmplY3QodHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gcGFkZGluZyA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cykpO1xyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIGFycm93KF9yZWYpIHtcclxuICAgIHZhciBfc3RhdGUkbW9kaWZpZXJzRGF0YSQ7XHJcblxyXG4gICAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcclxuICAgICAgICBuYW1lID0gX3JlZi5uYW1lLFxyXG4gICAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XHJcbiAgICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XHJcbiAgICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cztcclxuICAgIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xyXG4gICAgdmFyIGF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCk7XHJcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFtsZWZ0LCByaWdodF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwO1xyXG4gICAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XHJcblxyXG4gICAgaWYgKCFhcnJvd0VsZW1lbnQgfHwgIXBvcHBlck9mZnNldHMpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBwYWRkaW5nT2JqZWN0ID0gdG9QYWRkaW5nT2JqZWN0KG9wdGlvbnMucGFkZGluZywgc3RhdGUpO1xyXG4gICAgdmFyIGFycm93UmVjdCA9IGdldExheW91dFJlY3QoYXJyb3dFbGVtZW50KTtcclxuICAgIHZhciBtaW5Qcm9wID0gYXhpcyA9PT0gJ3knID8gdG9wIDogbGVmdDtcclxuICAgIHZhciBtYXhQcm9wID0gYXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XHJcbiAgICB2YXIgZW5kRGlmZiA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtsZW5dICsgc3RhdGUucmVjdHMucmVmZXJlbmNlW2F4aXNdIC0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnBvcHBlcltsZW5dO1xyXG4gICAgdmFyIHN0YXJ0RGlmZiA9IHBvcHBlck9mZnNldHNbYXhpc10gLSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbYXhpc107XHJcbiAgICB2YXIgYXJyb3dPZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQoYXJyb3dFbGVtZW50KTtcclxuICAgIHZhciBjbGllbnRTaXplID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBheGlzID09PSAneScgPyBhcnJvd09mZnNldFBhcmVudC5jbGllbnRIZWlnaHQgfHwgMCA6IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudFdpZHRoIHx8IDAgOiAwO1xyXG4gICAgdmFyIGNlbnRlclRvUmVmZXJlbmNlID0gZW5kRGlmZiAvIDIgLSBzdGFydERpZmYgLyAyOyAvLyBNYWtlIHN1cmUgdGhlIGFycm93IGRvZXNuJ3Qgb3ZlcmZsb3cgdGhlIHBvcHBlciBpZiB0aGUgY2VudGVyIHBvaW50IGlzXHJcbiAgICAvLyBvdXRzaWRlIG9mIHRoZSBwb3BwZXIgYm91bmRzXHJcblxyXG4gICAgdmFyIG1pbiA9IHBhZGRpbmdPYmplY3RbbWluUHJvcF07XHJcbiAgICB2YXIgbWF4ID0gY2xpZW50U2l6ZSAtIGFycm93UmVjdFtsZW5dIC0gcGFkZGluZ09iamVjdFttYXhQcm9wXTtcclxuICAgIHZhciBjZW50ZXIgPSBjbGllbnRTaXplIC8gMiAtIGFycm93UmVjdFtsZW5dIC8gMiArIGNlbnRlclRvUmVmZXJlbmNlO1xyXG4gICAgdmFyIG9mZnNldCA9IHdpdGhpbihtaW4sIGNlbnRlciwgbWF4KTsgLy8gUHJldmVudHMgYnJlYWtpbmcgc3ludGF4IGhpZ2hsaWdodGluZy4uLlxyXG5cclxuICAgIHZhciBheGlzUHJvcCA9IGF4aXM7XHJcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gKF9zdGF0ZSRtb2RpZmllcnNEYXRhJCA9IHt9LCBfc3RhdGUkbW9kaWZpZXJzRGF0YSRbYXhpc1Byb3BdID0gb2Zmc2V0LCBfc3RhdGUkbW9kaWZpZXJzRGF0YSQuY2VudGVyT2Zmc2V0ID0gb2Zmc2V0IC0gY2VudGVyLCBfc3RhdGUkbW9kaWZpZXJzRGF0YSQpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZWZmZWN0JDEoX3JlZjIpIHtcclxuICAgIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlLFxyXG4gICAgICAgIG9wdGlvbnMgPSBfcmVmMi5vcHRpb25zO1xyXG4gICAgdmFyIF9vcHRpb25zJGVsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQsXHJcbiAgICAgICAgYXJyb3dFbGVtZW50ID0gX29wdGlvbnMkZWxlbWVudCA9PT0gdm9pZCAwID8gJ1tkYXRhLXBvcHBlci1hcnJvd10nIDogX29wdGlvbnMkZWxlbWVudDtcclxuXHJcbiAgICBpZiAoYXJyb3dFbGVtZW50ID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfSAvLyBDU1Mgc2VsZWN0b3JcclxuXHJcblxyXG4gICAgaWYgKHR5cGVvZiBhcnJvd0VsZW1lbnQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLnBvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93RWxlbWVudCk7XHJcblxyXG4gICAgICBpZiAoIWFycm93RWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICghY29udGFpbnMoc3RhdGUuZWxlbWVudHMucG9wcGVyLCBhcnJvd0VsZW1lbnQpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0ZS5lbGVtZW50cy5hcnJvdyA9IGFycm93RWxlbWVudDtcclxuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcclxuXHJcblxyXG4gIGNvbnN0IGFycm93JDEgPSB7XHJcbiAgICBuYW1lOiAnYXJyb3cnLFxyXG4gICAgZW5hYmxlZDogdHJ1ZSxcclxuICAgIHBoYXNlOiAnbWFpbicsXHJcbiAgICBmbjogYXJyb3csXHJcbiAgICBlZmZlY3Q6IGVmZmVjdCQxLFxyXG4gICAgcmVxdWlyZXM6IFsncG9wcGVyT2Zmc2V0cyddLFxyXG4gICAgcmVxdWlyZXNJZkV4aXN0czogWydwcmV2ZW50T3ZlcmZsb3cnXVxyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIGdldFZhcmlhdGlvbihwbGFjZW1lbnQpIHtcclxuICAgIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcclxuICB9XHJcblxyXG4gIHZhciB1bnNldFNpZGVzID0ge1xyXG4gICAgdG9wOiAnYXV0bycsXHJcbiAgICByaWdodDogJ2F1dG8nLFxyXG4gICAgYm90dG9tOiAnYXV0bycsXHJcbiAgICBsZWZ0OiAnYXV0bydcclxuICB9OyAvLyBSb3VuZCB0aGUgb2Zmc2V0cyB0byB0aGUgbmVhcmVzdCBzdWl0YWJsZSBzdWJwaXhlbCBiYXNlZCBvbiB0aGUgRFBSLlxyXG4gIC8vIFpvb21pbmcgY2FuIGNoYW5nZSB0aGUgRFBSLCBidXQgaXQgc2VlbXMgdG8gcmVwb3J0IGEgdmFsdWUgdGhhdCB3aWxsXHJcbiAgLy8gY2xlYW5seSBkaXZpZGUgdGhlIHZhbHVlcyBpbnRvIHRoZSBhcHByb3ByaWF0ZSBzdWJwaXhlbHMuXHJcblxyXG4gIGZ1bmN0aW9uIHJvdW5kT2Zmc2V0c0J5RFBSKF9yZWYsIHdpbikge1xyXG4gICAgdmFyIHggPSBfcmVmLngsXHJcbiAgICAgICAgeSA9IF9yZWYueTtcclxuICAgIHZhciBkcHIgPSB3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgeDogcm91bmQoeCAqIGRwcikgLyBkcHIgfHwgMCxcclxuICAgICAgeTogcm91bmQoeSAqIGRwcikgLyBkcHIgfHwgMFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG1hcFRvU3R5bGVzKF9yZWYyKSB7XHJcbiAgICB2YXIgX09iamVjdCRhc3NpZ24yO1xyXG5cclxuICAgIHZhciBwb3BwZXIgPSBfcmVmMi5wb3BwZXIsXHJcbiAgICAgICAgcG9wcGVyUmVjdCA9IF9yZWYyLnBvcHBlclJlY3QsXHJcbiAgICAgICAgcGxhY2VtZW50ID0gX3JlZjIucGxhY2VtZW50LFxyXG4gICAgICAgIHZhcmlhdGlvbiA9IF9yZWYyLnZhcmlhdGlvbixcclxuICAgICAgICBvZmZzZXRzID0gX3JlZjIub2Zmc2V0cyxcclxuICAgICAgICBwb3NpdGlvbiA9IF9yZWYyLnBvc2l0aW9uLFxyXG4gICAgICAgIGdwdUFjY2VsZXJhdGlvbiA9IF9yZWYyLmdwdUFjY2VsZXJhdGlvbixcclxuICAgICAgICBhZGFwdGl2ZSA9IF9yZWYyLmFkYXB0aXZlLFxyXG4gICAgICAgIHJvdW5kT2Zmc2V0cyA9IF9yZWYyLnJvdW5kT2Zmc2V0cyxcclxuICAgICAgICBpc0ZpeGVkID0gX3JlZjIuaXNGaXhlZDtcclxuICAgIHZhciBfb2Zmc2V0cyR4ID0gb2Zmc2V0cy54LFxyXG4gICAgICAgIHggPSBfb2Zmc2V0cyR4ID09PSB2b2lkIDAgPyAwIDogX29mZnNldHMkeCxcclxuICAgICAgICBfb2Zmc2V0cyR5ID0gb2Zmc2V0cy55LFxyXG4gICAgICAgIHkgPSBfb2Zmc2V0cyR5ID09PSB2b2lkIDAgPyAwIDogX29mZnNldHMkeTtcclxuXHJcbiAgICB2YXIgX3JlZjMgPSB0eXBlb2Ygcm91bmRPZmZzZXRzID09PSAnZnVuY3Rpb24nID8gcm91bmRPZmZzZXRzKHtcclxuICAgICAgeDogeCxcclxuICAgICAgeTogeVxyXG4gICAgfSkgOiB7XHJcbiAgICAgIHg6IHgsXHJcbiAgICAgIHk6IHlcclxuICAgIH07XHJcblxyXG4gICAgeCA9IF9yZWYzLng7XHJcbiAgICB5ID0gX3JlZjMueTtcclxuICAgIHZhciBoYXNYID0gb2Zmc2V0cy5oYXNPd25Qcm9wZXJ0eSgneCcpO1xyXG4gICAgdmFyIGhhc1kgPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd5Jyk7XHJcbiAgICB2YXIgc2lkZVggPSBsZWZ0O1xyXG4gICAgdmFyIHNpZGVZID0gdG9wO1xyXG4gICAgdmFyIHdpbiA9IHdpbmRvdztcclxuXHJcbiAgICBpZiAoYWRhcHRpdmUpIHtcclxuICAgICAgdmFyIG9mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChwb3BwZXIpO1xyXG4gICAgICB2YXIgaGVpZ2h0UHJvcCA9ICdjbGllbnRIZWlnaHQnO1xyXG4gICAgICB2YXIgd2lkdGhQcm9wID0gJ2NsaWVudFdpZHRoJztcclxuXHJcbiAgICAgIGlmIChvZmZzZXRQYXJlbnQgPT09IGdldFdpbmRvdyhwb3BwZXIpKSB7XHJcbiAgICAgICAgb2Zmc2V0UGFyZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KHBvcHBlcik7XHJcblxyXG4gICAgICAgIGlmIChnZXRDb21wdXRlZFN0eWxlJDEob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiAhPT0gJ3N0YXRpYycgJiYgcG9zaXRpb24gPT09ICdhYnNvbHV0ZScpIHtcclxuICAgICAgICAgIGhlaWdodFByb3AgPSAnc2Nyb2xsSGVpZ2h0JztcclxuICAgICAgICAgIHdpZHRoUHJvcCA9ICdzY3JvbGxXaWR0aCc7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhc3RdOiBmb3JjZSB0eXBlIHJlZmluZW1lbnQsIHdlIGNvbXBhcmUgb2Zmc2V0UGFyZW50IHdpdGggd2luZG93IGFib3ZlLCBidXQgRmxvdyBkb2Vzbid0IGRldGVjdCBpdFxyXG5cclxuXHJcbiAgICAgIG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudDtcclxuXHJcbiAgICAgIGlmIChwbGFjZW1lbnQgPT09IHRvcCB8fCAocGxhY2VtZW50ID09PSBsZWZ0IHx8IHBsYWNlbWVudCA9PT0gcmlnaHQpICYmIHZhcmlhdGlvbiA9PT0gZW5kKSB7XHJcbiAgICAgICAgc2lkZVkgPSBib3R0b207XHJcbiAgICAgICAgdmFyIG9mZnNldFkgPSBpc0ZpeGVkICYmIG9mZnNldFBhcmVudCA9PT0gd2luICYmIHdpbi52aXN1YWxWaWV3cG9ydCA/IHdpbi52aXN1YWxWaWV3cG9ydC5oZWlnaHQgOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cclxuICAgICAgICBvZmZzZXRQYXJlbnRbaGVpZ2h0UHJvcF07XHJcbiAgICAgICAgeSAtPSBvZmZzZXRZIC0gcG9wcGVyUmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgeSAqPSBncHVBY2NlbGVyYXRpb24gPyAxIDogLTE7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChwbGFjZW1lbnQgPT09IGxlZnQgfHwgKHBsYWNlbWVudCA9PT0gdG9wIHx8IHBsYWNlbWVudCA9PT0gYm90dG9tKSAmJiB2YXJpYXRpb24gPT09IGVuZCkge1xyXG4gICAgICAgIHNpZGVYID0gcmlnaHQ7XHJcbiAgICAgICAgdmFyIG9mZnNldFggPSBpc0ZpeGVkICYmIG9mZnNldFBhcmVudCA9PT0gd2luICYmIHdpbi52aXN1YWxWaWV3cG9ydCA/IHdpbi52aXN1YWxWaWV3cG9ydC53aWR0aCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxyXG4gICAgICAgIG9mZnNldFBhcmVudFt3aWR0aFByb3BdO1xyXG4gICAgICAgIHggLT0gb2Zmc2V0WCAtIHBvcHBlclJlY3Qud2lkdGg7XHJcbiAgICAgICAgeCAqPSBncHVBY2NlbGVyYXRpb24gPyAxIDogLTE7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgY29tbW9uU3R5bGVzID0gT2JqZWN0LmFzc2lnbih7XHJcbiAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblxyXG4gICAgfSwgYWRhcHRpdmUgJiYgdW5zZXRTaWRlcyk7XHJcblxyXG4gICAgdmFyIF9yZWY0ID0gcm91bmRPZmZzZXRzID09PSB0cnVlID8gcm91bmRPZmZzZXRzQnlEUFIoe1xyXG4gICAgICB4OiB4LFxyXG4gICAgICB5OiB5XHJcbiAgICB9LCBnZXRXaW5kb3cocG9wcGVyKSkgOiB7XHJcbiAgICAgIHg6IHgsXHJcbiAgICAgIHk6IHlcclxuICAgIH07XHJcblxyXG4gICAgeCA9IF9yZWY0Lng7XHJcbiAgICB5ID0gX3JlZjQueTtcclxuXHJcbiAgICBpZiAoZ3B1QWNjZWxlcmF0aW9uKSB7XHJcbiAgICAgIHZhciBfT2JqZWN0JGFzc2lnbjtcclxuXHJcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIChfT2JqZWN0JGFzc2lnbiA9IHt9LCBfT2JqZWN0JGFzc2lnbltzaWRlWV0gPSBoYXNZID8gJzAnIDogJycsIF9PYmplY3QkYXNzaWduW3NpZGVYXSA9IGhhc1ggPyAnMCcgOiAnJywgX09iamVjdCRhc3NpZ24udHJhbnNmb3JtID0gKHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIDw9IDEgPyBcInRyYW5zbGF0ZShcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4KVwiIDogXCJ0cmFuc2xhdGUzZChcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4LCAwKVwiLCBfT2JqZWN0JGFzc2lnbikpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIChfT2JqZWN0JGFzc2lnbjIgPSB7fSwgX09iamVjdCRhc3NpZ24yW3NpZGVZXSA9IGhhc1kgPyB5ICsgXCJweFwiIDogJycsIF9PYmplY3QkYXNzaWduMltzaWRlWF0gPSBoYXNYID8geCArIFwicHhcIiA6ICcnLCBfT2JqZWN0JGFzc2lnbjIudHJhbnNmb3JtID0gJycsIF9PYmplY3QkYXNzaWduMikpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY29tcHV0ZVN0eWxlcyhfcmVmNSkge1xyXG4gICAgdmFyIHN0YXRlID0gX3JlZjUuc3RhdGUsXHJcbiAgICAgICAgb3B0aW9ucyA9IF9yZWY1Lm9wdGlvbnM7XHJcbiAgICB2YXIgX29wdGlvbnMkZ3B1QWNjZWxlcmF0ID0gb3B0aW9ucy5ncHVBY2NlbGVyYXRpb24sXHJcbiAgICAgICAgZ3B1QWNjZWxlcmF0aW9uID0gX29wdGlvbnMkZ3B1QWNjZWxlcmF0ID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkZ3B1QWNjZWxlcmF0LFxyXG4gICAgICAgIF9vcHRpb25zJGFkYXB0aXZlID0gb3B0aW9ucy5hZGFwdGl2ZSxcclxuICAgICAgICBhZGFwdGl2ZSA9IF9vcHRpb25zJGFkYXB0aXZlID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkYWRhcHRpdmUsXHJcbiAgICAgICAgX29wdGlvbnMkcm91bmRPZmZzZXRzID0gb3B0aW9ucy5yb3VuZE9mZnNldHMsXHJcbiAgICAgICAgcm91bmRPZmZzZXRzID0gX29wdGlvbnMkcm91bmRPZmZzZXRzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkcm91bmRPZmZzZXRzO1xyXG4gICAgdmFyIGNvbW1vblN0eWxlcyA9IHtcclxuICAgICAgcGxhY2VtZW50OiBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCksXHJcbiAgICAgIHZhcmlhdGlvbjogZ2V0VmFyaWF0aW9uKHN0YXRlLnBsYWNlbWVudCksXHJcbiAgICAgIHBvcHBlcjogc3RhdGUuZWxlbWVudHMucG9wcGVyLFxyXG4gICAgICBwb3BwZXJSZWN0OiBzdGF0ZS5yZWN0cy5wb3BwZXIsXHJcbiAgICAgIGdwdUFjY2VsZXJhdGlvbjogZ3B1QWNjZWxlcmF0aW9uLFxyXG4gICAgICBpc0ZpeGVkOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5ID09PSAnZml4ZWQnXHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xyXG4gICAgICBzdGF0ZS5zdHlsZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc3R5bGVzLnBvcHBlciwgbWFwVG9TdHlsZXMoT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCB7XHJcbiAgICAgICAgb2Zmc2V0czogc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLFxyXG4gICAgICAgIHBvc2l0aW9uOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5LFxyXG4gICAgICAgIGFkYXB0aXZlOiBhZGFwdGl2ZSxcclxuICAgICAgICByb3VuZE9mZnNldHM6IHJvdW5kT2Zmc2V0c1xyXG4gICAgICB9KSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93ICE9IG51bGwpIHtcclxuICAgICAgc3RhdGUuc3R5bGVzLmFycm93ID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc3R5bGVzLmFycm93LCBtYXBUb1N0eWxlcyhPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIHtcclxuICAgICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93LFxyXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgIGFkYXB0aXZlOiBmYWxzZSxcclxuICAgICAgICByb3VuZE9mZnNldHM6IHJvdW5kT2Zmc2V0c1xyXG4gICAgICB9KSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIsIHtcclxuICAgICAgJ2RhdGEtcG9wcGVyLXBsYWNlbWVudCc6IHN0YXRlLnBsYWNlbWVudFxyXG4gICAgfSk7XHJcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXHJcblxyXG5cclxuICBjb25zdCBjb21wdXRlU3R5bGVzJDEgPSB7XHJcbiAgICBuYW1lOiAnY29tcHV0ZVN0eWxlcycsXHJcbiAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgcGhhc2U6ICdiZWZvcmVXcml0ZScsXHJcbiAgICBmbjogY29tcHV0ZVN0eWxlcyxcclxuICAgIGRhdGE6IHt9XHJcbiAgfTtcclxuXHJcbiAgdmFyIHBhc3NpdmUgPSB7XHJcbiAgICBwYXNzaXZlOiB0cnVlXHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gZWZmZWN0KF9yZWYpIHtcclxuICAgIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXHJcbiAgICAgICAgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlLFxyXG4gICAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XHJcbiAgICB2YXIgX29wdGlvbnMkc2Nyb2xsID0gb3B0aW9ucy5zY3JvbGwsXHJcbiAgICAgICAgc2Nyb2xsID0gX29wdGlvbnMkc2Nyb2xsID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkc2Nyb2xsLFxyXG4gICAgICAgIF9vcHRpb25zJHJlc2l6ZSA9IG9wdGlvbnMucmVzaXplLFxyXG4gICAgICAgIHJlc2l6ZSA9IF9vcHRpb25zJHJlc2l6ZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHJlc2l6ZTtcclxuICAgIHZhciB3aW5kb3cgPSBnZXRXaW5kb3coc3RhdGUuZWxlbWVudHMucG9wcGVyKTtcclxuICAgIHZhciBzY3JvbGxQYXJlbnRzID0gW10uY29uY2F0KHN0YXRlLnNjcm9sbFBhcmVudHMucmVmZXJlbmNlLCBzdGF0ZS5zY3JvbGxQYXJlbnRzLnBvcHBlcik7XHJcblxyXG4gICAgaWYgKHNjcm9sbCkge1xyXG4gICAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xyXG4gICAgICAgIHNjcm9sbFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocmVzaXplKSB7XHJcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmIChzY3JvbGwpIHtcclxuICAgICAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xyXG4gICAgICAgICAgc2Nyb2xsUGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChyZXNpemUpIHtcclxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcclxuXHJcblxyXG4gIGNvbnN0IGV2ZW50TGlzdGVuZXJzID0ge1xyXG4gICAgbmFtZTogJ2V2ZW50TGlzdGVuZXJzJyxcclxuICAgIGVuYWJsZWQ6IHRydWUsXHJcbiAgICBwaGFzZTogJ3dyaXRlJyxcclxuICAgIGZuOiBmdW5jdGlvbiBmbigpIHt9LFxyXG4gICAgZWZmZWN0OiBlZmZlY3QsXHJcbiAgICBkYXRhOiB7fVxyXG4gIH07XHJcblxyXG4gIHZhciBoYXNoJDEgPSB7XHJcbiAgICBsZWZ0OiAncmlnaHQnLFxyXG4gICAgcmlnaHQ6ICdsZWZ0JyxcclxuICAgIGJvdHRvbTogJ3RvcCcsXHJcbiAgICB0b3A6ICdib3R0b20nXHJcbiAgfTtcclxuICBmdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcclxuICAgIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XHJcbiAgICAgIHJldHVybiBoYXNoJDFbbWF0Y2hlZF07XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHZhciBoYXNoID0ge1xyXG4gICAgc3RhcnQ6ICdlbmQnLFxyXG4gICAgZW5kOiAnc3RhcnQnXHJcbiAgfTtcclxuICBmdW5jdGlvbiBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChwbGFjZW1lbnQpIHtcclxuICAgIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvc3RhcnR8ZW5kL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XHJcbiAgICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGwobm9kZSkge1xyXG4gICAgdmFyIHdpbiA9IGdldFdpbmRvdyhub2RlKTtcclxuICAgIHZhciBzY3JvbGxMZWZ0ID0gd2luLnBhZ2VYT2Zmc2V0O1xyXG4gICAgdmFyIHNjcm9sbFRvcCA9IHdpbi5wYWdlWU9mZnNldDtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHNjcm9sbExlZnQ6IHNjcm9sbExlZnQsXHJcbiAgICAgIHNjcm9sbFRvcDogc2Nyb2xsVG9wXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KSB7XHJcbiAgICAvLyBJZiA8aHRtbD4gaGFzIGEgQ1NTIHdpZHRoIGdyZWF0ZXIgdGhhbiB0aGUgdmlld3BvcnQsIHRoZW4gdGhpcyB3aWxsIGJlXHJcbiAgICAvLyBpbmNvcnJlY3QgZm9yIFJUTC5cclxuICAgIC8vIFBvcHBlciAxIGlzIGJyb2tlbiBpbiB0aGlzIGNhc2UgYW5kIG5ldmVyIGhhZCBhIGJ1ZyByZXBvcnQgc28gbGV0J3MgYXNzdW1lXHJcbiAgICAvLyBpdCdzIG5vdCBhbiBpc3N1ZS4gSSBkb24ndCB0aGluayBhbnlvbmUgZXZlciBzcGVjaWZpZXMgd2lkdGggb24gPGh0bWw+XHJcbiAgICAvLyBhbnl3YXkuXHJcbiAgICAvLyBCcm93c2VycyB3aGVyZSB0aGUgbGVmdCBzY3JvbGxiYXIgZG9lc24ndCBjYXVzZSBhbiBpc3N1ZSByZXBvcnQgYDBgIGZvclxyXG4gICAgLy8gdGhpcyAoZS5nLiBFZGdlIDIwMTksIElFMTEsIFNhZmFyaSlcclxuICAgIHJldHVybiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKS5sZWZ0ICsgZ2V0V2luZG93U2Nyb2xsKGVsZW1lbnQpLnNjcm9sbExlZnQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpIHtcclxuICAgIHZhciB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XHJcbiAgICB2YXIgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcclxuICAgIHZhciB2aXN1YWxWaWV3cG9ydCA9IHdpbi52aXN1YWxWaWV3cG9ydDtcclxuICAgIHZhciB3aWR0aCA9IGh0bWwuY2xpZW50V2lkdGg7XHJcbiAgICB2YXIgaGVpZ2h0ID0gaHRtbC5jbGllbnRIZWlnaHQ7XHJcbiAgICB2YXIgeCA9IDA7XHJcbiAgICB2YXIgeSA9IDA7XHJcblxyXG4gICAgaWYgKHZpc3VhbFZpZXdwb3J0KSB7XHJcbiAgICAgIHdpZHRoID0gdmlzdWFsVmlld3BvcnQud2lkdGg7XHJcbiAgICAgIGhlaWdodCA9IHZpc3VhbFZpZXdwb3J0LmhlaWdodDtcclxuICAgICAgdmFyIGxheW91dFZpZXdwb3J0ID0gaXNMYXlvdXRWaWV3cG9ydCgpO1xyXG5cclxuICAgICAgaWYgKGxheW91dFZpZXdwb3J0IHx8ICFsYXlvdXRWaWV3cG9ydCAmJiBzdHJhdGVneSA9PT0gJ2ZpeGVkJykge1xyXG4gICAgICAgIHggPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0O1xyXG4gICAgICAgIHkgPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3A7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICB4OiB4ICsgZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KSxcclxuICAgICAgeTogeVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIG9mIHRoZSBgPGh0bWw+YCBhbmQgYDxib2R5PmAgcmVjdCBib3VuZHMgaWYgaG9yaXpvbnRhbGx5IHNjcm9sbGFibGVcclxuXHJcbiAgZnVuY3Rpb24gZ2V0RG9jdW1lbnRSZWN0KGVsZW1lbnQpIHtcclxuICAgIHZhciBfZWxlbWVudCRvd25lckRvY3VtZW47XHJcblxyXG4gICAgdmFyIGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XHJcbiAgICB2YXIgd2luU2Nyb2xsID0gZ2V0V2luZG93U2Nyb2xsKGVsZW1lbnQpO1xyXG4gICAgdmFyIGJvZHkgPSAoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gZWxlbWVudC5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQkb3duZXJEb2N1bWVuLmJvZHk7XHJcbiAgICB2YXIgd2lkdGggPSBtYXgoaHRtbC5zY3JvbGxXaWR0aCwgaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuc2Nyb2xsV2lkdGggOiAwLCBib2R5ID8gYm9keS5jbGllbnRXaWR0aCA6IDApO1xyXG4gICAgdmFyIGhlaWdodCA9IG1heChodG1sLnNjcm9sbEhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQsIGJvZHkgPyBib2R5LnNjcm9sbEhlaWdodCA6IDAsIGJvZHkgPyBib2R5LmNsaWVudEhlaWdodCA6IDApO1xyXG4gICAgdmFyIHggPSAtd2luU2Nyb2xsLnNjcm9sbExlZnQgKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpO1xyXG4gICAgdmFyIHkgPSAtd2luU2Nyb2xsLnNjcm9sbFRvcDtcclxuXHJcbiAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZSQxKGJvZHkgfHwgaHRtbCkuZGlyZWN0aW9uID09PSAncnRsJykge1xyXG4gICAgICB4ICs9IG1heChodG1sLmNsaWVudFdpZHRoLCBib2R5ID8gYm9keS5jbGllbnRXaWR0aCA6IDApIC0gd2lkdGg7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcclxuICAgICAgeDogeCxcclxuICAgICAgeTogeVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGlzU2Nyb2xsUGFyZW50KGVsZW1lbnQpIHtcclxuICAgIC8vIEZpcmVmb3ggd2FudHMgdXMgdG8gY2hlY2sgYC14YCBhbmQgYC15YCB2YXJpYXRpb25zIGFzIHdlbGxcclxuICAgIHZhciBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUkMShlbGVtZW50KSxcclxuICAgICAgICBvdmVyZmxvdyA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93LFxyXG4gICAgICAgIG92ZXJmbG93WCA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93WCxcclxuICAgICAgICBvdmVyZmxvd1kgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5vdmVyZmxvd1k7XHJcblxyXG4gICAgcmV0dXJuIC9hdXRvfHNjcm9sbHxvdmVybGF5fGhpZGRlbi8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQobm9kZSkge1xyXG4gICAgaWYgKFsnaHRtbCcsICdib2R5JywgJyNkb2N1bWVudCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUobm9kZSkpID49IDApIHtcclxuICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogYXNzdW1lIGJvZHkgaXMgYWx3YXlzIGF2YWlsYWJsZVxyXG4gICAgICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50LmJvZHk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQobm9kZSkgJiYgaXNTY3JvbGxQYXJlbnQobm9kZSkpIHtcclxuICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKG5vZGUpKTtcclxuICB9XHJcblxyXG4gIC8qXHJcbiAgZ2l2ZW4gYSBET00gZWxlbWVudCwgcmV0dXJuIHRoZSBsaXN0IG9mIGFsbCBzY3JvbGwgcGFyZW50cywgdXAgdGhlIGxpc3Qgb2YgYW5jZXNvcnNcclxuICB1bnRpbCB3ZSBnZXQgdG8gdGhlIHRvcCB3aW5kb3cgb2JqZWN0LiBUaGlzIGxpc3QgaXMgd2hhdCB3ZSBhdHRhY2ggc2Nyb2xsIGxpc3RlbmVyc1xyXG4gIHRvLCBiZWNhdXNlIGlmIGFueSBvZiB0aGVzZSBwYXJlbnQgZWxlbWVudHMgc2Nyb2xsLCB3ZSdsbCBuZWVkIHRvIHJlLWNhbGN1bGF0ZSB0aGVcclxuICByZWZlcmVuY2UgZWxlbWVudCdzIHBvc2l0aW9uLlxyXG4gICovXHJcblxyXG4gIGZ1bmN0aW9uIGxpc3RTY3JvbGxQYXJlbnRzKGVsZW1lbnQsIGxpc3QpIHtcclxuICAgIHZhciBfZWxlbWVudCRvd25lckRvY3VtZW47XHJcblxyXG4gICAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xyXG4gICAgICBsaXN0ID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudChlbGVtZW50KTtcclxuICAgIHZhciBpc0JvZHkgPSBzY3JvbGxQYXJlbnQgPT09ICgoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gZWxlbWVudC5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQkb3duZXJEb2N1bWVuLmJvZHkpO1xyXG4gICAgdmFyIHdpbiA9IGdldFdpbmRvdyhzY3JvbGxQYXJlbnQpO1xyXG4gICAgdmFyIHRhcmdldCA9IGlzQm9keSA/IFt3aW5dLmNvbmNhdCh3aW4udmlzdWFsVmlld3BvcnQgfHwgW10sIGlzU2Nyb2xsUGFyZW50KHNjcm9sbFBhcmVudCkgPyBzY3JvbGxQYXJlbnQgOiBbXSkgOiBzY3JvbGxQYXJlbnQ7XHJcbiAgICB2YXIgdXBkYXRlZExpc3QgPSBsaXN0LmNvbmNhdCh0YXJnZXQpO1xyXG4gICAgcmV0dXJuIGlzQm9keSA/IHVwZGF0ZWRMaXN0IDogLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IGlzQm9keSB0ZWxscyB1cyB0YXJnZXQgd2lsbCBiZSBhbiBIVE1MRWxlbWVudCBoZXJlXHJcbiAgICB1cGRhdGVkTGlzdC5jb25jYXQobGlzdFNjcm9sbFBhcmVudHMoZ2V0UGFyZW50Tm9kZSh0YXJnZXQpKSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZWN0VG9DbGllbnRSZWN0KHJlY3QpIHtcclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCByZWN0LCB7XHJcbiAgICAgIGxlZnQ6IHJlY3QueCxcclxuICAgICAgdG9wOiByZWN0LnksXHJcbiAgICAgIHJpZ2h0OiByZWN0LnggKyByZWN0LndpZHRoLFxyXG4gICAgICBib3R0b206IHJlY3QueSArIHJlY3QuaGVpZ2h0XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XHJcbiAgICB2YXIgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBmYWxzZSwgc3RyYXRlZ3kgPT09ICdmaXhlZCcpO1xyXG4gICAgcmVjdC50b3AgPSByZWN0LnRvcCArIGVsZW1lbnQuY2xpZW50VG9wO1xyXG4gICAgcmVjdC5sZWZ0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRMZWZ0O1xyXG4gICAgcmVjdC5ib3R0b20gPSByZWN0LnRvcCArIGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xyXG4gICAgcmVjdC5yaWdodCA9IHJlY3QubGVmdCArIGVsZW1lbnQuY2xpZW50V2lkdGg7XHJcbiAgICByZWN0LndpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aDtcclxuICAgIHJlY3QuaGVpZ2h0ID0gZWxlbWVudC5jbGllbnRIZWlnaHQ7XHJcbiAgICByZWN0LnggPSByZWN0LmxlZnQ7XHJcbiAgICByZWN0LnkgPSByZWN0LnRvcDtcclxuICAgIHJldHVybiByZWN0O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgY2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KSB7XHJcbiAgICByZXR1cm4gY2xpcHBpbmdQYXJlbnQgPT09IHZpZXdwb3J0ID8gcmVjdFRvQ2xpZW50UmVjdChnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpKSA6IGlzRWxlbWVudChjbGlwcGluZ1BhcmVudCkgPyBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpIDogcmVjdFRvQ2xpZW50UmVjdChnZXREb2N1bWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKSk7XHJcbiAgfSAvLyBBIFwiY2xpcHBpbmcgcGFyZW50XCIgaXMgYW4gb3ZlcmZsb3dhYmxlIGNvbnRhaW5lciB3aXRoIHRoZSBjaGFyYWN0ZXJpc3RpYyBvZlxyXG4gIC8vIGNsaXBwaW5nIChvciBoaWRpbmcpIG92ZXJmbG93aW5nIGVsZW1lbnRzIHdpdGggYSBwb3NpdGlvbiBkaWZmZXJlbnQgZnJvbVxyXG4gIC8vIGBpbml0aWFsYFxyXG5cclxuXHJcbiAgZnVuY3Rpb24gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsZW1lbnQpIHtcclxuICAgIHZhciBjbGlwcGluZ1BhcmVudHMgPSBsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcclxuICAgIHZhciBjYW5Fc2NhcGVDbGlwcGluZyA9IFsnYWJzb2x1dGUnLCAnZml4ZWQnXS5pbmRleE9mKGdldENvbXB1dGVkU3R5bGUkMShlbGVtZW50KS5wb3NpdGlvbikgPj0gMDtcclxuICAgIHZhciBjbGlwcGVyRWxlbWVudCA9IGNhbkVzY2FwZUNsaXBwaW5nICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkgPyBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkgOiBlbGVtZW50O1xyXG5cclxuICAgIGlmICghaXNFbGVtZW50KGNsaXBwZXJFbGVtZW50KSkge1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8xNDE0XHJcblxyXG5cclxuICAgIHJldHVybiBjbGlwcGluZ1BhcmVudHMuZmlsdGVyKGZ1bmN0aW9uIChjbGlwcGluZ1BhcmVudCkge1xyXG4gICAgICByZXR1cm4gaXNFbGVtZW50KGNsaXBwaW5nUGFyZW50KSAmJiBjb250YWlucyhjbGlwcGluZ1BhcmVudCwgY2xpcHBlckVsZW1lbnQpICYmIGdldE5vZGVOYW1lKGNsaXBwaW5nUGFyZW50KSAhPT0gJ2JvZHknO1xyXG4gICAgfSk7XHJcbiAgfSAvLyBHZXRzIHRoZSBtYXhpbXVtIGFyZWEgdGhhdCB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIGluIGR1ZSB0byBhbnkgbnVtYmVyIG9mXHJcbiAgLy8gY2xpcHBpbmcgcGFyZW50c1xyXG5cclxuXHJcbiAgZnVuY3Rpb24gZ2V0Q2xpcHBpbmdSZWN0KGVsZW1lbnQsIGJvdW5kYXJ5LCByb290Qm91bmRhcnksIHN0cmF0ZWd5KSB7XHJcbiAgICB2YXIgbWFpbkNsaXBwaW5nUGFyZW50cyA9IGJvdW5kYXJ5ID09PSAnY2xpcHBpbmdQYXJlbnRzJyA/IGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSA6IFtdLmNvbmNhdChib3VuZGFyeSk7XHJcbiAgICB2YXIgY2xpcHBpbmdQYXJlbnRzID0gW10uY29uY2F0KG1haW5DbGlwcGluZ1BhcmVudHMsIFtyb290Qm91bmRhcnldKTtcclxuICAgIHZhciBmaXJzdENsaXBwaW5nUGFyZW50ID0gY2xpcHBpbmdQYXJlbnRzWzBdO1xyXG4gICAgdmFyIGNsaXBwaW5nUmVjdCA9IGNsaXBwaW5nUGFyZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjY1JlY3QsIGNsaXBwaW5nUGFyZW50KSB7XHJcbiAgICAgIHZhciByZWN0ID0gZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgY2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KTtcclxuICAgICAgYWNjUmVjdC50b3AgPSBtYXgocmVjdC50b3AsIGFjY1JlY3QudG9wKTtcclxuICAgICAgYWNjUmVjdC5yaWdodCA9IG1pbihyZWN0LnJpZ2h0LCBhY2NSZWN0LnJpZ2h0KTtcclxuICAgICAgYWNjUmVjdC5ib3R0b20gPSBtaW4ocmVjdC5ib3R0b20sIGFjY1JlY3QuYm90dG9tKTtcclxuICAgICAgYWNjUmVjdC5sZWZ0ID0gbWF4KHJlY3QubGVmdCwgYWNjUmVjdC5sZWZ0KTtcclxuICAgICAgcmV0dXJuIGFjY1JlY3Q7XHJcbiAgICB9LCBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBmaXJzdENsaXBwaW5nUGFyZW50LCBzdHJhdGVneSkpO1xyXG4gICAgY2xpcHBpbmdSZWN0LndpZHRoID0gY2xpcHBpbmdSZWN0LnJpZ2h0IC0gY2xpcHBpbmdSZWN0LmxlZnQ7XHJcbiAgICBjbGlwcGluZ1JlY3QuaGVpZ2h0ID0gY2xpcHBpbmdSZWN0LmJvdHRvbSAtIGNsaXBwaW5nUmVjdC50b3A7XHJcbiAgICBjbGlwcGluZ1JlY3QueCA9IGNsaXBwaW5nUmVjdC5sZWZ0O1xyXG4gICAgY2xpcHBpbmdSZWN0LnkgPSBjbGlwcGluZ1JlY3QudG9wO1xyXG4gICAgcmV0dXJuIGNsaXBwaW5nUmVjdDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNvbXB1dGVPZmZzZXRzKF9yZWYpIHtcclxuICAgIHZhciByZWZlcmVuY2UgPSBfcmVmLnJlZmVyZW5jZSxcclxuICAgICAgICBlbGVtZW50ID0gX3JlZi5lbGVtZW50LFxyXG4gICAgICAgIHBsYWNlbWVudCA9IF9yZWYucGxhY2VtZW50O1xyXG4gICAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQgPyBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgOiBudWxsO1xyXG4gICAgdmFyIHZhcmlhdGlvbiA9IHBsYWNlbWVudCA/IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpIDogbnVsbDtcclxuICAgIHZhciBjb21tb25YID0gcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGggLyAyIC0gZWxlbWVudC53aWR0aCAvIDI7XHJcbiAgICB2YXIgY29tbW9uWSA9IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCAvIDIgLSBlbGVtZW50LmhlaWdodCAvIDI7XHJcbiAgICB2YXIgb2Zmc2V0cztcclxuXHJcbiAgICBzd2l0Y2ggKGJhc2VQbGFjZW1lbnQpIHtcclxuICAgICAgY2FzZSB0b3A6XHJcbiAgICAgICAgb2Zmc2V0cyA9IHtcclxuICAgICAgICAgIHg6IGNvbW1vblgsXHJcbiAgICAgICAgICB5OiByZWZlcmVuY2UueSAtIGVsZW1lbnQuaGVpZ2h0XHJcbiAgICAgICAgfTtcclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGNhc2UgYm90dG9tOlxyXG4gICAgICAgIG9mZnNldHMgPSB7XHJcbiAgICAgICAgICB4OiBjb21tb25YLFxyXG4gICAgICAgICAgeTogcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0XHJcbiAgICAgICAgfTtcclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGNhc2UgcmlnaHQ6XHJcbiAgICAgICAgb2Zmc2V0cyA9IHtcclxuICAgICAgICAgIHg6IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoLFxyXG4gICAgICAgICAgeTogY29tbW9uWVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBjYXNlIGxlZnQ6XHJcbiAgICAgICAgb2Zmc2V0cyA9IHtcclxuICAgICAgICAgIHg6IHJlZmVyZW5jZS54IC0gZWxlbWVudC53aWR0aCxcclxuICAgICAgICAgIHk6IGNvbW1vbllcclxuICAgICAgICB9O1xyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICBvZmZzZXRzID0ge1xyXG4gICAgICAgICAgeDogcmVmZXJlbmNlLngsXHJcbiAgICAgICAgICB5OiByZWZlcmVuY2UueVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG1haW5BeGlzID0gYmFzZVBsYWNlbWVudCA/IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KSA6IG51bGw7XHJcblxyXG4gICAgaWYgKG1haW5BeGlzICE9IG51bGwpIHtcclxuICAgICAgdmFyIGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XHJcblxyXG4gICAgICBzd2l0Y2ggKHZhcmlhdGlvbikge1xyXG4gICAgICAgIGNhc2Ugc3RhcnQ6XHJcbiAgICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9IG9mZnNldHNbbWFpbkF4aXNdIC0gKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgZW5kOlxyXG4gICAgICAgICAgb2Zmc2V0c1ttYWluQXhpc10gPSBvZmZzZXRzW21haW5BeGlzXSArIChyZWZlcmVuY2VbbGVuXSAvIDIgLSBlbGVtZW50W2xlbl0gLyAyKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG9mZnNldHM7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgb3B0aW9ucykge1xyXG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xyXG4gICAgICBvcHRpb25zID0ge307XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcclxuICAgICAgICBfb3B0aW9ucyRwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXHJcbiAgICAgICAgcGxhY2VtZW50ID0gX29wdGlvbnMkcGxhY2VtZW50ID09PSB2b2lkIDAgPyBzdGF0ZS5wbGFjZW1lbnQgOiBfb3B0aW9ucyRwbGFjZW1lbnQsXHJcbiAgICAgICAgX29wdGlvbnMkc3RyYXRlZ3kgPSBfb3B0aW9ucy5zdHJhdGVneSxcclxuICAgICAgICBzdHJhdGVneSA9IF9vcHRpb25zJHN0cmF0ZWd5ID09PSB2b2lkIDAgPyBzdGF0ZS5zdHJhdGVneSA6IF9vcHRpb25zJHN0cmF0ZWd5LFxyXG4gICAgICAgIF9vcHRpb25zJGJvdW5kYXJ5ID0gX29wdGlvbnMuYm91bmRhcnksXHJcbiAgICAgICAgYm91bmRhcnkgPSBfb3B0aW9ucyRib3VuZGFyeSA9PT0gdm9pZCAwID8gY2xpcHBpbmdQYXJlbnRzIDogX29wdGlvbnMkYm91bmRhcnksXHJcbiAgICAgICAgX29wdGlvbnMkcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMucm9vdEJvdW5kYXJ5LFxyXG4gICAgICAgIHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zJHJvb3RCb3VuZGFyeSA9PT0gdm9pZCAwID8gdmlld3BvcnQgOiBfb3B0aW9ucyRyb290Qm91bmRhcnksXHJcbiAgICAgICAgX29wdGlvbnMkZWxlbWVudENvbnRlID0gX29wdGlvbnMuZWxlbWVudENvbnRleHQsXHJcbiAgICAgICAgZWxlbWVudENvbnRleHQgPSBfb3B0aW9ucyRlbGVtZW50Q29udGUgPT09IHZvaWQgMCA/IHBvcHBlciA6IF9vcHRpb25zJGVsZW1lbnRDb250ZSxcclxuICAgICAgICBfb3B0aW9ucyRhbHRCb3VuZGFyeSA9IF9vcHRpb25zLmFsdEJvdW5kYXJ5LFxyXG4gICAgICAgIGFsdEJvdW5kYXJ5ID0gX29wdGlvbnMkYWx0Qm91bmRhcnkgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx0Qm91bmRhcnksXHJcbiAgICAgICAgX29wdGlvbnMkcGFkZGluZyA9IF9vcHRpb25zLnBhZGRpbmcsXHJcbiAgICAgICAgcGFkZGluZyA9IF9vcHRpb25zJHBhZGRpbmcgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyRwYWRkaW5nO1xyXG4gICAgdmFyIHBhZGRpbmdPYmplY3QgPSBtZXJnZVBhZGRpbmdPYmplY3QodHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gcGFkZGluZyA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cykpO1xyXG4gICAgdmFyIGFsdENvbnRleHQgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcmVmZXJlbmNlIDogcG9wcGVyO1xyXG4gICAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XHJcbiAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW2FsdEJvdW5kYXJ5ID8gYWx0Q29udGV4dCA6IGVsZW1lbnRDb250ZXh0XTtcclxuICAgIHZhciBjbGlwcGluZ0NsaWVudFJlY3QgPSBnZXRDbGlwcGluZ1JlY3QoaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudCA6IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgfHwgZ2V0RG9jdW1lbnRFbGVtZW50KHN0YXRlLmVsZW1lbnRzLnBvcHBlciksIGJvdW5kYXJ5LCByb290Qm91bmRhcnksIHN0cmF0ZWd5KTtcclxuICAgIHZhciByZWZlcmVuY2VDbGllbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHN0YXRlLmVsZW1lbnRzLnJlZmVyZW5jZSk7XHJcbiAgICB2YXIgcG9wcGVyT2Zmc2V0cyA9IGNvbXB1dGVPZmZzZXRzKHtcclxuICAgICAgcmVmZXJlbmNlOiByZWZlcmVuY2VDbGllbnRSZWN0LFxyXG4gICAgICBlbGVtZW50OiBwb3BwZXJSZWN0LFxyXG4gICAgICBzdHJhdGVneTogJ2Fic29sdXRlJyxcclxuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcclxuICAgIH0pO1xyXG4gICAgdmFyIHBvcHBlckNsaWVudFJlY3QgPSByZWN0VG9DbGllbnRSZWN0KE9iamVjdC5hc3NpZ24oe30sIHBvcHBlclJlY3QsIHBvcHBlck9mZnNldHMpKTtcclxuICAgIHZhciBlbGVtZW50Q2xpZW50UmVjdCA9IGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgPyBwb3BwZXJDbGllbnRSZWN0IDogcmVmZXJlbmNlQ2xpZW50UmVjdDsgLy8gcG9zaXRpdmUgPSBvdmVyZmxvd2luZyB0aGUgY2xpcHBpbmcgcmVjdFxyXG4gICAgLy8gMCBvciBuZWdhdGl2ZSA9IHdpdGhpbiB0aGUgY2xpcHBpbmcgcmVjdFxyXG5cclxuICAgIHZhciBvdmVyZmxvd09mZnNldHMgPSB7XHJcbiAgICAgIHRvcDogY2xpcHBpbmdDbGllbnRSZWN0LnRvcCAtIGVsZW1lbnRDbGllbnRSZWN0LnRvcCArIHBhZGRpbmdPYmplY3QudG9wLFxyXG4gICAgICBib3R0b206IGVsZW1lbnRDbGllbnRSZWN0LmJvdHRvbSAtIGNsaXBwaW5nQ2xpZW50UmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSxcclxuICAgICAgbGVmdDogY2xpcHBpbmdDbGllbnRSZWN0LmxlZnQgLSBlbGVtZW50Q2xpZW50UmVjdC5sZWZ0ICsgcGFkZGluZ09iamVjdC5sZWZ0LFxyXG4gICAgICByaWdodDogZWxlbWVudENsaWVudFJlY3QucmlnaHQgLSBjbGlwcGluZ0NsaWVudFJlY3QucmlnaHQgKyBwYWRkaW5nT2JqZWN0LnJpZ2h0XHJcbiAgICB9O1xyXG4gICAgdmFyIG9mZnNldERhdGEgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldDsgLy8gT2Zmc2V0cyBjYW4gYmUgYXBwbGllZCBvbmx5IHRvIHRoZSBwb3BwZXIgZWxlbWVudFxyXG5cclxuICAgIGlmIChlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyICYmIG9mZnNldERhdGEpIHtcclxuICAgICAgdmFyIG9mZnNldCA9IG9mZnNldERhdGFbcGxhY2VtZW50XTtcclxuICAgICAgT2JqZWN0LmtleXMob3ZlcmZsb3dPZmZzZXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICB2YXIgbXVsdGlwbHkgPSBbcmlnaHQsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAxIDogLTE7XHJcbiAgICAgICAgdmFyIGF4aXMgPSBbdG9wLCBib3R0b21dLmluZGV4T2Yoa2V5KSA+PSAwID8gJ3knIDogJ3gnO1xyXG4gICAgICAgIG92ZXJmbG93T2Zmc2V0c1trZXldICs9IG9mZnNldFtheGlzXSAqIG11bHRpcGx5O1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3ZlcmZsb3dPZmZzZXRzO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIG9wdGlvbnMpIHtcclxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcclxuICAgICAgb3B0aW9ucyA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXHJcbiAgICAgICAgcGxhY2VtZW50ID0gX29wdGlvbnMucGxhY2VtZW50LFxyXG4gICAgICAgIGJvdW5kYXJ5ID0gX29wdGlvbnMuYm91bmRhcnksXHJcbiAgICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMucm9vdEJvdW5kYXJ5LFxyXG4gICAgICAgIHBhZGRpbmcgPSBfb3B0aW9ucy5wYWRkaW5nLFxyXG4gICAgICAgIGZsaXBWYXJpYXRpb25zID0gX29wdGlvbnMuZmxpcFZhcmlhdGlvbnMsXHJcbiAgICAgICAgX29wdGlvbnMkYWxsb3dlZEF1dG9QID0gX29wdGlvbnMuYWxsb3dlZEF1dG9QbGFjZW1lbnRzLFxyXG4gICAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50cyA9IF9vcHRpb25zJGFsbG93ZWRBdXRvUCA9PT0gdm9pZCAwID8gcGxhY2VtZW50cyA6IF9vcHRpb25zJGFsbG93ZWRBdXRvUDtcclxuICAgIHZhciB2YXJpYXRpb24gPSBnZXRWYXJpYXRpb24ocGxhY2VtZW50KTtcclxuICAgIHZhciBwbGFjZW1lbnRzJDEgPSB2YXJpYXRpb24gPyBmbGlwVmFyaWF0aW9ucyA/IHZhcmlhdGlvblBsYWNlbWVudHMgOiB2YXJpYXRpb25QbGFjZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAocGxhY2VtZW50KSB7XHJcbiAgICAgIHJldHVybiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA9PT0gdmFyaWF0aW9uO1xyXG4gICAgfSkgOiBiYXNlUGxhY2VtZW50cztcclxuICAgIHZhciBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMkMS5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xyXG4gICAgICByZXR1cm4gYWxsb3dlZEF1dG9QbGFjZW1lbnRzLmluZGV4T2YocGxhY2VtZW50KSA+PSAwO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKGFsbG93ZWRQbGFjZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMkMTtcclxuICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV06IEZsb3cgc2VlbXMgdG8gaGF2ZSBwcm9ibGVtcyB3aXRoIHR3byBhcnJheSB1bmlvbnMuLi5cclxuXHJcblxyXG4gICAgdmFyIG92ZXJmbG93cyA9IGFsbG93ZWRQbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcclxuICAgICAgYWNjW3BsYWNlbWVudF0gPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xyXG4gICAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxyXG4gICAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcclxuICAgICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcclxuICAgICAgICBwYWRkaW5nOiBwYWRkaW5nXHJcbiAgICAgIH0pW2dldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KV07XHJcbiAgICAgIHJldHVybiBhY2M7XHJcbiAgICB9LCB7fSk7XHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob3ZlcmZsb3dzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgIHJldHVybiBvdmVyZmxvd3NbYV0gLSBvdmVyZmxvd3NbYl07XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHBsYWNlbWVudCkge1xyXG4gICAgaWYgKGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA9PT0gYXV0bykge1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG9wcG9zaXRlUGxhY2VtZW50ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcclxuICAgIHJldHVybiBbZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQocGxhY2VtZW50KSwgb3Bwb3NpdGVQbGFjZW1lbnQsIGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KG9wcG9zaXRlUGxhY2VtZW50KV07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBmbGlwKF9yZWYpIHtcclxuICAgIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXHJcbiAgICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcclxuICAgICAgICBuYW1lID0gX3JlZi5uYW1lO1xyXG5cclxuICAgIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdLl9za2lwKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgX29wdGlvbnMkbWFpbkF4aXMgPSBvcHRpb25zLm1haW5BeGlzLFxyXG4gICAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxyXG4gICAgICAgIF9vcHRpb25zJGFsdEF4aXMgPSBvcHRpb25zLmFsdEF4aXMsXHJcbiAgICAgICAgY2hlY2tBbHRBeGlzID0gX29wdGlvbnMkYWx0QXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGFsdEF4aXMsXHJcbiAgICAgICAgc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzID0gb3B0aW9ucy5mYWxsYmFja1BsYWNlbWVudHMsXHJcbiAgICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcclxuICAgICAgICBib3VuZGFyeSA9IG9wdGlvbnMuYm91bmRhcnksXHJcbiAgICAgICAgcm9vdEJvdW5kYXJ5ID0gb3B0aW9ucy5yb290Qm91bmRhcnksXHJcbiAgICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxyXG4gICAgICAgIF9vcHRpb25zJGZsaXBWYXJpYXRpbyA9IG9wdGlvbnMuZmxpcFZhcmlhdGlvbnMsXHJcbiAgICAgICAgZmxpcFZhcmlhdGlvbnMgPSBfb3B0aW9ucyRmbGlwVmFyaWF0aW8gPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRmbGlwVmFyaWF0aW8sXHJcbiAgICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gb3B0aW9ucy5hbGxvd2VkQXV0b1BsYWNlbWVudHM7XHJcbiAgICB2YXIgcHJlZmVycmVkUGxhY2VtZW50ID0gc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQ7XHJcbiAgICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocHJlZmVycmVkUGxhY2VtZW50KTtcclxuICAgIHZhciBpc0Jhc2VQbGFjZW1lbnQgPSBiYXNlUGxhY2VtZW50ID09PSBwcmVmZXJyZWRQbGFjZW1lbnQ7XHJcbiAgICB2YXIgZmFsbGJhY2tQbGFjZW1lbnRzID0gc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzIHx8IChpc0Jhc2VQbGFjZW1lbnQgfHwgIWZsaXBWYXJpYXRpb25zID8gW2dldE9wcG9zaXRlUGxhY2VtZW50KHByZWZlcnJlZFBsYWNlbWVudCldIDogZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMocHJlZmVycmVkUGxhY2VtZW50KSk7XHJcbiAgICB2YXIgcGxhY2VtZW50cyA9IFtwcmVmZXJyZWRQbGFjZW1lbnRdLmNvbmNhdChmYWxsYmFja1BsYWNlbWVudHMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcclxuICAgICAgcmV0dXJuIGFjYy5jb25jYXQoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvID8gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIHtcclxuICAgICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcclxuICAgICAgICBib3VuZGFyeTogYm91bmRhcnksXHJcbiAgICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXHJcbiAgICAgICAgcGFkZGluZzogcGFkZGluZyxcclxuICAgICAgICBmbGlwVmFyaWF0aW9uczogZmxpcFZhcmlhdGlvbnMsXHJcbiAgICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzOiBhbGxvd2VkQXV0b1BsYWNlbWVudHNcclxuICAgICAgfSkgOiBwbGFjZW1lbnQpO1xyXG4gICAgfSwgW10pO1xyXG4gICAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XHJcbiAgICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcclxuICAgIHZhciBjaGVja3NNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICB2YXIgbWFrZUZhbGxiYWNrQ2hlY2tzID0gdHJ1ZTtcclxuICAgIHZhciBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRzWzBdO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGxhY2VtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgcGxhY2VtZW50ID0gcGxhY2VtZW50c1tpXTtcclxuXHJcbiAgICAgIHZhciBfYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KTtcclxuXHJcbiAgICAgIHZhciBpc1N0YXJ0VmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgPT09IHN0YXJ0O1xyXG4gICAgICB2YXIgaXNWZXJ0aWNhbCA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihfYmFzZVBsYWNlbWVudCkgPj0gMDtcclxuICAgICAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XHJcbiAgICAgIHZhciBvdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XHJcbiAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXHJcbiAgICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxyXG4gICAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxyXG4gICAgICAgIGFsdEJvdW5kYXJ5OiBhbHRCb3VuZGFyeSxcclxuICAgICAgICBwYWRkaW5nOiBwYWRkaW5nXHJcbiAgICAgIH0pO1xyXG4gICAgICB2YXIgbWFpblZhcmlhdGlvblNpZGUgPSBpc1ZlcnRpY2FsID8gaXNTdGFydFZhcmlhdGlvbiA/IHJpZ2h0IDogbGVmdCA6IGlzU3RhcnRWYXJpYXRpb24gPyBib3R0b20gOiB0b3A7XHJcblxyXG4gICAgICBpZiAocmVmZXJlbmNlUmVjdFtsZW5dID4gcG9wcGVyUmVjdFtsZW5dKSB7XHJcbiAgICAgICAgbWFpblZhcmlhdGlvblNpZGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluVmFyaWF0aW9uU2lkZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBhbHRWYXJpYXRpb25TaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpblZhcmlhdGlvblNpZGUpO1xyXG4gICAgICB2YXIgY2hlY2tzID0gW107XHJcblxyXG4gICAgICBpZiAoY2hlY2tNYWluQXhpcykge1xyXG4gICAgICAgIGNoZWNrcy5wdXNoKG92ZXJmbG93W19iYXNlUGxhY2VtZW50XSA8PSAwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGNoZWNrQWx0QXhpcykge1xyXG4gICAgICAgIGNoZWNrcy5wdXNoKG92ZXJmbG93W21haW5WYXJpYXRpb25TaWRlXSA8PSAwLCBvdmVyZmxvd1thbHRWYXJpYXRpb25TaWRlXSA8PSAwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGNoZWNrcy5ldmVyeShmdW5jdGlvbiAoY2hlY2spIHtcclxuICAgICAgICByZXR1cm4gY2hlY2s7XHJcbiAgICAgIH0pKSB7XHJcbiAgICAgICAgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50O1xyXG4gICAgICAgIG1ha2VGYWxsYmFja0NoZWNrcyA9IGZhbHNlO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjaGVja3NNYXAuc2V0KHBsYWNlbWVudCwgY2hlY2tzKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobWFrZUZhbGxiYWNrQ2hlY2tzKSB7XHJcbiAgICAgIC8vIGAyYCBtYXkgYmUgZGVzaXJlZCBpbiBzb21lIGNhc2VzIOKAkyByZXNlYXJjaCBsYXRlclxyXG4gICAgICB2YXIgbnVtYmVyT2ZDaGVja3MgPSBmbGlwVmFyaWF0aW9ucyA/IDMgOiAxO1xyXG5cclxuICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoX2kpIHtcclxuICAgICAgICB2YXIgZml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHMuZmluZChmdW5jdGlvbiAocGxhY2VtZW50KSB7XHJcbiAgICAgICAgICB2YXIgY2hlY2tzID0gY2hlY2tzTWFwLmdldChwbGFjZW1lbnQpO1xyXG5cclxuICAgICAgICAgIGlmIChjaGVja3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNoZWNrcy5zbGljZSgwLCBfaSkuZXZlcnkoZnVuY3Rpb24gKGNoZWNrKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKGZpdHRpbmdQbGFjZW1lbnQpIHtcclxuICAgICAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IGZpdHRpbmdQbGFjZW1lbnQ7XHJcbiAgICAgICAgICByZXR1cm4gXCJicmVha1wiO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIGZvciAodmFyIF9pID0gbnVtYmVyT2ZDaGVja3M7IF9pID4gMDsgX2ktLSkge1xyXG4gICAgICAgIHZhciBfcmV0ID0gX2xvb3AoX2kpO1xyXG5cclxuICAgICAgICBpZiAoX3JldCA9PT0gXCJicmVha1wiKSBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChzdGF0ZS5wbGFjZW1lbnQgIT09IGZpcnN0Rml0dGluZ1BsYWNlbWVudCkge1xyXG4gICAgICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdLl9za2lwID0gdHJ1ZTtcclxuICAgICAgc3RhdGUucGxhY2VtZW50ID0gZmlyc3RGaXR0aW5nUGxhY2VtZW50O1xyXG4gICAgICBzdGF0ZS5yZXNldCA9IHRydWU7XHJcbiAgICB9XHJcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXHJcblxyXG5cclxuICBjb25zdCBmbGlwJDEgPSB7XHJcbiAgICBuYW1lOiAnZmxpcCcsXHJcbiAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgcGhhc2U6ICdtYWluJyxcclxuICAgIGZuOiBmbGlwLFxyXG4gICAgcmVxdWlyZXNJZkV4aXN0czogWydvZmZzZXQnXSxcclxuICAgIGRhdGE6IHtcclxuICAgICAgX3NraXA6IGZhbHNlXHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3QsIHByZXZlbnRlZE9mZnNldHMpIHtcclxuICAgIGlmIChwcmV2ZW50ZWRPZmZzZXRzID09PSB2b2lkIDApIHtcclxuICAgICAgcHJldmVudGVkT2Zmc2V0cyA9IHtcclxuICAgICAgICB4OiAwLFxyXG4gICAgICAgIHk6IDBcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0b3A6IG92ZXJmbG93LnRvcCAtIHJlY3QuaGVpZ2h0IC0gcHJldmVudGVkT2Zmc2V0cy55LFxyXG4gICAgICByaWdodDogb3ZlcmZsb3cucmlnaHQgLSByZWN0LndpZHRoICsgcHJldmVudGVkT2Zmc2V0cy54LFxyXG4gICAgICBib3R0b206IG92ZXJmbG93LmJvdHRvbSAtIHJlY3QuaGVpZ2h0ICsgcHJldmVudGVkT2Zmc2V0cy55LFxyXG4gICAgICBsZWZ0OiBvdmVyZmxvdy5sZWZ0IC0gcmVjdC53aWR0aCAtIHByZXZlbnRlZE9mZnNldHMueFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChvdmVyZmxvdykge1xyXG4gICAgcmV0dXJuIFt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRdLnNvbWUoZnVuY3Rpb24gKHNpZGUpIHtcclxuICAgICAgcmV0dXJuIG92ZXJmbG93W3NpZGVdID49IDA7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGhpZGUoX3JlZikge1xyXG4gICAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcclxuICAgICAgICBuYW1lID0gX3JlZi5uYW1lO1xyXG4gICAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XHJcbiAgICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcclxuICAgIHZhciBwcmV2ZW50ZWRPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wcmV2ZW50T3ZlcmZsb3c7XHJcbiAgICB2YXIgcmVmZXJlbmNlT3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xyXG4gICAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZSdcclxuICAgIH0pO1xyXG4gICAgdmFyIHBvcHBlckFsdE92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcclxuICAgICAgYWx0Qm91bmRhcnk6IHRydWVcclxuICAgIH0pO1xyXG4gICAgdmFyIHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKHJlZmVyZW5jZU92ZXJmbG93LCByZWZlcmVuY2VSZWN0KTtcclxuICAgIHZhciBwb3BwZXJFc2NhcGVPZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMocG9wcGVyQWx0T3ZlcmZsb3csIHBvcHBlclJlY3QsIHByZXZlbnRlZE9mZnNldHMpO1xyXG4gICAgdmFyIGlzUmVmZXJlbmNlSGlkZGVuID0gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyk7XHJcbiAgICB2YXIgaGFzUG9wcGVyRXNjYXBlZCA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChwb3BwZXJFc2NhcGVPZmZzZXRzKTtcclxuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSB7XHJcbiAgICAgIHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0czogcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzLFxyXG4gICAgICBwb3BwZXJFc2NhcGVPZmZzZXRzOiBwb3BwZXJFc2NhcGVPZmZzZXRzLFxyXG4gICAgICBpc1JlZmVyZW5jZUhpZGRlbjogaXNSZWZlcmVuY2VIaWRkZW4sXHJcbiAgICAgIGhhc1BvcHBlckVzY2FwZWQ6IGhhc1BvcHBlckVzY2FwZWRcclxuICAgIH07XHJcbiAgICBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyLCB7XHJcbiAgICAgICdkYXRhLXBvcHBlci1yZWZlcmVuY2UtaGlkZGVuJzogaXNSZWZlcmVuY2VIaWRkZW4sXHJcbiAgICAgICdkYXRhLXBvcHBlci1lc2NhcGVkJzogaGFzUG9wcGVyRXNjYXBlZFxyXG4gICAgfSk7XHJcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXHJcblxyXG5cclxuICBjb25zdCBoaWRlJDEgPSB7XHJcbiAgICBuYW1lOiAnaGlkZScsXHJcbiAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgcGhhc2U6ICdtYWluJyxcclxuICAgIHJlcXVpcmVzSWZFeGlzdHM6IFsncHJldmVudE92ZXJmbG93J10sXHJcbiAgICBmbjogaGlkZVxyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKHBsYWNlbWVudCwgcmVjdHMsIG9mZnNldCkge1xyXG4gICAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XHJcbiAgICB2YXIgaW52ZXJ0RGlzdGFuY2UgPSBbbGVmdCwgdG9wXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDAgPyAtMSA6IDE7XHJcblxyXG4gICAgdmFyIF9yZWYgPSB0eXBlb2Ygb2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gb2Zmc2V0KE9iamVjdC5hc3NpZ24oe30sIHJlY3RzLCB7XHJcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50XHJcbiAgICB9KSkgOiBvZmZzZXQsXHJcbiAgICAgICAgc2tpZGRpbmcgPSBfcmVmWzBdLFxyXG4gICAgICAgIGRpc3RhbmNlID0gX3JlZlsxXTtcclxuXHJcbiAgICBza2lkZGluZyA9IHNraWRkaW5nIHx8IDA7XHJcbiAgICBkaXN0YW5jZSA9IChkaXN0YW5jZSB8fCAwKSAqIGludmVydERpc3RhbmNlO1xyXG4gICAgcmV0dXJuIFtsZWZ0LCByaWdodF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwID8ge1xyXG4gICAgICB4OiBkaXN0YW5jZSxcclxuICAgICAgeTogc2tpZGRpbmdcclxuICAgIH0gOiB7XHJcbiAgICAgIHg6IHNraWRkaW5nLFxyXG4gICAgICB5OiBkaXN0YW5jZVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG9mZnNldChfcmVmMikge1xyXG4gICAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXHJcbiAgICAgICAgb3B0aW9ucyA9IF9yZWYyLm9wdGlvbnMsXHJcbiAgICAgICAgbmFtZSA9IF9yZWYyLm5hbWU7XHJcbiAgICB2YXIgX29wdGlvbnMkb2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQsXHJcbiAgICAgICAgb2Zmc2V0ID0gX29wdGlvbnMkb2Zmc2V0ID09PSB2b2lkIDAgPyBbMCwgMF0gOiBfb3B0aW9ucyRvZmZzZXQ7XHJcbiAgICB2YXIgZGF0YSA9IHBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xyXG4gICAgICBhY2NbcGxhY2VtZW50XSA9IGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKHBsYWNlbWVudCwgc3RhdGUucmVjdHMsIG9mZnNldCk7XHJcbiAgICAgIHJldHVybiBhY2M7XHJcbiAgICB9LCB7fSk7XHJcbiAgICB2YXIgX2RhdGEkc3RhdGUkcGxhY2VtZW50ID0gZGF0YVtzdGF0ZS5wbGFjZW1lbnRdLFxyXG4gICAgICAgIHggPSBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQueCxcclxuICAgICAgICB5ID0gX2RhdGEkc3RhdGUkcGxhY2VtZW50Lnk7XHJcblxyXG4gICAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAhPSBudWxsKSB7XHJcbiAgICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy54ICs9IHg7XHJcbiAgICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy55ICs9IHk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGRhdGE7XHJcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXHJcblxyXG5cclxuICBjb25zdCBvZmZzZXQkMSA9IHtcclxuICAgIG5hbWU6ICdvZmZzZXQnLFxyXG4gICAgZW5hYmxlZDogdHJ1ZSxcclxuICAgIHBoYXNlOiAnbWFpbicsXHJcbiAgICByZXF1aXJlczogWydwb3BwZXJPZmZzZXRzJ10sXHJcbiAgICBmbjogb2Zmc2V0XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gcG9wcGVyT2Zmc2V0cyhfcmVmKSB7XHJcbiAgICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxyXG4gICAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XHJcbiAgICAvLyBPZmZzZXRzIGFyZSB0aGUgYWN0dWFsIHBvc2l0aW9uIHRoZSBwb3BwZXIgbmVlZHMgdG8gaGF2ZSB0byBiZVxyXG4gICAgLy8gcHJvcGVybHkgcG9zaXRpb25lZCBuZWFyIGl0cyByZWZlcmVuY2UgZWxlbWVudFxyXG4gICAgLy8gVGhpcyBpcyB0aGUgbW9zdCBiYXNpYyBwbGFjZW1lbnQsIGFuZCB3aWxsIGJlIGFkanVzdGVkIGJ5XHJcbiAgICAvLyB0aGUgbW9kaWZpZXJzIGluIHRoZSBuZXh0IHN0ZXBcclxuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBjb21wdXRlT2Zmc2V0cyh7XHJcbiAgICAgIHJlZmVyZW5jZTogc3RhdGUucmVjdHMucmVmZXJlbmNlLFxyXG4gICAgICBlbGVtZW50OiBzdGF0ZS5yZWN0cy5wb3BwZXIsXHJcbiAgICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxyXG4gICAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxyXG4gICAgfSk7XHJcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXHJcblxyXG5cclxuICBjb25zdCBwb3BwZXJPZmZzZXRzJDEgPSB7XHJcbiAgICBuYW1lOiAncG9wcGVyT2Zmc2V0cycsXHJcbiAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgcGhhc2U6ICdyZWFkJyxcclxuICAgIGZuOiBwb3BwZXJPZmZzZXRzLFxyXG4gICAgZGF0YToge31cclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBnZXRBbHRBeGlzKGF4aXMpIHtcclxuICAgIHJldHVybiBheGlzID09PSAneCcgPyAneScgOiAneCc7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwcmV2ZW50T3ZlcmZsb3coX3JlZikge1xyXG4gICAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcclxuICAgICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxyXG4gICAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XHJcbiAgICB2YXIgX29wdGlvbnMkbWFpbkF4aXMgPSBvcHRpb25zLm1haW5BeGlzLFxyXG4gICAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxyXG4gICAgICAgIF9vcHRpb25zJGFsdEF4aXMgPSBvcHRpb25zLmFsdEF4aXMsXHJcbiAgICAgICAgY2hlY2tBbHRBeGlzID0gX29wdGlvbnMkYWx0QXhpcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRhbHRBeGlzLFxyXG4gICAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcclxuICAgICAgICByb290Qm91bmRhcnkgPSBvcHRpb25zLnJvb3RCb3VuZGFyeSxcclxuICAgICAgICBhbHRCb3VuZGFyeSA9IG9wdGlvbnMuYWx0Qm91bmRhcnksXHJcbiAgICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcclxuICAgICAgICBfb3B0aW9ucyR0ZXRoZXIgPSBvcHRpb25zLnRldGhlcixcclxuICAgICAgICB0ZXRoZXIgPSBfb3B0aW9ucyR0ZXRoZXIgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyR0ZXRoZXIsXHJcbiAgICAgICAgX29wdGlvbnMkdGV0aGVyT2Zmc2V0ID0gb3B0aW9ucy50ZXRoZXJPZmZzZXQsXHJcbiAgICAgICAgdGV0aGVyT2Zmc2V0ID0gX29wdGlvbnMkdGV0aGVyT2Zmc2V0ID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkdGV0aGVyT2Zmc2V0O1xyXG4gICAgdmFyIG92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcclxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxyXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcclxuICAgICAgcGFkZGluZzogcGFkZGluZyxcclxuICAgICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5XHJcbiAgICB9KTtcclxuICAgIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xyXG4gICAgdmFyIHZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihzdGF0ZS5wbGFjZW1lbnQpO1xyXG4gICAgdmFyIGlzQmFzZVBsYWNlbWVudCA9ICF2YXJpYXRpb247XHJcbiAgICB2YXIgbWFpbkF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCk7XHJcbiAgICB2YXIgYWx0QXhpcyA9IGdldEFsdEF4aXMobWFpbkF4aXMpO1xyXG4gICAgdmFyIHBvcHBlck9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHM7XHJcbiAgICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcclxuICAgIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xyXG4gICAgdmFyIHRldGhlck9mZnNldFZhbHVlID0gdHlwZW9mIHRldGhlck9mZnNldCA9PT0gJ2Z1bmN0aW9uJyA/IHRldGhlck9mZnNldChPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5yZWN0cywge1xyXG4gICAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxyXG4gICAgfSkpIDogdGV0aGVyT2Zmc2V0O1xyXG4gICAgdmFyIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZSA9IHR5cGVvZiB0ZXRoZXJPZmZzZXRWYWx1ZSA9PT0gJ251bWJlcicgPyB7XHJcbiAgICAgIG1haW5BeGlzOiB0ZXRoZXJPZmZzZXRWYWx1ZSxcclxuICAgICAgYWx0QXhpczogdGV0aGVyT2Zmc2V0VmFsdWVcclxuICAgIH0gOiBPYmplY3QuYXNzaWduKHtcclxuICAgICAgbWFpbkF4aXM6IDAsXHJcbiAgICAgIGFsdEF4aXM6IDBcclxuICAgIH0sIHRldGhlck9mZnNldFZhbHVlKTtcclxuICAgIHZhciBvZmZzZXRNb2RpZmllclN0YXRlID0gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXQgPyBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldFtzdGF0ZS5wbGFjZW1lbnRdIDogbnVsbDtcclxuICAgIHZhciBkYXRhID0ge1xyXG4gICAgICB4OiAwLFxyXG4gICAgICB5OiAwXHJcbiAgICB9O1xyXG5cclxuICAgIGlmICghcG9wcGVyT2Zmc2V0cykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcclxuICAgICAgdmFyIF9vZmZzZXRNb2RpZmllclN0YXRlJDtcclxuXHJcbiAgICAgIHZhciBtYWluU2lkZSA9IG1haW5BeGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xyXG4gICAgICB2YXIgYWx0U2lkZSA9IG1haW5BeGlzID09PSAneScgPyBib3R0b20gOiByaWdodDtcclxuICAgICAgdmFyIGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XHJcbiAgICAgIHZhciBvZmZzZXQgPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXTtcclxuICAgICAgdmFyIG1pbiQxID0gb2Zmc2V0ICsgb3ZlcmZsb3dbbWFpblNpZGVdO1xyXG4gICAgICB2YXIgbWF4JDEgPSBvZmZzZXQgLSBvdmVyZmxvd1thbHRTaWRlXTtcclxuICAgICAgdmFyIGFkZGl0aXZlID0gdGV0aGVyID8gLXBvcHBlclJlY3RbbGVuXSAvIDIgOiAwO1xyXG4gICAgICB2YXIgbWluTGVuID0gdmFyaWF0aW9uID09PSBzdGFydCA/IHJlZmVyZW5jZVJlY3RbbGVuXSA6IHBvcHBlclJlY3RbbGVuXTtcclxuICAgICAgdmFyIG1heExlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyAtcG9wcGVyUmVjdFtsZW5dIDogLXJlZmVyZW5jZVJlY3RbbGVuXTsgLy8gV2UgbmVlZCB0byBpbmNsdWRlIHRoZSBhcnJvdyBpbiB0aGUgY2FsY3VsYXRpb24gc28gdGhlIGFycm93IGRvZXNuJ3QgZ29cclxuICAgICAgLy8gb3V0c2lkZSB0aGUgcmVmZXJlbmNlIGJvdW5kc1xyXG5cclxuICAgICAgdmFyIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xyXG4gICAgICB2YXIgYXJyb3dSZWN0ID0gdGV0aGVyICYmIGFycm93RWxlbWVudCA/IGdldExheW91dFJlY3QoYXJyb3dFbGVtZW50KSA6IHtcclxuICAgICAgICB3aWR0aDogMCxcclxuICAgICAgICBoZWlnaHQ6IDBcclxuICAgICAgfTtcclxuICAgICAgdmFyIGFycm93UGFkZGluZ09iamVjdCA9IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXSA/IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXS5wYWRkaW5nIDogZ2V0RnJlc2hTaWRlT2JqZWN0KCk7XHJcbiAgICAgIHZhciBhcnJvd1BhZGRpbmdNaW4gPSBhcnJvd1BhZGRpbmdPYmplY3RbbWFpblNpZGVdO1xyXG4gICAgICB2YXIgYXJyb3dQYWRkaW5nTWF4ID0gYXJyb3dQYWRkaW5nT2JqZWN0W2FsdFNpZGVdOyAvLyBJZiB0aGUgcmVmZXJlbmNlIGxlbmd0aCBpcyBzbWFsbGVyIHRoYW4gdGhlIGFycm93IGxlbmd0aCwgd2UgZG9uJ3Qgd2FudFxyXG4gICAgICAvLyB0byBpbmNsdWRlIGl0cyBmdWxsIHNpemUgaW4gdGhlIGNhbGN1bGF0aW9uLiBJZiB0aGUgcmVmZXJlbmNlIGlzIHNtYWxsXHJcbiAgICAgIC8vIGFuZCBuZWFyIHRoZSBlZGdlIG9mIGEgYm91bmRhcnksIHRoZSBwb3BwZXIgY2FuIG92ZXJmbG93IGV2ZW4gaWYgdGhlXHJcbiAgICAgIC8vIHJlZmVyZW5jZSBpcyBub3Qgb3ZlcmZsb3dpbmcgYXMgd2VsbCAoZS5nLiB2aXJ0dWFsIGVsZW1lbnRzIHdpdGggbm9cclxuICAgICAgLy8gd2lkdGggb3IgaGVpZ2h0KVxyXG5cclxuICAgICAgdmFyIGFycm93TGVuID0gd2l0aGluKDAsIHJlZmVyZW5jZVJlY3RbbGVuXSwgYXJyb3dSZWN0W2xlbl0pO1xyXG4gICAgICB2YXIgbWluT2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50ID8gcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiAtIGFkZGl0aXZlIC0gYXJyb3dMZW4gLSBhcnJvd1BhZGRpbmdNaW4gLSBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXMgOiBtaW5MZW4gLSBhcnJvd0xlbiAtIGFycm93UGFkZGluZ01pbiAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcztcclxuICAgICAgdmFyIG1heE9mZnNldCA9IGlzQmFzZVBsYWNlbWVudCA/IC1yZWZlcmVuY2VSZWN0W2xlbl0gLyAyICsgYWRkaXRpdmUgKyBhcnJvd0xlbiArIGFycm93UGFkZGluZ01heCArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcyA6IG1heExlbiArIGFycm93TGVuICsgYXJyb3dQYWRkaW5nTWF4ICsgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzO1xyXG4gICAgICB2YXIgYXJyb3dPZmZzZXRQYXJlbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdyAmJiBnZXRPZmZzZXRQYXJlbnQoc3RhdGUuZWxlbWVudHMuYXJyb3cpO1xyXG4gICAgICB2YXIgY2xpZW50T2Zmc2V0ID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBtYWluQXhpcyA9PT0gJ3knID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50VG9wIHx8IDAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRMZWZ0IHx8IDAgOiAwO1xyXG4gICAgICB2YXIgb2Zmc2V0TW9kaWZpZXJWYWx1ZSA9IChfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQgPSBvZmZzZXRNb2RpZmllclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBvZmZzZXRNb2RpZmllclN0YXRlW21haW5BeGlzXSkgIT0gbnVsbCA/IF9vZmZzZXRNb2RpZmllclN0YXRlJCA6IDA7XHJcbiAgICAgIHZhciB0ZXRoZXJNaW4gPSBvZmZzZXQgKyBtaW5PZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlIC0gY2xpZW50T2Zmc2V0O1xyXG4gICAgICB2YXIgdGV0aGVyTWF4ID0gb2Zmc2V0ICsgbWF4T2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZTtcclxuICAgICAgdmFyIHByZXZlbnRlZE9mZnNldCA9IHdpdGhpbih0ZXRoZXIgPyBtaW4obWluJDEsIHRldGhlck1pbikgOiBtaW4kMSwgb2Zmc2V0LCB0ZXRoZXIgPyBtYXgobWF4JDEsIHRldGhlck1heCkgOiBtYXgkMSk7XHJcbiAgICAgIHBvcHBlck9mZnNldHNbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0O1xyXG4gICAgICBkYXRhW21haW5BeGlzXSA9IHByZXZlbnRlZE9mZnNldCAtIG9mZnNldDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY2hlY2tBbHRBeGlzKSB7XHJcbiAgICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyO1xyXG5cclxuICAgICAgdmFyIF9tYWluU2lkZSA9IG1haW5BeGlzID09PSAneCcgPyB0b3AgOiBsZWZ0O1xyXG5cclxuICAgICAgdmFyIF9hbHRTaWRlID0gbWFpbkF4aXMgPT09ICd4JyA/IGJvdHRvbSA6IHJpZ2h0O1xyXG5cclxuICAgICAgdmFyIF9vZmZzZXQgPSBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdO1xyXG5cclxuICAgICAgdmFyIF9sZW4gPSBhbHRBeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XHJcblxyXG4gICAgICB2YXIgX21pbiA9IF9vZmZzZXQgKyBvdmVyZmxvd1tfbWFpblNpZGVdO1xyXG5cclxuICAgICAgdmFyIF9tYXggPSBfb2Zmc2V0IC0gb3ZlcmZsb3dbX2FsdFNpZGVdO1xyXG5cclxuICAgICAgdmFyIGlzT3JpZ2luU2lkZSA9IFt0b3AsIGxlZnRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xyXG5cclxuICAgICAgdmFyIF9vZmZzZXRNb2RpZmllclZhbHVlID0gKF9vZmZzZXRNb2RpZmllclN0YXRlJDIgPSBvZmZzZXRNb2RpZmllclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBvZmZzZXRNb2RpZmllclN0YXRlW2FsdEF4aXNdKSAhPSBudWxsID8gX29mZnNldE1vZGlmaWVyU3RhdGUkMiA6IDA7XHJcblxyXG4gICAgICB2YXIgX3RldGhlck1pbiA9IGlzT3JpZ2luU2lkZSA/IF9taW4gOiBfb2Zmc2V0IC0gcmVmZXJlbmNlUmVjdFtfbGVuXSAtIHBvcHBlclJlY3RbX2xlbl0gLSBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5hbHRBeGlzO1xyXG5cclxuICAgICAgdmFyIF90ZXRoZXJNYXggPSBpc09yaWdpblNpZGUgPyBfb2Zmc2V0ICsgcmVmZXJlbmNlUmVjdFtfbGVuXSArIHBvcHBlclJlY3RbX2xlbl0gLSBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5hbHRBeGlzIDogX21heDtcclxuXHJcbiAgICAgIHZhciBfcHJldmVudGVkT2Zmc2V0ID0gdGV0aGVyICYmIGlzT3JpZ2luU2lkZSA/IHdpdGhpbk1heENsYW1wKF90ZXRoZXJNaW4sIF9vZmZzZXQsIF90ZXRoZXJNYXgpIDogd2l0aGluKHRldGhlciA/IF90ZXRoZXJNaW4gOiBfbWluLCBfb2Zmc2V0LCB0ZXRoZXIgPyBfdGV0aGVyTWF4IDogX21heCk7XHJcblxyXG4gICAgICBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdID0gX3ByZXZlbnRlZE9mZnNldDtcclxuICAgICAgZGF0YVthbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQgLSBfb2Zmc2V0O1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xyXG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xyXG5cclxuXHJcbiAgY29uc3QgcHJldmVudE92ZXJmbG93JDEgPSB7XHJcbiAgICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcclxuICAgIGVuYWJsZWQ6IHRydWUsXHJcbiAgICBwaGFzZTogJ21haW4nLFxyXG4gICAgZm46IHByZXZlbnRPdmVyZmxvdyxcclxuICAgIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J11cclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBnZXRIVE1MRWxlbWVudFNjcm9sbChlbGVtZW50KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbExlZnQsXHJcbiAgICAgIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxUb3BcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXROb2RlU2Nyb2xsKG5vZGUpIHtcclxuICAgIGlmIChub2RlID09PSBnZXRXaW5kb3cobm9kZSkgfHwgIWlzSFRNTEVsZW1lbnQobm9kZSkpIHtcclxuICAgICAgcmV0dXJuIGdldFdpbmRvd1Njcm9sbChub2RlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBnZXRIVE1MRWxlbWVudFNjcm9sbChub2RlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGlzRWxlbWVudFNjYWxlZChlbGVtZW50KSB7XHJcbiAgICB2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICB2YXIgc2NhbGVYID0gcm91bmQocmVjdC53aWR0aCkgLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDE7XHJcbiAgICB2YXIgc2NhbGVZID0gcm91bmQocmVjdC5oZWlnaHQpIC8gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMTtcclxuICAgIHJldHVybiBzY2FsZVggIT09IDEgfHwgc2NhbGVZICE9PSAxO1xyXG4gIH0gLy8gUmV0dXJucyB0aGUgY29tcG9zaXRlIHJlY3Qgb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byBpdHMgb2Zmc2V0UGFyZW50LlxyXG4gIC8vIENvbXBvc2l0ZSBtZWFucyBpdCB0YWtlcyBpbnRvIGFjY291bnQgdHJhbnNmb3JtcyBhcyB3ZWxsIGFzIGxheW91dC5cclxuXHJcblxyXG4gIGZ1bmN0aW9uIGdldENvbXBvc2l0ZVJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQsIG9mZnNldFBhcmVudCwgaXNGaXhlZCkge1xyXG4gICAgaWYgKGlzRml4ZWQgPT09IHZvaWQgMCkge1xyXG4gICAgICBpc0ZpeGVkID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xyXG4gICAgdmFyIG9mZnNldFBhcmVudElzU2NhbGVkID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGlzRWxlbWVudFNjYWxlZChvZmZzZXRQYXJlbnQpO1xyXG4gICAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGdldERvY3VtZW50RWxlbWVudChvZmZzZXRQYXJlbnQpO1xyXG4gICAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQsIG9mZnNldFBhcmVudElzU2NhbGVkLCBpc0ZpeGVkKTtcclxuICAgIHZhciBzY3JvbGwgPSB7XHJcbiAgICAgIHNjcm9sbExlZnQ6IDAsXHJcbiAgICAgIHNjcm9sbFRvcDogMFxyXG4gICAgfTtcclxuICAgIHZhciBvZmZzZXRzID0ge1xyXG4gICAgICB4OiAwLFxyXG4gICAgICB5OiAwXHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgIWlzRml4ZWQpIHtcclxuICAgICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEwNzhcclxuICAgICAgaXNTY3JvbGxQYXJlbnQoZG9jdW1lbnRFbGVtZW50KSkge1xyXG4gICAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xyXG4gICAgICAgIG9mZnNldHMgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50LCB0cnVlKTtcclxuICAgICAgICBvZmZzZXRzLnggKz0gb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XHJcbiAgICAgICAgb2Zmc2V0cy55ICs9IG9mZnNldFBhcmVudC5jbGllbnRUb3A7XHJcbiAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnRFbGVtZW50KSB7XHJcbiAgICAgICAgb2Zmc2V0cy54ID0gZ2V0V2luZG93U2Nyb2xsQmFyWChkb2N1bWVudEVsZW1lbnQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgeDogcmVjdC5sZWZ0ICsgc2Nyb2xsLnNjcm9sbExlZnQgLSBvZmZzZXRzLngsXHJcbiAgICAgIHk6IHJlY3QudG9wICsgc2Nyb2xsLnNjcm9sbFRvcCAtIG9mZnNldHMueSxcclxuICAgICAgd2lkdGg6IHJlY3Qud2lkdGgsXHJcbiAgICAgIGhlaWdodDogcmVjdC5oZWlnaHRcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBvcmRlcihtb2RpZmllcnMpIHtcclxuICAgIHZhciBtYXAgPSBuZXcgTWFwKCk7XHJcbiAgICB2YXIgdmlzaXRlZCA9IG5ldyBTZXQoKTtcclxuICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xyXG4gICAgICBtYXAuc2V0KG1vZGlmaWVyLm5hbWUsIG1vZGlmaWVyKTtcclxuICAgIH0pOyAvLyBPbiB2aXNpdGluZyBvYmplY3QsIGNoZWNrIGZvciBpdHMgZGVwZW5kZW5jaWVzIGFuZCB2aXNpdCB0aGVtIHJlY3Vyc2l2ZWx5XHJcblxyXG4gICAgZnVuY3Rpb24gc29ydChtb2RpZmllcikge1xyXG4gICAgICB2aXNpdGVkLmFkZChtb2RpZmllci5uYW1lKTtcclxuICAgICAgdmFyIHJlcXVpcmVzID0gW10uY29uY2F0KG1vZGlmaWVyLnJlcXVpcmVzIHx8IFtdLCBtb2RpZmllci5yZXF1aXJlc0lmRXhpc3RzIHx8IFtdKTtcclxuICAgICAgcmVxdWlyZXMuZm9yRWFjaChmdW5jdGlvbiAoZGVwKSB7XHJcbiAgICAgICAgaWYgKCF2aXNpdGVkLmhhcyhkZXApKSB7XHJcbiAgICAgICAgICB2YXIgZGVwTW9kaWZpZXIgPSBtYXAuZ2V0KGRlcCk7XHJcblxyXG4gICAgICAgICAgaWYgKGRlcE1vZGlmaWVyKSB7XHJcbiAgICAgICAgICAgIHNvcnQoZGVwTW9kaWZpZXIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHJlc3VsdC5wdXNoKG1vZGlmaWVyKTtcclxuICAgIH1cclxuXHJcbiAgICBtb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcclxuICAgICAgaWYgKCF2aXNpdGVkLmhhcyhtb2RpZmllci5uYW1lKSkge1xyXG4gICAgICAgIC8vIGNoZWNrIGZvciB2aXNpdGVkIG9iamVjdFxyXG4gICAgICAgIHNvcnQobW9kaWZpZXIpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBvcmRlck1vZGlmaWVycyhtb2RpZmllcnMpIHtcclxuICAgIC8vIG9yZGVyIGJhc2VkIG9uIGRlcGVuZGVuY2llc1xyXG4gICAgdmFyIG9yZGVyZWRNb2RpZmllcnMgPSBvcmRlcihtb2RpZmllcnMpOyAvLyBvcmRlciBiYXNlZCBvbiBwaGFzZVxyXG5cclxuICAgIHJldHVybiBtb2RpZmllclBoYXNlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGhhc2UpIHtcclxuICAgICAgcmV0dXJuIGFjYy5jb25jYXQob3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG1vZGlmaWVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vZGlmaWVyLnBoYXNlID09PSBwaGFzZTtcclxuICAgICAgfSkpO1xyXG4gICAgfSwgW10pO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZGVib3VuY2UoZm4pIHtcclxuICAgIHZhciBwZW5kaW5nO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgaWYgKCFwZW5kaW5nKSB7XHJcbiAgICAgICAgcGVuZGluZyA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcGVuZGluZyA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgcmVzb2x2ZShmbigpKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcGVuZGluZztcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBtZXJnZUJ5TmFtZShtb2RpZmllcnMpIHtcclxuICAgIHZhciBtZXJnZWQgPSBtb2RpZmllcnMucmVkdWNlKGZ1bmN0aW9uIChtZXJnZWQsIGN1cnJlbnQpIHtcclxuICAgICAgdmFyIGV4aXN0aW5nID0gbWVyZ2VkW2N1cnJlbnQubmFtZV07XHJcbiAgICAgIG1lcmdlZFtjdXJyZW50Lm5hbWVdID0gZXhpc3RpbmcgPyBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZywgY3VycmVudCwge1xyXG4gICAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLm9wdGlvbnMsIGN1cnJlbnQub3B0aW9ucyksXHJcbiAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcuZGF0YSwgY3VycmVudC5kYXRhKVxyXG4gICAgICB9KSA6IGN1cnJlbnQ7XHJcbiAgICAgIHJldHVybiBtZXJnZWQ7XHJcbiAgICB9LCB7fSk7IC8vIElFMTEgZG9lcyBub3Qgc3VwcG9ydCBPYmplY3QudmFsdWVzXHJcblxyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG1lcmdlZCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgcmV0dXJuIG1lcmdlZFtrZXldO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICB2YXIgREVGQVVMVF9PUFRJT05TID0ge1xyXG4gICAgcGxhY2VtZW50OiAnYm90dG9tJyxcclxuICAgIG1vZGlmaWVyczogW10sXHJcbiAgICBzdHJhdGVneTogJ2Fic29sdXRlJ1xyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIGFyZVZhbGlkRWxlbWVudHMoKSB7XHJcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcclxuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gIWFyZ3Muc29tZShmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICByZXR1cm4gIShlbGVtZW50ICYmIHR5cGVvZiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCA9PT0gJ2Z1bmN0aW9uJyk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBvcHBlckdlbmVyYXRvcihnZW5lcmF0b3JPcHRpb25zKSB7XHJcbiAgICBpZiAoZ2VuZXJhdG9yT3B0aW9ucyA9PT0gdm9pZCAwKSB7XHJcbiAgICAgIGdlbmVyYXRvck9wdGlvbnMgPSB7fTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgX2dlbmVyYXRvck9wdGlvbnMgPSBnZW5lcmF0b3JPcHRpb25zLFxyXG4gICAgICAgIF9nZW5lcmF0b3JPcHRpb25zJGRlZiA9IF9nZW5lcmF0b3JPcHRpb25zLmRlZmF1bHRNb2RpZmllcnMsXHJcbiAgICAgICAgZGVmYXVsdE1vZGlmaWVycyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZiA9PT0gdm9pZCAwID8gW10gOiBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYsXHJcbiAgICAgICAgX2dlbmVyYXRvck9wdGlvbnMkZGVmMiA9IF9nZW5lcmF0b3JPcHRpb25zLmRlZmF1bHRPcHRpb25zLFxyXG4gICAgICAgIGRlZmF1bHRPcHRpb25zID0gX2dlbmVyYXRvck9wdGlvbnMkZGVmMiA9PT0gdm9pZCAwID8gREVGQVVMVF9PUFRJT05TIDogX2dlbmVyYXRvck9wdGlvbnMkZGVmMjtcclxuICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVQb3BwZXIocmVmZXJlbmNlLCBwb3BwZXIsIG9wdGlvbnMpIHtcclxuICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xyXG4gICAgICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHN0YXRlID0ge1xyXG4gICAgICAgIHBsYWNlbWVudDogJ2JvdHRvbScsXHJcbiAgICAgICAgb3JkZXJlZE1vZGlmaWVyczogW10sXHJcbiAgICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBkZWZhdWx0T3B0aW9ucyksXHJcbiAgICAgICAgbW9kaWZpZXJzRGF0YToge30sXHJcbiAgICAgICAgZWxlbWVudHM6IHtcclxuICAgICAgICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlLFxyXG4gICAgICAgICAgcG9wcGVyOiBwb3BwZXJcclxuICAgICAgICB9LFxyXG4gICAgICAgIGF0dHJpYnV0ZXM6IHt9LFxyXG4gICAgICAgIHN0eWxlczoge31cclxuICAgICAgfTtcclxuICAgICAgdmFyIGVmZmVjdENsZWFudXBGbnMgPSBbXTtcclxuICAgICAgdmFyIGlzRGVzdHJveWVkID0gZmFsc2U7XHJcbiAgICAgIHZhciBpbnN0YW5jZSA9IHtcclxuICAgICAgICBzdGF0ZTogc3RhdGUsXHJcbiAgICAgICAgc2V0T3B0aW9uczogZnVuY3Rpb24gc2V0T3B0aW9ucyhzZXRPcHRpb25zQWN0aW9uKSB7XHJcbiAgICAgICAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBzZXRPcHRpb25zQWN0aW9uID09PSAnZnVuY3Rpb24nID8gc2V0T3B0aW9uc0FjdGlvbihzdGF0ZS5vcHRpb25zKSA6IHNldE9wdGlvbnNBY3Rpb247XHJcbiAgICAgICAgICBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCk7XHJcbiAgICAgICAgICBzdGF0ZS5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIHN0YXRlLm9wdGlvbnMsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgc3RhdGUuc2Nyb2xsUGFyZW50cyA9IHtcclxuICAgICAgICAgICAgcmVmZXJlbmNlOiBpc0VsZW1lbnQocmVmZXJlbmNlKSA/IGxpc3RTY3JvbGxQYXJlbnRzKHJlZmVyZW5jZSkgOiByZWZlcmVuY2UuY29udGV4dEVsZW1lbnQgPyBsaXN0U2Nyb2xsUGFyZW50cyhyZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpIDogW10sXHJcbiAgICAgICAgICAgIHBvcHBlcjogbGlzdFNjcm9sbFBhcmVudHMocG9wcGVyKVxyXG4gICAgICAgICAgfTsgLy8gT3JkZXJzIHRoZSBtb2RpZmllcnMgYmFzZWQgb24gdGhlaXIgZGVwZW5kZW5jaWVzIGFuZCBgcGhhc2VgXHJcbiAgICAgICAgICAvLyBwcm9wZXJ0aWVzXHJcblxyXG4gICAgICAgICAgdmFyIG9yZGVyZWRNb2RpZmllcnMgPSBvcmRlck1vZGlmaWVycyhtZXJnZUJ5TmFtZShbXS5jb25jYXQoZGVmYXVsdE1vZGlmaWVycywgc3RhdGUub3B0aW9ucy5tb2RpZmllcnMpKSk7IC8vIFN0cmlwIG91dCBkaXNhYmxlZCBtb2RpZmllcnNcclxuXHJcbiAgICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG0uZW5hYmxlZDtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgcnVuTW9kaWZpZXJFZmZlY3RzKCk7XHJcbiAgICAgICAgICByZXR1cm4gaW5zdGFuY2UudXBkYXRlKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBTeW5jIHVwZGF0ZSDigJMgaXQgd2lsbCBhbHdheXMgYmUgZXhlY3V0ZWQsIGV2ZW4gaWYgbm90IG5lY2Vzc2FyeS4gVGhpc1xyXG4gICAgICAgIC8vIGlzIHVzZWZ1bCBmb3IgbG93IGZyZXF1ZW5jeSB1cGRhdGVzIHdoZXJlIHN5bmMgYmVoYXZpb3Igc2ltcGxpZmllcyB0aGVcclxuICAgICAgICAvLyBsb2dpYy5cclxuICAgICAgICAvLyBGb3IgaGlnaCBmcmVxdWVuY3kgdXBkYXRlcyAoZS5nLiBgcmVzaXplYCBhbmQgYHNjcm9sbGAgZXZlbnRzKSwgYWx3YXlzXHJcbiAgICAgICAgLy8gcHJlZmVyIHRoZSBhc3luYyBQb3BwZXIjdXBkYXRlIG1ldGhvZFxyXG4gICAgICAgIGZvcmNlVXBkYXRlOiBmdW5jdGlvbiBmb3JjZVVwZGF0ZSgpIHtcclxuICAgICAgICAgIGlmIChpc0Rlc3Ryb3llZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmFyIF9zdGF0ZSRlbGVtZW50cyA9IHN0YXRlLmVsZW1lbnRzLFxyXG4gICAgICAgICAgICAgIHJlZmVyZW5jZSA9IF9zdGF0ZSRlbGVtZW50cy5yZWZlcmVuY2UsXHJcbiAgICAgICAgICAgICAgcG9wcGVyID0gX3N0YXRlJGVsZW1lbnRzLnBvcHBlcjsgLy8gRG9uJ3QgcHJvY2VlZCBpZiBgcmVmZXJlbmNlYCBvciBgcG9wcGVyYCBhcmUgbm90IHZhbGlkIGVsZW1lbnRzXHJcbiAgICAgICAgICAvLyBhbnltb3JlXHJcblxyXG4gICAgICAgICAgaWYgKCFhcmVWYWxpZEVsZW1lbnRzKHJlZmVyZW5jZSwgcG9wcGVyKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9IC8vIFN0b3JlIHRoZSByZWZlcmVuY2UgYW5kIHBvcHBlciByZWN0cyB0byBiZSByZWFkIGJ5IG1vZGlmaWVyc1xyXG5cclxuXHJcbiAgICAgICAgICBzdGF0ZS5yZWN0cyA9IHtcclxuICAgICAgICAgICAgcmVmZXJlbmNlOiBnZXRDb21wb3NpdGVSZWN0KHJlZmVyZW5jZSwgZ2V0T2Zmc2V0UGFyZW50KHBvcHBlciksIHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3kgPT09ICdmaXhlZCcpLFxyXG4gICAgICAgICAgICBwb3BwZXI6IGdldExheW91dFJlY3QocG9wcGVyKVxyXG4gICAgICAgICAgfTsgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gcmVzZXQgdGhlIGN1cnJlbnQgdXBkYXRlIGN5Y2xlLiBUaGVcclxuICAgICAgICAgIC8vIG1vc3QgY29tbW9uIHVzZSBjYXNlIGZvciB0aGlzIGlzIHRoZSBgZmxpcGAgbW9kaWZpZXIgY2hhbmdpbmcgdGhlXHJcbiAgICAgICAgICAvLyBwbGFjZW1lbnQsIHdoaWNoIHRoZW4gbmVlZHMgdG8gcmUtcnVuIGFsbCB0aGUgbW9kaWZpZXJzLCBiZWNhdXNlIHRoZVxyXG4gICAgICAgICAgLy8gbG9naWMgd2FzIHByZXZpb3VzbHkgcmFuIGZvciB0aGUgcHJldmlvdXMgcGxhY2VtZW50IGFuZCBpcyB0aGVyZWZvcmVcclxuICAgICAgICAgIC8vIHN0YWxlL2luY29ycmVjdFxyXG5cclxuICAgICAgICAgIHN0YXRlLnJlc2V0ID0gZmFsc2U7XHJcbiAgICAgICAgICBzdGF0ZS5wbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDsgLy8gT24gZWFjaCB1cGRhdGUgY3ljbGUsIHRoZSBgbW9kaWZpZXJzRGF0YWAgcHJvcGVydHkgZm9yIGVhY2ggbW9kaWZpZXJcclxuICAgICAgICAgIC8vIGlzIGZpbGxlZCB3aXRoIHRoZSBpbml0aWFsIGRhdGEgc3BlY2lmaWVkIGJ5IHRoZSBtb2RpZmllci4gVGhpcyBtZWFuc1xyXG4gICAgICAgICAgLy8gaXQgZG9lc24ndCBwZXJzaXN0IGFuZCBpcyBmcmVzaCBvbiBlYWNoIHVwZGF0ZS5cclxuICAgICAgICAgIC8vIFRvIGVuc3VyZSBwZXJzaXN0ZW50IGRhdGEsIHVzZSBgJHtuYW1lfSNwZXJzaXN0ZW50YFxyXG5cclxuICAgICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLm1vZGlmaWVyc0RhdGFbbW9kaWZpZXIubmFtZV0gPSBPYmplY3QuYXNzaWduKHt9LCBtb2RpZmllci5kYXRhKTtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICBpZiAoc3RhdGUucmVzZXQgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgIGluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBfc3RhdGUkb3JkZXJlZE1vZGlmaWUgPSBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzW2luZGV4XSxcclxuICAgICAgICAgICAgICAgIGZuID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLmZuLFxyXG4gICAgICAgICAgICAgICAgX3N0YXRlJG9yZGVyZWRNb2RpZmllMiA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5vcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgX29wdGlvbnMgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyID09PSB2b2lkIDAgPyB7fSA6IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIsXHJcbiAgICAgICAgICAgICAgICBuYW1lID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLm5hbWU7XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgc3RhdGUgPSBmbih7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBfb3B0aW9ucyxcclxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2VcclxuICAgICAgICAgICAgICB9KSB8fCBzdGF0ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gQXN5bmMgYW5kIG9wdGltaXN0aWNhbGx5IG9wdGltaXplZCB1cGRhdGUg4oCTIGl0IHdpbGwgbm90IGJlIGV4ZWN1dGVkIGlmXHJcbiAgICAgICAgLy8gbm90IG5lY2Vzc2FyeSAoZGVib3VuY2VkIHRvIHJ1biBhdCBtb3N0IG9uY2UtcGVyLXRpY2spXHJcbiAgICAgICAgdXBkYXRlOiBkZWJvdW5jZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcclxuICAgICAgICAgICAgcmVzb2x2ZShzdGF0ZSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KSxcclxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xyXG4gICAgICAgICAgY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpO1xyXG4gICAgICAgICAgaXNEZXN0cm95ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIGlmICghYXJlVmFsaWRFbGVtZW50cyhyZWZlcmVuY2UsIHBvcHBlcikpIHtcclxuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucykudGhlbihmdW5jdGlvbiAoc3RhdGUpIHtcclxuICAgICAgICBpZiAoIWlzRGVzdHJveWVkICYmIG9wdGlvbnMub25GaXJzdFVwZGF0ZSkge1xyXG4gICAgICAgICAgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKHN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pOyAvLyBNb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byBleGVjdXRlIGFyYml0cmFyeSBjb2RlIGJlZm9yZSB0aGUgZmlyc3RcclxuICAgICAgLy8gdXBkYXRlIGN5Y2xlIHJ1bnMuIFRoZXkgd2lsbCBiZSBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgdXBkYXRlXHJcbiAgICAgIC8vIGN5Y2xlLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGEgbW9kaWZpZXIgYWRkcyBzb21lIHBlcnNpc3RlbnQgZGF0YSB0aGF0XHJcbiAgICAgIC8vIG90aGVyIG1vZGlmaWVycyBuZWVkIHRvIHVzZSwgYnV0IHRoZSBtb2RpZmllciBpcyBydW4gYWZ0ZXIgdGhlIGRlcGVuZGVudFxyXG4gICAgICAvLyBvbmUuXHJcblxyXG4gICAgICBmdW5jdGlvbiBydW5Nb2RpZmllckVmZmVjdHMoKSB7XHJcbiAgICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XHJcbiAgICAgICAgICB2YXIgbmFtZSA9IF9yZWYubmFtZSxcclxuICAgICAgICAgICAgICBfcmVmJG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgb3B0aW9ucyA9IF9yZWYkb3B0aW9ucyA9PT0gdm9pZCAwID8ge30gOiBfcmVmJG9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgZWZmZWN0ID0gX3JlZi5lZmZlY3Q7XHJcblxyXG4gICAgICAgICAgaWYgKHR5cGVvZiBlZmZlY3QgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdmFyIGNsZWFudXBGbiA9IGVmZmVjdCh7XHJcbiAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxyXG4gICAgICAgICAgICAgIG5hbWU6IG5hbWUsXHJcbiAgICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxyXG4gICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgbm9vcEZuID0gZnVuY3Rpb24gbm9vcEZuKCkge307XHJcblxyXG4gICAgICAgICAgICBlZmZlY3RDbGVhbnVwRm5zLnB1c2goY2xlYW51cEZuIHx8IG5vb3BGbik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKSB7XHJcbiAgICAgICAgZWZmZWN0Q2xlYW51cEZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgICAgcmV0dXJuIGZuKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZWZmZWN0Q2xlYW51cEZucyA9IFtdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gaW5zdGFuY2U7XHJcbiAgICB9O1xyXG4gIH1cclxuICB2YXIgY3JlYXRlUG9wcGVyJDIgPSAvKiNfX1BVUkVfXyovcG9wcGVyR2VuZXJhdG9yKCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcclxuXHJcbiAgdmFyIGRlZmF1bHRNb2RpZmllcnMkMSA9IFtldmVudExpc3RlbmVycywgcG9wcGVyT2Zmc2V0cyQxLCBjb21wdXRlU3R5bGVzJDEsIGFwcGx5U3R5bGVzJDFdO1xyXG4gIHZhciBjcmVhdGVQb3BwZXIkMSA9IC8qI19fUFVSRV9fKi9wb3BwZXJHZW5lcmF0b3Ioe1xyXG4gICAgZGVmYXVsdE1vZGlmaWVyczogZGVmYXVsdE1vZGlmaWVycyQxXHJcbiAgfSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcclxuXHJcbiAgdmFyIGRlZmF1bHRNb2RpZmllcnMgPSBbZXZlbnRMaXN0ZW5lcnMsIHBvcHBlck9mZnNldHMkMSwgY29tcHV0ZVN0eWxlcyQxLCBhcHBseVN0eWxlcyQxLCBvZmZzZXQkMSwgZmxpcCQxLCBwcmV2ZW50T3ZlcmZsb3ckMSwgYXJyb3ckMSwgaGlkZSQxXTtcclxuICB2YXIgY3JlYXRlUG9wcGVyID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcih7XHJcbiAgICBkZWZhdWx0TW9kaWZpZXJzOiBkZWZhdWx0TW9kaWZpZXJzXHJcbiAgfSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcclxuXHJcbiAgY29uc3QgUG9wcGVyID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoLyojX19QVVJFX18qL09iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XHJcbiAgICBfX3Byb3RvX186IG51bGwsXHJcbiAgICBhZnRlck1haW4sXHJcbiAgICBhZnRlclJlYWQsXHJcbiAgICBhZnRlcldyaXRlLFxyXG4gICAgYXBwbHlTdHlsZXM6IGFwcGx5U3R5bGVzJDEsXHJcbiAgICBhcnJvdzogYXJyb3ckMSxcclxuICAgIGF1dG8sXHJcbiAgICBiYXNlUGxhY2VtZW50cyxcclxuICAgIGJlZm9yZU1haW4sXHJcbiAgICBiZWZvcmVSZWFkLFxyXG4gICAgYmVmb3JlV3JpdGUsXHJcbiAgICBib3R0b20sXHJcbiAgICBjbGlwcGluZ1BhcmVudHMsXHJcbiAgICBjb21wdXRlU3R5bGVzOiBjb21wdXRlU3R5bGVzJDEsXHJcbiAgICBjcmVhdGVQb3BwZXIsXHJcbiAgICBjcmVhdGVQb3BwZXJCYXNlOiBjcmVhdGVQb3BwZXIkMixcclxuICAgIGNyZWF0ZVBvcHBlckxpdGU6IGNyZWF0ZVBvcHBlciQxLFxyXG4gICAgZGV0ZWN0T3ZlcmZsb3csXHJcbiAgICBlbmQsXHJcbiAgICBldmVudExpc3RlbmVycyxcclxuICAgIGZsaXA6IGZsaXAkMSxcclxuICAgIGhpZGU6IGhpZGUkMSxcclxuICAgIGxlZnQsXHJcbiAgICBtYWluLFxyXG4gICAgbW9kaWZpZXJQaGFzZXMsXHJcbiAgICBvZmZzZXQ6IG9mZnNldCQxLFxyXG4gICAgcGxhY2VtZW50cyxcclxuICAgIHBvcHBlcixcclxuICAgIHBvcHBlckdlbmVyYXRvcixcclxuICAgIHBvcHBlck9mZnNldHM6IHBvcHBlck9mZnNldHMkMSxcclxuICAgIHByZXZlbnRPdmVyZmxvdzogcHJldmVudE92ZXJmbG93JDEsXHJcbiAgICByZWFkLFxyXG4gICAgcmVmZXJlbmNlLFxyXG4gICAgcmlnaHQsXHJcbiAgICBzdGFydCxcclxuICAgIHRvcCxcclxuICAgIHZhcmlhdGlvblBsYWNlbWVudHMsXHJcbiAgICB2aWV3cG9ydCxcclxuICAgIHdyaXRlXHJcbiAgfSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICogQm9vdHN0cmFwIGRyb3Bkb3duLmpzXHJcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKi9cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0YW50c1xyXG4gICAqL1xyXG5cclxuICBjb25zdCBOQU1FJGEgPSAnZHJvcGRvd24nO1xyXG4gIGNvbnN0IERBVEFfS0VZJDYgPSAnYnMuZHJvcGRvd24nO1xyXG4gIGNvbnN0IEVWRU5UX0tFWSQ2ID0gYC4ke0RBVEFfS0VZJDZ9YDtcclxuICBjb25zdCBEQVRBX0FQSV9LRVkkMyA9ICcuZGF0YS1hcGknO1xyXG4gIGNvbnN0IEVTQ0FQRV9LRVkkMiA9ICdFc2NhcGUnO1xyXG4gIGNvbnN0IFRBQl9LRVkkMSA9ICdUYWInO1xyXG4gIGNvbnN0IEFSUk9XX1VQX0tFWSQxID0gJ0Fycm93VXAnO1xyXG4gIGNvbnN0IEFSUk9XX0RPV05fS0VZJDEgPSAnQXJyb3dEb3duJztcclxuICBjb25zdCBSSUdIVF9NT1VTRV9CVVRUT04gPSAyOyAvLyBNb3VzZUV2ZW50LmJ1dHRvbiB2YWx1ZSBmb3IgdGhlIHNlY29uZGFyeSBidXR0b24sIHVzdWFsbHkgdGhlIHJpZ2h0IGJ1dHRvblxyXG5cclxuICBjb25zdCBFVkVOVF9ISURFJDUgPSBgaGlkZSR7RVZFTlRfS0VZJDZ9YDtcclxuICBjb25zdCBFVkVOVF9ISURERU4kNSA9IGBoaWRkZW4ke0VWRU5UX0tFWSQ2fWA7XHJcbiAgY29uc3QgRVZFTlRfU0hPVyQ1ID0gYHNob3cke0VWRU5UX0tFWSQ2fWA7XHJcbiAgY29uc3QgRVZFTlRfU0hPV04kNSA9IGBzaG93biR7RVZFTlRfS0VZJDZ9YDtcclxuICBjb25zdCBFVkVOVF9DTElDS19EQVRBX0FQSSQzID0gYGNsaWNrJHtFVkVOVF9LRVkkNn0ke0RBVEFfQVBJX0tFWSQzfWA7XHJcbiAgY29uc3QgRVZFTlRfS0VZRE9XTl9EQVRBX0FQSSA9IGBrZXlkb3duJHtFVkVOVF9LRVkkNn0ke0RBVEFfQVBJX0tFWSQzfWA7XHJcbiAgY29uc3QgRVZFTlRfS0VZVVBfREFUQV9BUEkgPSBga2V5dXAke0VWRU5UX0tFWSQ2fSR7REFUQV9BUElfS0VZJDN9YDtcclxuICBjb25zdCBDTEFTU19OQU1FX1NIT1ckNiA9ICdzaG93JztcclxuICBjb25zdCBDTEFTU19OQU1FX0RST1BVUCA9ICdkcm9wdXAnO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfRFJPUEVORCA9ICdkcm9wZW5kJztcclxuICBjb25zdCBDTEFTU19OQU1FX0RST1BTVEFSVCA9ICdkcm9wc3RhcnQnO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfRFJPUFVQX0NFTlRFUiA9ICdkcm9wdXAtY2VudGVyJztcclxuICBjb25zdCBDTEFTU19OQU1FX0RST1BET1dOX0NFTlRFUiA9ICdkcm9wZG93bi1jZW50ZXInO1xyXG4gIGNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFJDMgPSAnW2RhdGEtYnMtdG9nZ2xlPVwiZHJvcGRvd25cIl06bm90KC5kaXNhYmxlZCk6bm90KDpkaXNhYmxlZCknO1xyXG4gIGNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFX1NIT1dOID0gYCR7U0VMRUNUT1JfREFUQV9UT0dHTEUkM30uJHtDTEFTU19OQU1FX1NIT1ckNn1gO1xyXG4gIGNvbnN0IFNFTEVDVE9SX01FTlUgPSAnLmRyb3Bkb3duLW1lbnUnO1xyXG4gIGNvbnN0IFNFTEVDVE9SX05BVkJBUiA9ICcubmF2YmFyJztcclxuICBjb25zdCBTRUxFQ1RPUl9OQVZCQVJfTkFWID0gJy5uYXZiYXItbmF2JztcclxuICBjb25zdCBTRUxFQ1RPUl9WSVNJQkxFX0lURU1TID0gJy5kcm9wZG93bi1tZW51IC5kcm9wZG93bi1pdGVtOm5vdCguZGlzYWJsZWQpOm5vdCg6ZGlzYWJsZWQpJztcclxuICBjb25zdCBQTEFDRU1FTlRfVE9QID0gaXNSVEwoKSA/ICd0b3AtZW5kJyA6ICd0b3Atc3RhcnQnO1xyXG4gIGNvbnN0IFBMQUNFTUVOVF9UT1BFTkQgPSBpc1JUTCgpID8gJ3RvcC1zdGFydCcgOiAndG9wLWVuZCc7XHJcbiAgY29uc3QgUExBQ0VNRU5UX0JPVFRPTSA9IGlzUlRMKCkgPyAnYm90dG9tLWVuZCcgOiAnYm90dG9tLXN0YXJ0JztcclxuICBjb25zdCBQTEFDRU1FTlRfQk9UVE9NRU5EID0gaXNSVEwoKSA/ICdib3R0b20tc3RhcnQnIDogJ2JvdHRvbS1lbmQnO1xyXG4gIGNvbnN0IFBMQUNFTUVOVF9SSUdIVCA9IGlzUlRMKCkgPyAnbGVmdC1zdGFydCcgOiAncmlnaHQtc3RhcnQnO1xyXG4gIGNvbnN0IFBMQUNFTUVOVF9MRUZUID0gaXNSVEwoKSA/ICdyaWdodC1zdGFydCcgOiAnbGVmdC1zdGFydCc7XHJcbiAgY29uc3QgUExBQ0VNRU5UX1RPUENFTlRFUiA9ICd0b3AnO1xyXG4gIGNvbnN0IFBMQUNFTUVOVF9CT1RUT01DRU5URVIgPSAnYm90dG9tJztcclxuICBjb25zdCBEZWZhdWx0JDkgPSB7XHJcbiAgICBhdXRvQ2xvc2U6IHRydWUsXHJcbiAgICBib3VuZGFyeTogJ2NsaXBwaW5nUGFyZW50cycsXHJcbiAgICBkaXNwbGF5OiAnZHluYW1pYycsXHJcbiAgICBvZmZzZXQ6IFswLCAyXSxcclxuICAgIHBvcHBlckNvbmZpZzogbnVsbCxcclxuICAgIHJlZmVyZW5jZTogJ3RvZ2dsZSdcclxuICB9O1xyXG4gIGNvbnN0IERlZmF1bHRUeXBlJDkgPSB7XHJcbiAgICBhdXRvQ2xvc2U6ICcoYm9vbGVhbnxzdHJpbmcpJyxcclxuICAgIGJvdW5kYXJ5OiAnKHN0cmluZ3xlbGVtZW50KScsXHJcbiAgICBkaXNwbGF5OiAnc3RyaW5nJyxcclxuICAgIG9mZnNldDogJyhhcnJheXxzdHJpbmd8ZnVuY3Rpb24pJyxcclxuICAgIHBvcHBlckNvbmZpZzogJyhudWxsfG9iamVjdHxmdW5jdGlvbiknLFxyXG4gICAgcmVmZXJlbmNlOiAnKHN0cmluZ3xlbGVtZW50fG9iamVjdCknXHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxyXG4gICAqL1xyXG5cclxuICBjbGFzcyBEcm9wZG93biBleHRlbmRzIEJhc2VDb21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XHJcbiAgICAgIHN1cGVyKGVsZW1lbnQsIGNvbmZpZyk7XHJcbiAgICAgIHRoaXMuX3BvcHBlciA9IG51bGw7XHJcbiAgICAgIHRoaXMuX3BhcmVudCA9IHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZTsgLy8gZHJvcGRvd24gd3JhcHBlclxyXG4gICAgICAvLyBUT0RPOiB2NiByZXZlcnQgIzM3MDExICYgY2hhbmdlIG1hcmt1cCBodHRwczovL2dldGJvb3RzdHJhcC5jb20vZG9jcy81LjMvZm9ybXMvaW5wdXQtZ3JvdXAvXHJcbiAgICAgIHRoaXMuX21lbnUgPSBTZWxlY3RvckVuZ2luZS5uZXh0KHRoaXMuX2VsZW1lbnQsIFNFTEVDVE9SX01FTlUpWzBdIHx8IFNlbGVjdG9yRW5naW5lLnByZXYodGhpcy5fZWxlbWVudCwgU0VMRUNUT1JfTUVOVSlbMF0gfHwgU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9NRU5VLCB0aGlzLl9wYXJlbnQpO1xyXG4gICAgICB0aGlzLl9pbk5hdmJhciA9IHRoaXMuX2RldGVjdE5hdmJhcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldHRlcnNcclxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcclxuICAgICAgcmV0dXJuIERlZmF1bHQkOTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XHJcbiAgICAgIHJldHVybiBEZWZhdWx0VHlwZSQ5O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xyXG4gICAgICByZXR1cm4gTkFNRSRhO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFB1YmxpY1xyXG4gICAgdG9nZ2xlKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5faXNTaG93bigpID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3coKTtcclxuICAgIH1cclxuICAgIHNob3coKSB7XHJcbiAgICAgIGlmIChpc0Rpc2FibGVkKHRoaXMuX2VsZW1lbnQpIHx8IHRoaXMuX2lzU2hvd24oKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0ge1xyXG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcclxuICAgICAgfTtcclxuICAgICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPVyQ1LCByZWxhdGVkVGFyZ2V0KTtcclxuICAgICAgaWYgKHNob3dFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHBlcigpO1xyXG5cclxuICAgICAgLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIGFkZCBleHRyYVxyXG4gICAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHRvIHRoZSBib2R5J3MgaW1tZWRpYXRlIGNoaWxkcmVuO1xyXG4gICAgICAvLyBvbmx5IG5lZWRlZCBiZWNhdXNlIG9mIGJyb2tlbiBldmVudCBkZWxlZ2F0aW9uIG9uIGlPU1xyXG4gICAgICAvLyBodHRwczovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTQvMDIvbW91c2VfZXZlbnRfYnViLmh0bWxcclxuICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiAhdGhpcy5fcGFyZW50LmNsb3Nlc3QoU0VMRUNUT1JfTkFWQkFSX05BVikpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgW10uY29uY2F0KC4uLmRvY3VtZW50LmJvZHkuY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICBFdmVudEhhbmRsZXIub24oZWxlbWVudCwgJ21vdXNlb3ZlcicsIG5vb3ApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9lbGVtZW50LmZvY3VzKCk7XHJcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSk7XHJcbiAgICAgIHRoaXMuX21lbnUuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1ckNik7XHJcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1ckNik7XHJcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOJDUsIHJlbGF0ZWRUYXJnZXQpO1xyXG4gICAgfVxyXG4gICAgaGlkZSgpIHtcclxuICAgICAgaWYgKGlzRGlzYWJsZWQodGhpcy5fZWxlbWVudCkgfHwgIXRoaXMuX2lzU2hvd24oKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0ge1xyXG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5fY29tcGxldGVIaWRlKHJlbGF0ZWRUYXJnZXQpO1xyXG4gICAgfVxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgaWYgKHRoaXMuX3BvcHBlcikge1xyXG4gICAgICAgIHRoaXMuX3BvcHBlci5kZXN0cm95KCk7XHJcbiAgICAgIH1cclxuICAgICAgc3VwZXIuZGlzcG9zZSgpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKCkge1xyXG4gICAgICB0aGlzLl9pbk5hdmJhciA9IHRoaXMuX2RldGVjdE5hdmJhcigpO1xyXG4gICAgICBpZiAodGhpcy5fcG9wcGVyKSB7XHJcbiAgICAgICAgdGhpcy5fcG9wcGVyLnVwZGF0ZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHJpdmF0ZVxyXG4gICAgX2NvbXBsZXRlSGlkZShyZWxhdGVkVGFyZ2V0KSB7XHJcbiAgICAgIGNvbnN0IGhpZGVFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREUkNSwgcmVsYXRlZFRhcmdldCk7XHJcbiAgICAgIGlmIChoaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIHJlbW92ZSB0aGUgZXh0cmFcclxuICAgICAgLy8gZW1wdHkgbW91c2VvdmVyIGxpc3RlbmVycyB3ZSBhZGRlZCBmb3IgaU9TIHN1cHBvcnRcclxuICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBbXS5jb25jYXQoLi4uZG9jdW1lbnQuYm9keS5jaGlsZHJlbikpIHtcclxuICAgICAgICAgIEV2ZW50SGFuZGxlci5vZmYoZWxlbWVudCwgJ21vdXNlb3ZlcicsIG5vb3ApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5fcG9wcGVyKSB7XHJcbiAgICAgICAgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9tZW51LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDYpO1xyXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDYpO1xyXG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xyXG4gICAgICBNYW5pcHVsYXRvci5yZW1vdmVEYXRhQXR0cmlidXRlKHRoaXMuX21lbnUsICdwb3BwZXInKTtcclxuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElEREVOJDUsIHJlbGF0ZWRUYXJnZXQpO1xyXG4gICAgfVxyXG4gICAgX2dldENvbmZpZyhjb25maWcpIHtcclxuICAgICAgY29uZmlnID0gc3VwZXIuX2dldENvbmZpZyhjb25maWcpO1xyXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWZlcmVuY2UgPT09ICdvYmplY3QnICYmICFpc0VsZW1lbnQkMShjb25maWcucmVmZXJlbmNlKSAmJiB0eXBlb2YgY29uZmlnLnJlZmVyZW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAvLyBQb3BwZXIgdmlydHVhbCBlbGVtZW50cyByZXF1aXJlIGEgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG1ldGhvZFxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7TkFNRSRhLnRvVXBwZXJDYXNlKCl9OiBPcHRpb24gXCJyZWZlcmVuY2VcIiBwcm92aWRlZCB0eXBlIFwib2JqZWN0XCIgd2l0aG91dCBhIHJlcXVpcmVkIFwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XCIgbWV0aG9kLmApO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBjb25maWc7XHJcbiAgICB9XHJcbiAgICBfY3JlYXRlUG9wcGVyKCkge1xyXG4gICAgICBpZiAodHlwZW9mIFBvcHBlciA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb290c3RyYXBcXCdzIGRyb3Bkb3ducyByZXF1aXJlIFBvcHBlciAoaHR0cHM6Ly9wb3BwZXIuanMub3JnKScpO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCByZWZlcmVuY2VFbGVtZW50ID0gdGhpcy5fZWxlbWVudDtcclxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UgPT09ICdwYXJlbnQnKSB7XHJcbiAgICAgICAgcmVmZXJlbmNlRWxlbWVudCA9IHRoaXMuX3BhcmVudDtcclxuICAgICAgfSBlbHNlIGlmIChpc0VsZW1lbnQkMSh0aGlzLl9jb25maWcucmVmZXJlbmNlKSkge1xyXG4gICAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSBnZXRFbGVtZW50KHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UpO1xyXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9jb25maWcucmVmZXJlbmNlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSB0aGlzLl9jb25maWcucmVmZXJlbmNlO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHBvcHBlckNvbmZpZyA9IHRoaXMuX2dldFBvcHBlckNvbmZpZygpO1xyXG4gICAgICB0aGlzLl9wb3BwZXIgPSBjcmVhdGVQb3BwZXIocmVmZXJlbmNlRWxlbWVudCwgdGhpcy5fbWVudSwgcG9wcGVyQ29uZmlnKTtcclxuICAgIH1cclxuICAgIF9pc1Nob3duKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fbWVudS5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XJDYpO1xyXG4gICAgfVxyXG4gICAgX2dldFBsYWNlbWVudCgpIHtcclxuICAgICAgY29uc3QgcGFyZW50RHJvcGRvd24gPSB0aGlzLl9wYXJlbnQ7XHJcbiAgICAgIGlmIChwYXJlbnREcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9EUk9QRU5EKSkge1xyXG4gICAgICAgIHJldHVybiBQTEFDRU1FTlRfUklHSFQ7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHBhcmVudERyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BTVEFSVCkpIHtcclxuICAgICAgICByZXR1cm4gUExBQ0VNRU5UX0xFRlQ7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHBhcmVudERyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BVUF9DRU5URVIpKSB7XHJcbiAgICAgICAgcmV0dXJuIFBMQUNFTUVOVF9UT1BDRU5URVI7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHBhcmVudERyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BET1dOX0NFTlRFUikpIHtcclxuICAgICAgICByZXR1cm4gUExBQ0VNRU5UX0JPVFRPTUNFTlRFUjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gV2UgbmVlZCB0byB0cmltIHRoZSB2YWx1ZSBiZWNhdXNlIGN1c3RvbSBwcm9wZXJ0aWVzIGNhbiBhbHNvIGluY2x1ZGUgc3BhY2VzXHJcbiAgICAgIGNvbnN0IGlzRW5kID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9tZW51KS5nZXRQcm9wZXJ0eVZhbHVlKCctLWJzLXBvc2l0aW9uJykudHJpbSgpID09PSAnZW5kJztcclxuICAgICAgaWYgKHBhcmVudERyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BVUCkpIHtcclxuICAgICAgICByZXR1cm4gaXNFbmQgPyBQTEFDRU1FTlRfVE9QRU5EIDogUExBQ0VNRU5UX1RPUDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gaXNFbmQgPyBQTEFDRU1FTlRfQk9UVE9NRU5EIDogUExBQ0VNRU5UX0JPVFRPTTtcclxuICAgIH1cclxuICAgIF9kZXRlY3ROYXZiYXIoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmNsb3Nlc3QoU0VMRUNUT1JfTkFWQkFSKSAhPT0gbnVsbDtcclxuICAgIH1cclxuICAgIF9nZXRPZmZzZXQoKSB7XHJcbiAgICAgIGNvbnN0IHtcclxuICAgICAgICBvZmZzZXRcclxuICAgICAgfSA9IHRoaXMuX2NvbmZpZztcclxuICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIG9mZnNldC5zcGxpdCgnLCcpLm1hcCh2YWx1ZSA9PiBOdW1iZXIucGFyc2VJbnQodmFsdWUsIDEwKSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICByZXR1cm4gcG9wcGVyRGF0YSA9PiBvZmZzZXQocG9wcGVyRGF0YSwgdGhpcy5fZWxlbWVudCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG9mZnNldDtcclxuICAgIH1cclxuICAgIF9nZXRQb3BwZXJDb25maWcoKSB7XHJcbiAgICAgIGNvbnN0IGRlZmF1bHRCc1BvcHBlckNvbmZpZyA9IHtcclxuICAgICAgICBwbGFjZW1lbnQ6IHRoaXMuX2dldFBsYWNlbWVudCgpLFxyXG4gICAgICAgIG1vZGlmaWVyczogW3tcclxuICAgICAgICAgIG5hbWU6ICdwcmV2ZW50T3ZlcmZsb3cnLFxyXG4gICAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICBib3VuZGFyeTogdGhpcy5fY29uZmlnLmJvdW5kYXJ5XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSwge1xyXG4gICAgICAgICAgbmFtZTogJ29mZnNldCcsXHJcbiAgICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy5fZ2V0T2Zmc2V0KClcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gRGlzYWJsZSBQb3BwZXIgaWYgd2UgaGF2ZSBhIHN0YXRpYyBkaXNwbGF5IG9yIERyb3Bkb3duIGlzIGluIE5hdmJhclxyXG4gICAgICBpZiAodGhpcy5faW5OYXZiYXIgfHwgdGhpcy5fY29uZmlnLmRpc3BsYXkgPT09ICdzdGF0aWMnKSB7XHJcbiAgICAgICAgTWFuaXB1bGF0b3Iuc2V0RGF0YUF0dHJpYnV0ZSh0aGlzLl9tZW51LCAncG9wcGVyJywgJ3N0YXRpYycpOyAvLyBUT0RPOiB2NiByZW1vdmVcclxuICAgICAgICBkZWZhdWx0QnNQb3BwZXJDb25maWcubW9kaWZpZXJzID0gW3tcclxuICAgICAgICAgIG5hbWU6ICdhcHBseVN0eWxlcycsXHJcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZVxyXG4gICAgICAgIH1dO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgLi4uZGVmYXVsdEJzUG9wcGVyQ29uZmlnLFxyXG4gICAgICAgIC4uLmV4ZWN1dGUodGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZywgW2RlZmF1bHRCc1BvcHBlckNvbmZpZ10pXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBfc2VsZWN0TWVudUl0ZW0oe1xyXG4gICAgICBrZXksXHJcbiAgICAgIHRhcmdldFxyXG4gICAgfSkge1xyXG4gICAgICBjb25zdCBpdGVtcyA9IFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfVklTSUJMRV9JVEVNUywgdGhpcy5fbWVudSkuZmlsdGVyKGVsZW1lbnQgPT4gaXNWaXNpYmxlKGVsZW1lbnQpKTtcclxuICAgICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGlmIHRhcmdldCBpc24ndCBpbmNsdWRlZCBpbiBpdGVtcyAoZS5nLiB3aGVuIGV4cGFuZGluZyB0aGUgZHJvcGRvd24pXHJcbiAgICAgIC8vIGFsbG93IGN5Y2xpbmcgdG8gZ2V0IHRoZSBsYXN0IGl0ZW0gaW4gY2FzZSBrZXkgZXF1YWxzIEFSUk9XX1VQX0tFWVxyXG4gICAgICBnZXROZXh0QWN0aXZlRWxlbWVudChpdGVtcywgdGFyZ2V0LCBrZXkgPT09IEFSUk9XX0RPV05fS0VZJDEsICFpdGVtcy5pbmNsdWRlcyh0YXJnZXQpKS5mb2N1cygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFN0YXRpY1xyXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IERyb3Bkb3duLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcclxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkYXRhW2NvbmZpZ10oKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY2xlYXJNZW51cyhldmVudCkge1xyXG4gICAgICBpZiAoZXZlbnQuYnV0dG9uID09PSBSSUdIVF9NT1VTRV9CVVRUT04gfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJyAmJiBldmVudC5rZXkgIT09IFRBQl9LRVkkMSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBvcGVuVG9nZ2xlcyA9IFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfREFUQV9UT0dHTEVfU0hPV04pO1xyXG4gICAgICBmb3IgKGNvbnN0IHRvZ2dsZSBvZiBvcGVuVG9nZ2xlcykge1xyXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBEcm9wZG93bi5nZXRJbnN0YW5jZSh0b2dnbGUpO1xyXG4gICAgICAgIGlmICghY29udGV4dCB8fCBjb250ZXh0Ll9jb25maWcuYXV0b0Nsb3NlID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNvbXBvc2VkUGF0aCA9IGV2ZW50LmNvbXBvc2VkUGF0aCgpO1xyXG4gICAgICAgIGNvbnN0IGlzTWVudVRhcmdldCA9IGNvbXBvc2VkUGF0aC5pbmNsdWRlcyhjb250ZXh0Ll9tZW51KTtcclxuICAgICAgICBpZiAoY29tcG9zZWRQYXRoLmluY2x1ZGVzKGNvbnRleHQuX2VsZW1lbnQpIHx8IGNvbnRleHQuX2NvbmZpZy5hdXRvQ2xvc2UgPT09ICdpbnNpZGUnICYmICFpc01lbnVUYXJnZXQgfHwgY29udGV4dC5fY29uZmlnLmF1dG9DbG9zZSA9PT0gJ291dHNpZGUnICYmIGlzTWVudVRhcmdldCkge1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUYWIgbmF2aWdhdGlvbiB0aHJvdWdoIHRoZSBkcm9wZG93biBtZW51IG9yIGV2ZW50cyBmcm9tIGNvbnRhaW5lZCBpbnB1dHMgc2hvdWxkbid0IGNsb3NlIHRoZSBtZW51XHJcbiAgICAgICAgaWYgKGNvbnRleHQuX21lbnUuY29udGFpbnMoZXZlbnQudGFyZ2V0KSAmJiAoZXZlbnQudHlwZSA9PT0gJ2tleXVwJyAmJiBldmVudC5rZXkgPT09IFRBQl9LRVkkMSB8fCAvaW5wdXR8c2VsZWN0fG9wdGlvbnx0ZXh0YXJlYXxmb3JtL2kudGVzdChldmVudC50YXJnZXQudGFnTmFtZSkpKSB7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVsYXRlZFRhcmdldCA9IHtcclxuICAgICAgICAgIHJlbGF0ZWRUYXJnZXQ6IGNvbnRleHQuX2VsZW1lbnRcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChldmVudC50eXBlID09PSAnY2xpY2snKSB7XHJcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0LmNsaWNrRXZlbnQgPSBldmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGV4dC5fY29tcGxldGVIaWRlKHJlbGF0ZWRUYXJnZXQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZGF0YUFwaUtleWRvd25IYW5kbGVyKGV2ZW50KSB7XHJcbiAgICAgIC8vIElmIG5vdCBhbiBVUCB8IERPV04gfCBFU0NBUEUga2V5ID0+IG5vdCBhIGRyb3Bkb3duIGNvbW1hbmRcclxuICAgICAgLy8gSWYgaW5wdXQvdGV4dGFyZWEgJiYgaWYga2V5IGlzIG90aGVyIHRoYW4gRVNDQVBFID0+IG5vdCBhIGRyb3Bkb3duIGNvbW1hbmRcclxuXHJcbiAgICAgIGNvbnN0IGlzSW5wdXQgPSAvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGV2ZW50LnRhcmdldC50YWdOYW1lKTtcclxuICAgICAgY29uc3QgaXNFc2NhcGVFdmVudCA9IGV2ZW50LmtleSA9PT0gRVNDQVBFX0tFWSQyO1xyXG4gICAgICBjb25zdCBpc1VwT3JEb3duRXZlbnQgPSBbQVJST1dfVVBfS0VZJDEsIEFSUk9XX0RPV05fS0VZJDFdLmluY2x1ZGVzKGV2ZW50LmtleSk7XHJcbiAgICAgIGlmICghaXNVcE9yRG93bkV2ZW50ICYmICFpc0VzY2FwZUV2ZW50KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc0lucHV0ICYmICFpc0VzY2FwZUV2ZW50KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAvLyBUT0RPOiB2NiByZXZlcnQgIzM3MDExICYgY2hhbmdlIG1hcmt1cCBodHRwczovL2dldGJvb3RzdHJhcC5jb20vZG9jcy81LjMvZm9ybXMvaW5wdXQtZ3JvdXAvXHJcbiAgICAgIGNvbnN0IGdldFRvZ2dsZUJ1dHRvbiA9IHRoaXMubWF0Y2hlcyhTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzKSA/IHRoaXMgOiBTZWxlY3RvckVuZ2luZS5wcmV2KHRoaXMsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDMpWzBdIHx8IFNlbGVjdG9yRW5naW5lLm5leHQodGhpcywgU0VMRUNUT1JfREFUQV9UT0dHTEUkMylbMF0gfHwgU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzLCBldmVudC5kZWxlZ2F0ZVRhcmdldC5wYXJlbnROb2RlKTtcclxuICAgICAgY29uc3QgaW5zdGFuY2UgPSBEcm9wZG93bi5nZXRPckNyZWF0ZUluc3RhbmNlKGdldFRvZ2dsZUJ1dHRvbik7XHJcbiAgICAgIGlmIChpc1VwT3JEb3duRXZlbnQpIHtcclxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICBpbnN0YW5jZS5zaG93KCk7XHJcbiAgICAgICAgaW5zdGFuY2UuX3NlbGVjdE1lbnVJdGVtKGV2ZW50KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGluc3RhbmNlLl9pc1Nob3duKCkpIHtcclxuICAgICAgICAvLyBlbHNlIGlzIGVzY2FwZSBhbmQgd2UgY2hlY2sgaWYgaXQgaXMgc2hvd25cclxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICBpbnN0YW5jZS5oaWRlKCk7XHJcbiAgICAgICAgZ2V0VG9nZ2xlQnV0dG9uLmZvY3VzKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXHJcbiAgICovXHJcblxyXG4gIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfS0VZRE9XTl9EQVRBX0FQSSwgU0VMRUNUT1JfREFUQV9UT0dHTEUkMywgRHJvcGRvd24uZGF0YUFwaUtleWRvd25IYW5kbGVyKTtcclxuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0tFWURPV05fREFUQV9BUEksIFNFTEVDVE9SX01FTlUsIERyb3Bkb3duLmRhdGFBcGlLZXlkb3duSGFuZGxlcik7XHJcbiAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQzLCBEcm9wZG93bi5jbGVhck1lbnVzKTtcclxuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0tFWVVQX0RBVEFfQVBJLCBEcm9wZG93bi5jbGVhck1lbnVzKTtcclxuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDMsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDMsIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIERyb3Bkb3duLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcykudG9nZ2xlKCk7XHJcbiAgfSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIGpRdWVyeVxyXG4gICAqL1xyXG5cclxuICBkZWZpbmVKUXVlcnlQbHVnaW4oRHJvcGRvd24pO1xyXG5cclxuICAvKipcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqIEJvb3RzdHJhcCB1dGlsL2JhY2tkcm9wLmpzXHJcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKi9cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0YW50c1xyXG4gICAqL1xyXG5cclxuICBjb25zdCBOQU1FJDkgPSAnYmFja2Ryb3AnO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfRkFERSQ0ID0gJ2ZhZGUnO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfU0hPVyQ1ID0gJ3Nob3cnO1xyXG4gIGNvbnN0IEVWRU5UX01PVVNFRE9XTiA9IGBtb3VzZWRvd24uYnMuJHtOQU1FJDl9YDtcclxuICBjb25zdCBEZWZhdWx0JDggPSB7XHJcbiAgICBjbGFzc05hbWU6ICdtb2RhbC1iYWNrZHJvcCcsXHJcbiAgICBjbGlja0NhbGxiYWNrOiBudWxsLFxyXG4gICAgaXNBbmltYXRlZDogZmFsc2UsXHJcbiAgICBpc1Zpc2libGU6IHRydWUsXHJcbiAgICAvLyBpZiBmYWxzZSwgd2UgdXNlIHRoZSBiYWNrZHJvcCBoZWxwZXIgd2l0aG91dCBhZGRpbmcgYW55IGVsZW1lbnQgdG8gdGhlIGRvbVxyXG4gICAgcm9vdEVsZW1lbnQ6ICdib2R5JyAvLyBnaXZlIHRoZSBjaG9pY2UgdG8gcGxhY2UgYmFja2Ryb3AgdW5kZXIgZGlmZmVyZW50IGVsZW1lbnRzXHJcbiAgfTtcclxuICBjb25zdCBEZWZhdWx0VHlwZSQ4ID0ge1xyXG4gICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcclxuICAgIGNsaWNrQ2FsbGJhY2s6ICcoZnVuY3Rpb258bnVsbCknLFxyXG4gICAgaXNBbmltYXRlZDogJ2Jvb2xlYW4nLFxyXG4gICAgaXNWaXNpYmxlOiAnYm9vbGVhbicsXHJcbiAgICByb290RWxlbWVudDogJyhlbGVtZW50fHN0cmluZyknXHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxyXG4gICAqL1xyXG5cclxuICBjbGFzcyBCYWNrZHJvcCBleHRlbmRzIENvbmZpZyB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XHJcbiAgICAgIHRoaXMuX2lzQXBwZW5kZWQgPSBmYWxzZTtcclxuICAgICAgdGhpcy5fZWxlbWVudCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gR2V0dGVyc1xyXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xyXG4gICAgICByZXR1cm4gRGVmYXVsdCQ4O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcclxuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJDg7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XHJcbiAgICAgIHJldHVybiBOQU1FJDk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHVibGljXHJcbiAgICBzaG93KGNhbGxiYWNrKSB7XHJcbiAgICAgIGlmICghdGhpcy5fY29uZmlnLmlzVmlzaWJsZSkge1xyXG4gICAgICAgIGV4ZWN1dGUoY2FsbGJhY2spO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9hcHBlbmQoKTtcclxuICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2dldEVsZW1lbnQoKTtcclxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5pc0FuaW1hdGVkKSB7XHJcbiAgICAgICAgcmVmbG93KGVsZW1lbnQpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1ckNSk7XHJcbiAgICAgIHRoaXMuX2VtdWxhdGVBbmltYXRpb24oKCkgPT4ge1xyXG4gICAgICAgIGV4ZWN1dGUoY2FsbGJhY2spO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIGhpZGUoY2FsbGJhY2spIHtcclxuICAgICAgaWYgKCF0aGlzLl9jb25maWcuaXNWaXNpYmxlKSB7XHJcbiAgICAgICAgZXhlY3V0ZShjYWxsYmFjayk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2dldEVsZW1lbnQoKS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQ1KTtcclxuICAgICAgdGhpcy5fZW11bGF0ZUFuaW1hdGlvbigoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5kaXNwb3NlKCk7XHJcbiAgICAgICAgZXhlY3V0ZShjYWxsYmFjayk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgaWYgKCF0aGlzLl9pc0FwcGVuZGVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fZWxlbWVudCwgRVZFTlRfTU9VU0VET1dOKTtcclxuICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmUoKTtcclxuICAgICAgdGhpcy5faXNBcHBlbmRlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFByaXZhdGVcclxuICAgIF9nZXRFbGVtZW50KCkge1xyXG4gICAgICBpZiAoIXRoaXMuX2VsZW1lbnQpIHtcclxuICAgICAgICBjb25zdCBiYWNrZHJvcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIGJhY2tkcm9wLmNsYXNzTmFtZSA9IHRoaXMuX2NvbmZpZy5jbGFzc05hbWU7XHJcbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5pc0FuaW1hdGVkKSB7XHJcbiAgICAgICAgICBiYWNrZHJvcC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfRkFERSQ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IGJhY2tkcm9wO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50O1xyXG4gICAgfVxyXG4gICAgX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKSB7XHJcbiAgICAgIC8vIHVzZSBnZXRFbGVtZW50KCkgd2l0aCB0aGUgZGVmYXVsdCBcImJvZHlcIiB0byBnZXQgYSBmcmVzaCBFbGVtZW50IG9uIGVhY2ggaW5zdGFudGlhdGlvblxyXG4gICAgICBjb25maWcucm9vdEVsZW1lbnQgPSBnZXRFbGVtZW50KGNvbmZpZy5yb290RWxlbWVudCk7XHJcbiAgICAgIHJldHVybiBjb25maWc7XHJcbiAgICB9XHJcbiAgICBfYXBwZW5kKCkge1xyXG4gICAgICBpZiAodGhpcy5faXNBcHBlbmRlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fZ2V0RWxlbWVudCgpO1xyXG4gICAgICB0aGlzLl9jb25maWcucm9vdEVsZW1lbnQuYXBwZW5kKGVsZW1lbnQpO1xyXG4gICAgICBFdmVudEhhbmRsZXIub24oZWxlbWVudCwgRVZFTlRfTU9VU0VET1dOLCAoKSA9PiB7XHJcbiAgICAgICAgZXhlY3V0ZSh0aGlzLl9jb25maWcuY2xpY2tDYWxsYmFjayk7XHJcbiAgICAgIH0pO1xyXG4gICAgICB0aGlzLl9pc0FwcGVuZGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIF9lbXVsYXRlQW5pbWF0aW9uKGNhbGxiYWNrKSB7XHJcbiAgICAgIGV4ZWN1dGVBZnRlclRyYW5zaXRpb24oY2FsbGJhY2ssIHRoaXMuX2dldEVsZW1lbnQoKSwgdGhpcy5fY29uZmlnLmlzQW5pbWF0ZWQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKiBCb290c3RyYXAgdXRpbC9mb2N1c3RyYXAuanNcclxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqL1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RhbnRzXHJcbiAgICovXHJcblxyXG4gIGNvbnN0IE5BTUUkOCA9ICdmb2N1c3RyYXAnO1xyXG4gIGNvbnN0IERBVEFfS0VZJDUgPSAnYnMuZm9jdXN0cmFwJztcclxuICBjb25zdCBFVkVOVF9LRVkkNSA9IGAuJHtEQVRBX0tFWSQ1fWA7XHJcbiAgY29uc3QgRVZFTlRfRk9DVVNJTiQyID0gYGZvY3VzaW4ke0VWRU5UX0tFWSQ1fWA7XHJcbiAgY29uc3QgRVZFTlRfS0VZRE9XTl9UQUIgPSBga2V5ZG93bi50YWIke0VWRU5UX0tFWSQ1fWA7XHJcbiAgY29uc3QgVEFCX0tFWSA9ICdUYWInO1xyXG4gIGNvbnN0IFRBQl9OQVZfRk9SV0FSRCA9ICdmb3J3YXJkJztcclxuICBjb25zdCBUQUJfTkFWX0JBQ0tXQVJEID0gJ2JhY2t3YXJkJztcclxuICBjb25zdCBEZWZhdWx0JDcgPSB7XHJcbiAgICBhdXRvZm9jdXM6IHRydWUsXHJcbiAgICB0cmFwRWxlbWVudDogbnVsbCAvLyBUaGUgZWxlbWVudCB0byB0cmFwIGZvY3VzIGluc2lkZSBvZlxyXG4gIH07XHJcbiAgY29uc3QgRGVmYXVsdFR5cGUkNyA9IHtcclxuICAgIGF1dG9mb2N1czogJ2Jvb2xlYW4nLFxyXG4gICAgdHJhcEVsZW1lbnQ6ICdlbGVtZW50J1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENsYXNzIGRlZmluaXRpb25cclxuICAgKi9cclxuXHJcbiAgY2xhc3MgRm9jdXNUcmFwIGV4dGVuZHMgQ29uZmlnIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcclxuICAgICAgdGhpcy5faXNBY3RpdmUgPSBmYWxzZTtcclxuICAgICAgdGhpcy5fbGFzdFRhYk5hdkRpcmVjdGlvbiA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gR2V0dGVyc1xyXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xyXG4gICAgICByZXR1cm4gRGVmYXVsdCQ3O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcclxuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJDc7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XHJcbiAgICAgIHJldHVybiBOQU1FJDg7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHVibGljXHJcbiAgICBhY3RpdmF0ZSgpIHtcclxuICAgICAgaWYgKHRoaXMuX2lzQWN0aXZlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLl9jb25maWcuYXV0b2ZvY3VzKSB7XHJcbiAgICAgICAgdGhpcy5fY29uZmlnLnRyYXBFbGVtZW50LmZvY3VzKCk7XHJcbiAgICAgIH1cclxuICAgICAgRXZlbnRIYW5kbGVyLm9mZihkb2N1bWVudCwgRVZFTlRfS0VZJDUpOyAvLyBndWFyZCBhZ2FpbnN0IGluZmluaXRlIGZvY3VzIGxvb3BcclxuICAgICAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9GT0NVU0lOJDIsIGV2ZW50ID0+IHRoaXMuX2hhbmRsZUZvY3VzaW4oZXZlbnQpKTtcclxuICAgICAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9LRVlET1dOX1RBQiwgZXZlbnQgPT4gdGhpcy5faGFuZGxlS2V5ZG93bihldmVudCkpO1xyXG4gICAgICB0aGlzLl9pc0FjdGl2ZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBkZWFjdGl2YXRlKCkge1xyXG4gICAgICBpZiAoIXRoaXMuX2lzQWN0aXZlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2lzQWN0aXZlID0gZmFsc2U7XHJcbiAgICAgIEV2ZW50SGFuZGxlci5vZmYoZG9jdW1lbnQsIEVWRU5UX0tFWSQ1KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQcml2YXRlXHJcbiAgICBfaGFuZGxlRm9jdXNpbihldmVudCkge1xyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgdHJhcEVsZW1lbnRcclxuICAgICAgfSA9IHRoaXMuX2NvbmZpZztcclxuICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gZG9jdW1lbnQgfHwgZXZlbnQudGFyZ2V0ID09PSB0cmFwRWxlbWVudCB8fCB0cmFwRWxlbWVudC5jb250YWlucyhldmVudC50YXJnZXQpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gU2VsZWN0b3JFbmdpbmUuZm9jdXNhYmxlQ2hpbGRyZW4odHJhcEVsZW1lbnQpO1xyXG4gICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgdHJhcEVsZW1lbnQuZm9jdXMoKTtcclxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9sYXN0VGFiTmF2RGlyZWN0aW9uID09PSBUQUJfTkFWX0JBQ0tXQVJEKSB7XHJcbiAgICAgICAgZWxlbWVudHNbZWxlbWVudHMubGVuZ3RoIC0gMV0uZm9jdXMoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBlbGVtZW50c1swXS5mb2N1cygpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBfaGFuZGxlS2V5ZG93bihldmVudCkge1xyXG4gICAgICBpZiAoZXZlbnQua2V5ICE9PSBUQUJfS0VZKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2xhc3RUYWJOYXZEaXJlY3Rpb24gPSBldmVudC5zaGlmdEtleSA/IFRBQl9OQVZfQkFDS1dBUkQgOiBUQUJfTkFWX0ZPUldBUkQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqIEJvb3RzdHJhcCB1dGlsL3Njcm9sbEJhci5qc1xyXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICovXHJcblxyXG5cclxuICAvKipcclxuICAgKiBDb25zdGFudHNcclxuICAgKi9cclxuXHJcbiAgY29uc3QgU0VMRUNUT1JfRklYRURfQ09OVEVOVCA9ICcuZml4ZWQtdG9wLCAuZml4ZWQtYm90dG9tLCAuaXMtZml4ZWQsIC5zdGlja3ktdG9wJztcclxuICBjb25zdCBTRUxFQ1RPUl9TVElDS1lfQ09OVEVOVCA9ICcuc3RpY2t5LXRvcCc7XHJcbiAgY29uc3QgUFJPUEVSVFlfUEFERElORyA9ICdwYWRkaW5nLXJpZ2h0JztcclxuICBjb25zdCBQUk9QRVJUWV9NQVJHSU4gPSAnbWFyZ2luLXJpZ2h0JztcclxuXHJcbiAgLyoqXHJcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxyXG4gICAqL1xyXG5cclxuICBjbGFzcyBTY3JvbGxCYXJIZWxwZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBkb2N1bWVudC5ib2R5O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFB1YmxpY1xyXG4gICAgZ2V0V2lkdGgoKSB7XHJcbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3cvaW5uZXJXaWR0aCN1c2FnZV9ub3Rlc1xyXG4gICAgICBjb25zdCBkb2N1bWVudFdpZHRoID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xyXG4gICAgICByZXR1cm4gTWF0aC5hYnMod2luZG93LmlubmVyV2lkdGggLSBkb2N1bWVudFdpZHRoKTtcclxuICAgIH1cclxuICAgIGhpZGUoKSB7XHJcbiAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpO1xyXG4gICAgICB0aGlzLl9kaXNhYmxlT3ZlckZsb3coKTtcclxuICAgICAgLy8gZ2l2ZSBwYWRkaW5nIHRvIGVsZW1lbnQgdG8gYmFsYW5jZSB0aGUgaGlkZGVuIHNjcm9sbGJhciB3aWR0aFxyXG4gICAgICB0aGlzLl9zZXRFbGVtZW50QXR0cmlidXRlcyh0aGlzLl9lbGVtZW50LCBQUk9QRVJUWV9QQURESU5HLCBjYWxjdWxhdGVkVmFsdWUgPT4gY2FsY3VsYXRlZFZhbHVlICsgd2lkdGgpO1xyXG4gICAgICAvLyB0cmljazogV2UgYWRqdXN0IHBvc2l0aXZlIHBhZGRpbmdSaWdodCBhbmQgbmVnYXRpdmUgbWFyZ2luUmlnaHQgdG8gc3RpY2t5LXRvcCBlbGVtZW50cyB0byBrZWVwIHNob3dpbmcgZnVsbHdpZHRoXHJcbiAgICAgIHRoaXMuX3NldEVsZW1lbnRBdHRyaWJ1dGVzKFNFTEVDVE9SX0ZJWEVEX0NPTlRFTlQsIFBST1BFUlRZX1BBRERJTkcsIGNhbGN1bGF0ZWRWYWx1ZSA9PiBjYWxjdWxhdGVkVmFsdWUgKyB3aWR0aCk7XHJcbiAgICAgIHRoaXMuX3NldEVsZW1lbnRBdHRyaWJ1dGVzKFNFTEVDVE9SX1NUSUNLWV9DT05URU5ULCBQUk9QRVJUWV9NQVJHSU4sIGNhbGN1bGF0ZWRWYWx1ZSA9PiBjYWxjdWxhdGVkVmFsdWUgLSB3aWR0aCk7XHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgdGhpcy5fcmVzZXRFbGVtZW50QXR0cmlidXRlcyh0aGlzLl9lbGVtZW50LCAnb3ZlcmZsb3cnKTtcclxuICAgICAgdGhpcy5fcmVzZXRFbGVtZW50QXR0cmlidXRlcyh0aGlzLl9lbGVtZW50LCBQUk9QRVJUWV9QQURESU5HKTtcclxuICAgICAgdGhpcy5fcmVzZXRFbGVtZW50QXR0cmlidXRlcyhTRUxFQ1RPUl9GSVhFRF9DT05URU5ULCBQUk9QRVJUWV9QQURESU5HKTtcclxuICAgICAgdGhpcy5fcmVzZXRFbGVtZW50QXR0cmlidXRlcyhTRUxFQ1RPUl9TVElDS1lfQ09OVEVOVCwgUFJPUEVSVFlfTUFSR0lOKTtcclxuICAgIH1cclxuICAgIGlzT3ZlcmZsb3dpbmcoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldFdpZHRoKCkgPiAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFByaXZhdGVcclxuICAgIF9kaXNhYmxlT3ZlckZsb3coKSB7XHJcbiAgICAgIHRoaXMuX3NhdmVJbml0aWFsQXR0cmlidXRlKHRoaXMuX2VsZW1lbnQsICdvdmVyZmxvdycpO1xyXG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XHJcbiAgICB9XHJcbiAgICBfc2V0RWxlbWVudEF0dHJpYnV0ZXMoc2VsZWN0b3IsIHN0eWxlUHJvcGVydHksIGNhbGxiYWNrKSB7XHJcbiAgICAgIGNvbnN0IHNjcm9sbGJhcldpZHRoID0gdGhpcy5nZXRXaWR0aCgpO1xyXG4gICAgICBjb25zdCBtYW5pcHVsYXRpb25DYWxsQmFjayA9IGVsZW1lbnQgPT4ge1xyXG4gICAgICAgIGlmIChlbGVtZW50ICE9PSB0aGlzLl9lbGVtZW50ICYmIHdpbmRvdy5pbm5lcldpZHRoID4gZWxlbWVudC5jbGllbnRXaWR0aCArIHNjcm9sbGJhcldpZHRoKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3NhdmVJbml0aWFsQXR0cmlidXRlKGVsZW1lbnQsIHN0eWxlUHJvcGVydHkpO1xyXG4gICAgICAgIGNvbnN0IGNhbGN1bGF0ZWRWYWx1ZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoc3R5bGVQcm9wZXJ0eSk7XHJcbiAgICAgICAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShzdHlsZVByb3BlcnR5LCBgJHtjYWxsYmFjayhOdW1iZXIucGFyc2VGbG9hdChjYWxjdWxhdGVkVmFsdWUpKX1weGApO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLl9hcHBseU1hbmlwdWxhdGlvbkNhbGxiYWNrKHNlbGVjdG9yLCBtYW5pcHVsYXRpb25DYWxsQmFjayk7XHJcbiAgICB9XHJcbiAgICBfc2F2ZUluaXRpYWxBdHRyaWJ1dGUoZWxlbWVudCwgc3R5bGVQcm9wZXJ0eSkge1xyXG4gICAgICBjb25zdCBhY3R1YWxWYWx1ZSA9IGVsZW1lbnQuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShzdHlsZVByb3BlcnR5KTtcclxuICAgICAgaWYgKGFjdHVhbFZhbHVlKSB7XHJcbiAgICAgICAgTWFuaXB1bGF0b3Iuc2V0RGF0YUF0dHJpYnV0ZShlbGVtZW50LCBzdHlsZVByb3BlcnR5LCBhY3R1YWxWYWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIF9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKHNlbGVjdG9yLCBzdHlsZVByb3BlcnR5KSB7XHJcbiAgICAgIGNvbnN0IG1hbmlwdWxhdGlvbkNhbGxCYWNrID0gZWxlbWVudCA9PiB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBNYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlKGVsZW1lbnQsIHN0eWxlUHJvcGVydHkpO1xyXG4gICAgICAgIC8vIFdlIG9ubHkgd2FudCB0byByZW1vdmUgdGhlIHByb3BlcnR5IGlmIHRoZSB2YWx1ZSBpcyBgbnVsbGA7IHRoZSB2YWx1ZSBjYW4gYWxzbyBiZSB6ZXJvXHJcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XHJcbiAgICAgICAgICBlbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KHN0eWxlUHJvcGVydHkpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBNYW5pcHVsYXRvci5yZW1vdmVEYXRhQXR0cmlidXRlKGVsZW1lbnQsIHN0eWxlUHJvcGVydHkpO1xyXG4gICAgICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoc3R5bGVQcm9wZXJ0eSwgdmFsdWUpO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLl9hcHBseU1hbmlwdWxhdGlvbkNhbGxiYWNrKHNlbGVjdG9yLCBtYW5pcHVsYXRpb25DYWxsQmFjayk7XHJcbiAgICB9XHJcbiAgICBfYXBwbHlNYW5pcHVsYXRpb25DYWxsYmFjayhzZWxlY3RvciwgY2FsbEJhY2spIHtcclxuICAgICAgaWYgKGlzRWxlbWVudCQxKHNlbGVjdG9yKSkge1xyXG4gICAgICAgIGNhbGxCYWNrKHNlbGVjdG9yKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgZm9yIChjb25zdCBzZWwgb2YgU2VsZWN0b3JFbmdpbmUuZmluZChzZWxlY3RvciwgdGhpcy5fZWxlbWVudCkpIHtcclxuICAgICAgICBjYWxsQmFjayhzZWwpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqIEJvb3RzdHJhcCBtb2RhbC5qc1xyXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICovXHJcblxyXG5cclxuICAvKipcclxuICAgKiBDb25zdGFudHNcclxuICAgKi9cclxuXHJcbiAgY29uc3QgTkFNRSQ3ID0gJ21vZGFsJztcclxuICBjb25zdCBEQVRBX0tFWSQ0ID0gJ2JzLm1vZGFsJztcclxuICBjb25zdCBFVkVOVF9LRVkkNCA9IGAuJHtEQVRBX0tFWSQ0fWA7XHJcbiAgY29uc3QgREFUQV9BUElfS0VZJDIgPSAnLmRhdGEtYXBpJztcclxuICBjb25zdCBFU0NBUEVfS0VZJDEgPSAnRXNjYXBlJztcclxuICBjb25zdCBFVkVOVF9ISURFJDQgPSBgaGlkZSR7RVZFTlRfS0VZJDR9YDtcclxuICBjb25zdCBFVkVOVF9ISURFX1BSRVZFTlRFRCQxID0gYGhpZGVQcmV2ZW50ZWQke0VWRU5UX0tFWSQ0fWA7XHJcbiAgY29uc3QgRVZFTlRfSElEREVOJDQgPSBgaGlkZGVuJHtFVkVOVF9LRVkkNH1gO1xyXG4gIGNvbnN0IEVWRU5UX1NIT1ckNCA9IGBzaG93JHtFVkVOVF9LRVkkNH1gO1xyXG4gIGNvbnN0IEVWRU5UX1NIT1dOJDQgPSBgc2hvd24ke0VWRU5UX0tFWSQ0fWA7XHJcbiAgY29uc3QgRVZFTlRfUkVTSVpFJDEgPSBgcmVzaXplJHtFVkVOVF9LRVkkNH1gO1xyXG4gIGNvbnN0IEVWRU5UX0NMSUNLX0RJU01JU1MgPSBgY2xpY2suZGlzbWlzcyR7RVZFTlRfS0VZJDR9YDtcclxuICBjb25zdCBFVkVOVF9NT1VTRURPV05fRElTTUlTUyA9IGBtb3VzZWRvd24uZGlzbWlzcyR7RVZFTlRfS0VZJDR9YDtcclxuICBjb25zdCBFVkVOVF9LRVlET1dOX0RJU01JU1MkMSA9IGBrZXlkb3duLmRpc21pc3Mke0VWRU5UX0tFWSQ0fWA7XHJcbiAgY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMiA9IGBjbGljayR7RVZFTlRfS0VZJDR9JHtEQVRBX0FQSV9LRVkkMn1gO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfT1BFTiA9ICdtb2RhbC1vcGVuJztcclxuICBjb25zdCBDTEFTU19OQU1FX0ZBREUkMyA9ICdmYWRlJztcclxuICBjb25zdCBDTEFTU19OQU1FX1NIT1ckNCA9ICdzaG93JztcclxuICBjb25zdCBDTEFTU19OQU1FX1NUQVRJQyA9ICdtb2RhbC1zdGF0aWMnO1xyXG4gIGNvbnN0IE9QRU5fU0VMRUNUT1IkMSA9ICcubW9kYWwuc2hvdyc7XHJcbiAgY29uc3QgU0VMRUNUT1JfRElBTE9HID0gJy5tb2RhbC1kaWFsb2cnO1xyXG4gIGNvbnN0IFNFTEVDVE9SX01PREFMX0JPRFkgPSAnLm1vZGFsLWJvZHknO1xyXG4gIGNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFJDIgPSAnW2RhdGEtYnMtdG9nZ2xlPVwibW9kYWxcIl0nO1xyXG4gIGNvbnN0IERlZmF1bHQkNiA9IHtcclxuICAgIGJhY2tkcm9wOiB0cnVlLFxyXG4gICAgZm9jdXM6IHRydWUsXHJcbiAgICBrZXlib2FyZDogdHJ1ZVxyXG4gIH07XHJcbiAgY29uc3QgRGVmYXVsdFR5cGUkNiA9IHtcclxuICAgIGJhY2tkcm9wOiAnKGJvb2xlYW58c3RyaW5nKScsXHJcbiAgICBmb2N1czogJ2Jvb2xlYW4nLFxyXG4gICAga2V5Ym9hcmQ6ICdib29sZWFuJ1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENsYXNzIGRlZmluaXRpb25cclxuICAgKi9cclxuXHJcbiAgY2xhc3MgTW9kYWwgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xyXG4gICAgICBzdXBlcihlbGVtZW50LCBjb25maWcpO1xyXG4gICAgICB0aGlzLl9kaWFsb2cgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0RJQUxPRywgdGhpcy5fZWxlbWVudCk7XHJcbiAgICAgIHRoaXMuX2JhY2tkcm9wID0gdGhpcy5faW5pdGlhbGl6ZUJhY2tEcm9wKCk7XHJcbiAgICAgIHRoaXMuX2ZvY3VzdHJhcCA9IHRoaXMuX2luaXRpYWxpemVGb2N1c1RyYXAoKTtcclxuICAgICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xyXG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcclxuICAgICAgdGhpcy5fc2Nyb2xsQmFyID0gbmV3IFNjcm9sbEJhckhlbHBlcigpO1xyXG4gICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldHRlcnNcclxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcclxuICAgICAgcmV0dXJuIERlZmF1bHQkNjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XHJcbiAgICAgIHJldHVybiBEZWZhdWx0VHlwZSQ2O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xyXG4gICAgICByZXR1cm4gTkFNRSQ3O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFB1YmxpY1xyXG4gICAgdG9nZ2xlKHJlbGF0ZWRUYXJnZXQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2lzU2hvd24gPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdyhyZWxhdGVkVGFyZ2V0KTtcclxuICAgIH1cclxuICAgIHNob3cocmVsYXRlZFRhcmdldCkge1xyXG4gICAgICBpZiAodGhpcy5faXNTaG93biB8fCB0aGlzLl9pc1RyYW5zaXRpb25pbmcpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPVyQ0LCB7XHJcbiAgICAgICAgcmVsYXRlZFRhcmdldFxyXG4gICAgICB9KTtcclxuICAgICAgaWYgKHNob3dFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2lzU2hvd24gPSB0cnVlO1xyXG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSB0cnVlO1xyXG4gICAgICB0aGlzLl9zY3JvbGxCYXIuaGlkZSgpO1xyXG4gICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9PUEVOKTtcclxuICAgICAgdGhpcy5fYWRqdXN0RGlhbG9nKCk7XHJcbiAgICAgIHRoaXMuX2JhY2tkcm9wLnNob3coKCkgPT4gdGhpcy5fc2hvd0VsZW1lbnQocmVsYXRlZFRhcmdldCkpO1xyXG4gICAgfVxyXG4gICAgaGlkZSgpIHtcclxuICAgICAgaWYgKCF0aGlzLl9pc1Nob3duIHx8IHRoaXMuX2lzVHJhbnNpdGlvbmluZykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFJDQpO1xyXG4gICAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xyXG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSB0cnVlO1xyXG4gICAgICB0aGlzLl9mb2N1c3RyYXAuZGVhY3RpdmF0ZSgpO1xyXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDQpO1xyXG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHRoaXMuX2hpZGVNb2RhbCgpLCB0aGlzLl9lbGVtZW50LCB0aGlzLl9pc0FuaW1hdGVkKCkpO1xyXG4gICAgfVxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgRXZlbnRIYW5kbGVyLm9mZih3aW5kb3csIEVWRU5UX0tFWSQ0KTtcclxuICAgICAgRXZlbnRIYW5kbGVyLm9mZih0aGlzLl9kaWFsb2csIEVWRU5UX0tFWSQ0KTtcclxuICAgICAgdGhpcy5fYmFja2Ryb3AuZGlzcG9zZSgpO1xyXG4gICAgICB0aGlzLl9mb2N1c3RyYXAuZGVhY3RpdmF0ZSgpO1xyXG4gICAgICBzdXBlci5kaXNwb3NlKCk7XHJcbiAgICB9XHJcbiAgICBoYW5kbGVVcGRhdGUoKSB7XHJcbiAgICAgIHRoaXMuX2FkanVzdERpYWxvZygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFByaXZhdGVcclxuICAgIF9pbml0aWFsaXplQmFja0Ryb3AoKSB7XHJcbiAgICAgIHJldHVybiBuZXcgQmFja2Ryb3Aoe1xyXG4gICAgICAgIGlzVmlzaWJsZTogQm9vbGVhbih0aGlzLl9jb25maWcuYmFja2Ryb3ApLFxyXG4gICAgICAgIC8vICdzdGF0aWMnIG9wdGlvbiB3aWxsIGJlIHRyYW5zbGF0ZWQgdG8gdHJ1ZSwgYW5kIGJvb2xlYW5zIHdpbGwga2VlcCB0aGVpciB2YWx1ZSxcclxuICAgICAgICBpc0FuaW1hdGVkOiB0aGlzLl9pc0FuaW1hdGVkKClcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfaW5pdGlhbGl6ZUZvY3VzVHJhcCgpIHtcclxuICAgICAgcmV0dXJuIG5ldyBGb2N1c1RyYXAoe1xyXG4gICAgICAgIHRyYXBFbGVtZW50OiB0aGlzLl9lbGVtZW50XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX3Nob3dFbGVtZW50KHJlbGF0ZWRUYXJnZXQpIHtcclxuICAgICAgLy8gdHJ5IHRvIGFwcGVuZCBkeW5hbWljIG1vZGFsXHJcbiAgICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyh0aGlzLl9lbGVtZW50KSkge1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKHRoaXMuX2VsZW1lbnQpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcbiAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xyXG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1tb2RhbCcsIHRydWUpO1xyXG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdkaWFsb2cnKTtcclxuICAgICAgdGhpcy5fZWxlbWVudC5zY3JvbGxUb3AgPSAwO1xyXG4gICAgICBjb25zdCBtb2RhbEJvZHkgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX01PREFMX0JPRFksIHRoaXMuX2RpYWxvZyk7XHJcbiAgICAgIGlmIChtb2RhbEJvZHkpIHtcclxuICAgICAgICBtb2RhbEJvZHkuc2Nyb2xsVG9wID0gMDtcclxuICAgICAgfVxyXG4gICAgICByZWZsb3codGhpcy5fZWxlbWVudCk7XHJcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1ckNCk7XHJcbiAgICAgIGNvbnN0IHRyYW5zaXRpb25Db21wbGV0ZSA9ICgpID0+IHtcclxuICAgICAgICBpZiAodGhpcy5fY29uZmlnLmZvY3VzKSB7XHJcbiAgICAgICAgICB0aGlzLl9mb2N1c3RyYXAuYWN0aXZhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPV04kNCwge1xyXG4gICAgICAgICAgcmVsYXRlZFRhcmdldFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKHRyYW5zaXRpb25Db21wbGV0ZSwgdGhpcy5fZGlhbG9nLCB0aGlzLl9pc0FuaW1hdGVkKCkpO1xyXG4gICAgfVxyXG4gICAgX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xyXG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfS0VZRE9XTl9ESVNNSVNTJDEsIGV2ZW50ID0+IHtcclxuICAgICAgICBpZiAoZXZlbnQua2V5ICE9PSBFU0NBUEVfS0VZJDEpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5rZXlib2FyZCkge1xyXG4gICAgICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24oKTtcclxuICAgICAgfSk7XHJcbiAgICAgIEV2ZW50SGFuZGxlci5vbih3aW5kb3csIEVWRU5UX1JFU0laRSQxLCAoKSA9PiB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzU2hvd24gJiYgIXRoaXMuX2lzVHJhbnNpdGlvbmluZykge1xyXG4gICAgICAgICAgdGhpcy5fYWRqdXN0RGlhbG9nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFRE9XTl9ESVNNSVNTLCBldmVudCA9PiB7XHJcbiAgICAgICAgLy8gYSBiYWQgdHJpY2sgdG8gc2VncmVnYXRlIGNsaWNrcyB0aGF0IG1heSBzdGFydCBpbnNpZGUgZGlhbG9nIGJ1dCBlbmQgb3V0c2lkZSwgYW5kIGF2b2lkIGxpc3RlbiB0byBzY3JvbGxiYXIgY2xpY2tzXHJcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uZSh0aGlzLl9lbGVtZW50LCBFVkVOVF9DTElDS19ESVNNSVNTLCBldmVudDIgPT4ge1xyXG4gICAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnQgIT09IGV2ZW50LnRhcmdldCB8fCB0aGlzLl9lbGVtZW50ICE9PSBldmVudDIudGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICh0aGlzLl9jb25maWcuYmFja2Ryb3AgPT09ICdzdGF0aWMnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24oKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5iYWNrZHJvcCkge1xyXG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfaGlkZU1vZGFsKCkge1xyXG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRydWUpO1xyXG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1tb2RhbCcpO1xyXG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgncm9sZScpO1xyXG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcclxuICAgICAgdGhpcy5fYmFja2Ryb3AuaGlkZSgoKSA9PiB7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfT1BFTik7XHJcbiAgICAgICAgdGhpcy5fcmVzZXRBZGp1c3RtZW50cygpO1xyXG4gICAgICAgIHRoaXMuX3Njcm9sbEJhci5yZXNldCgpO1xyXG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJRERFTiQ0KTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfaXNBbmltYXRlZCgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRkFERSQzKTtcclxuICAgIH1cclxuICAgIF90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uKCkge1xyXG4gICAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFX1BSRVZFTlRFRCQxKTtcclxuICAgICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGlzTW9kYWxPdmVyZmxvd2luZyA9IHRoaXMuX2VsZW1lbnQuc2Nyb2xsSGVpZ2h0ID4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcclxuICAgICAgY29uc3QgaW5pdGlhbE92ZXJmbG93WSA9IHRoaXMuX2VsZW1lbnQuc3R5bGUub3ZlcmZsb3dZO1xyXG4gICAgICAvLyByZXR1cm4gaWYgdGhlIGZvbGxvd2luZyBiYWNrZ3JvdW5kIHRyYW5zaXRpb24gaGFzbid0IHlldCBjb21wbGV0ZWRcclxuICAgICAgaWYgKGluaXRpYWxPdmVyZmxvd1kgPT09ICdoaWRkZW4nIHx8IHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU1RBVElDKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWlzTW9kYWxPdmVyZmxvd2luZykge1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUub3ZlcmZsb3dZID0gJ2hpZGRlbic7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU1RBVElDKTtcclxuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU1RBVElDKTtcclxuICAgICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUub3ZlcmZsb3dZID0gaW5pdGlhbE92ZXJmbG93WTtcclxuICAgICAgICB9LCB0aGlzLl9kaWFsb2cpO1xyXG4gICAgICB9LCB0aGlzLl9kaWFsb2cpO1xyXG4gICAgICB0aGlzLl9lbGVtZW50LmZvY3VzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZm9sbG93aW5nIG1ldGhvZHMgYXJlIHVzZWQgdG8gaGFuZGxlIG92ZXJmbG93aW5nIG1vZGFsc1xyXG4gICAgICovXHJcblxyXG4gICAgX2FkanVzdERpYWxvZygpIHtcclxuICAgICAgY29uc3QgaXNNb2RhbE92ZXJmbG93aW5nID0gdGhpcy5fZWxlbWVudC5zY3JvbGxIZWlnaHQgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xyXG4gICAgICBjb25zdCBzY3JvbGxiYXJXaWR0aCA9IHRoaXMuX3Njcm9sbEJhci5nZXRXaWR0aCgpO1xyXG4gICAgICBjb25zdCBpc0JvZHlPdmVyZmxvd2luZyA9IHNjcm9sbGJhcldpZHRoID4gMDtcclxuICAgICAgaWYgKGlzQm9keU92ZXJmbG93aW5nICYmICFpc01vZGFsT3ZlcmZsb3dpbmcpIHtcclxuICAgICAgICBjb25zdCBwcm9wZXJ0eSA9IGlzUlRMKCkgPyAncGFkZGluZ0xlZnQnIDogJ3BhZGRpbmdSaWdodCc7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtwcm9wZXJ0eV0gPSBgJHtzY3JvbGxiYXJXaWR0aH1weGA7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFpc0JvZHlPdmVyZmxvd2luZyAmJiBpc01vZGFsT3ZlcmZsb3dpbmcpIHtcclxuICAgICAgICBjb25zdCBwcm9wZXJ0eSA9IGlzUlRMKCkgPyAncGFkZGluZ1JpZ2h0JyA6ICdwYWRkaW5nTGVmdCc7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtwcm9wZXJ0eV0gPSBgJHtzY3JvbGxiYXJXaWR0aH1weGA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIF9yZXNldEFkanVzdG1lbnRzKCkge1xyXG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdMZWZ0ID0gJyc7XHJcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gJyc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU3RhdGljXHJcbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZywgcmVsYXRlZFRhcmdldCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCBkYXRhID0gTW9kYWwuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRhdGFbY29uZmlnXShyZWxhdGVkVGFyZ2V0KTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxyXG4gICAqL1xyXG5cclxuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDIsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDIsIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gU2VsZWN0b3JFbmdpbmUuZ2V0RWxlbWVudEZyb21TZWxlY3Rvcih0aGlzKTtcclxuICAgIGlmIChbJ0EnLCAnQVJFQSddLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkpIHtcclxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIH1cclxuICAgIEV2ZW50SGFuZGxlci5vbmUodGFyZ2V0LCBFVkVOVF9TSE9XJDQsIHNob3dFdmVudCA9PiB7XHJcbiAgICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICAgIC8vIG9ubHkgcmVnaXN0ZXIgZm9jdXMgcmVzdG9yZXIgaWYgbW9kYWwgd2lsbCBhY3R1YWxseSBnZXQgc2hvd25cclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgRXZlbnRIYW5kbGVyLm9uZSh0YXJnZXQsIEVWRU5UX0hJRERFTiQ0LCAoKSA9PiB7XHJcbiAgICAgICAgaWYgKGlzVmlzaWJsZSh0aGlzKSkge1xyXG4gICAgICAgICAgdGhpcy5mb2N1cygpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBhdm9pZCBjb25mbGljdCB3aGVuIGNsaWNraW5nIG1vZGFsIHRvZ2dsZXIgd2hpbGUgYW5vdGhlciBvbmUgaXMgb3BlblxyXG4gICAgY29uc3QgYWxyZWFkeU9wZW4gPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKE9QRU5fU0VMRUNUT1IkMSk7XHJcbiAgICBpZiAoYWxyZWFkeU9wZW4pIHtcclxuICAgICAgTW9kYWwuZ2V0SW5zdGFuY2UoYWxyZWFkeU9wZW4pLmhpZGUoKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGRhdGEgPSBNb2RhbC5nZXRPckNyZWF0ZUluc3RhbmNlKHRhcmdldCk7XHJcbiAgICBkYXRhLnRvZ2dsZSh0aGlzKTtcclxuICB9KTtcclxuICBlbmFibGVEaXNtaXNzVHJpZ2dlcihNb2RhbCk7XHJcblxyXG4gIC8qKlxyXG4gICAqIGpRdWVyeVxyXG4gICAqL1xyXG5cclxuICBkZWZpbmVKUXVlcnlQbHVnaW4oTW9kYWwpO1xyXG5cclxuICAvKipcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqIEJvb3RzdHJhcCBvZmZjYW52YXMuanNcclxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqL1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RhbnRzXHJcbiAgICovXHJcblxyXG4gIGNvbnN0IE5BTUUkNiA9ICdvZmZjYW52YXMnO1xyXG4gIGNvbnN0IERBVEFfS0VZJDMgPSAnYnMub2ZmY2FudmFzJztcclxuICBjb25zdCBFVkVOVF9LRVkkMyA9IGAuJHtEQVRBX0tFWSQzfWA7XHJcbiAgY29uc3QgREFUQV9BUElfS0VZJDEgPSAnLmRhdGEtYXBpJztcclxuICBjb25zdCBFVkVOVF9MT0FEX0RBVEFfQVBJJDIgPSBgbG9hZCR7RVZFTlRfS0VZJDN9JHtEQVRBX0FQSV9LRVkkMX1gO1xyXG4gIGNvbnN0IEVTQ0FQRV9LRVkgPSAnRXNjYXBlJztcclxuICBjb25zdCBDTEFTU19OQU1FX1NIT1ckMyA9ICdzaG93JztcclxuICBjb25zdCBDTEFTU19OQU1FX1NIT1dJTkckMSA9ICdzaG93aW5nJztcclxuICBjb25zdCBDTEFTU19OQU1FX0hJRElORyA9ICdoaWRpbmcnO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfQkFDS0RST1AgPSAnb2ZmY2FudmFzLWJhY2tkcm9wJztcclxuICBjb25zdCBPUEVOX1NFTEVDVE9SID0gJy5vZmZjYW52YXMuc2hvdyc7XHJcbiAgY29uc3QgRVZFTlRfU0hPVyQzID0gYHNob3cke0VWRU5UX0tFWSQzfWA7XHJcbiAgY29uc3QgRVZFTlRfU0hPV04kMyA9IGBzaG93biR7RVZFTlRfS0VZJDN9YDtcclxuICBjb25zdCBFVkVOVF9ISURFJDMgPSBgaGlkZSR7RVZFTlRfS0VZJDN9YDtcclxuICBjb25zdCBFVkVOVF9ISURFX1BSRVZFTlRFRCA9IGBoaWRlUHJldmVudGVkJHtFVkVOVF9LRVkkM31gO1xyXG4gIGNvbnN0IEVWRU5UX0hJRERFTiQzID0gYGhpZGRlbiR7RVZFTlRfS0VZJDN9YDtcclxuICBjb25zdCBFVkVOVF9SRVNJWkUgPSBgcmVzaXplJHtFVkVOVF9LRVkkM31gO1xyXG4gIGNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJJDEgPSBgY2xpY2ske0VWRU5UX0tFWSQzfSR7REFUQV9BUElfS0VZJDF9YDtcclxuICBjb25zdCBFVkVOVF9LRVlET1dOX0RJU01JU1MgPSBga2V5ZG93bi5kaXNtaXNzJHtFVkVOVF9LRVkkM31gO1xyXG4gIGNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFJDEgPSAnW2RhdGEtYnMtdG9nZ2xlPVwib2ZmY2FudmFzXCJdJztcclxuICBjb25zdCBEZWZhdWx0JDUgPSB7XHJcbiAgICBiYWNrZHJvcDogdHJ1ZSxcclxuICAgIGtleWJvYXJkOiB0cnVlLFxyXG4gICAgc2Nyb2xsOiBmYWxzZVxyXG4gIH07XHJcbiAgY29uc3QgRGVmYXVsdFR5cGUkNSA9IHtcclxuICAgIGJhY2tkcm9wOiAnKGJvb2xlYW58c3RyaW5nKScsXHJcbiAgICBrZXlib2FyZDogJ2Jvb2xlYW4nLFxyXG4gICAgc2Nyb2xsOiAnYm9vbGVhbidcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDbGFzcyBkZWZpbml0aW9uXHJcbiAgICovXHJcblxyXG4gIGNsYXNzIE9mZmNhbnZhcyBleHRlbmRzIEJhc2VDb21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XHJcbiAgICAgIHN1cGVyKGVsZW1lbnQsIGNvbmZpZyk7XHJcbiAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcclxuICAgICAgdGhpcy5fYmFja2Ryb3AgPSB0aGlzLl9pbml0aWFsaXplQmFja0Ryb3AoKTtcclxuICAgICAgdGhpcy5fZm9jdXN0cmFwID0gdGhpcy5faW5pdGlhbGl6ZUZvY3VzVHJhcCgpO1xyXG4gICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldHRlcnNcclxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcclxuICAgICAgcmV0dXJuIERlZmF1bHQkNTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XHJcbiAgICAgIHJldHVybiBEZWZhdWx0VHlwZSQ1O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xyXG4gICAgICByZXR1cm4gTkFNRSQ2O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFB1YmxpY1xyXG4gICAgdG9nZ2xlKHJlbGF0ZWRUYXJnZXQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2lzU2hvd24gPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdyhyZWxhdGVkVGFyZ2V0KTtcclxuICAgIH1cclxuICAgIHNob3cocmVsYXRlZFRhcmdldCkge1xyXG4gICAgICBpZiAodGhpcy5faXNTaG93bikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBzaG93RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XJDMsIHtcclxuICAgICAgICByZWxhdGVkVGFyZ2V0XHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5faXNTaG93biA9IHRydWU7XHJcbiAgICAgIHRoaXMuX2JhY2tkcm9wLnNob3coKTtcclxuICAgICAgaWYgKCF0aGlzLl9jb25maWcuc2Nyb2xsKSB7XHJcbiAgICAgICAgbmV3IFNjcm9sbEJhckhlbHBlcigpLmhpZGUoKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1tb2RhbCcsIHRydWUpO1xyXG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdkaWFsb2cnKTtcclxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPV0lORyQxKTtcclxuICAgICAgY29uc3QgY29tcGxldGVDYWxsQmFjayA9ICgpID0+IHtcclxuICAgICAgICBpZiAoIXRoaXMuX2NvbmZpZy5zY3JvbGwgfHwgdGhpcy5fY29uZmlnLmJhY2tkcm9wKSB7XHJcbiAgICAgICAgICB0aGlzLl9mb2N1c3RyYXAuYWN0aXZhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQzKTtcclxuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XSU5HJDEpO1xyXG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOJDMsIHtcclxuICAgICAgICAgIHJlbGF0ZWRUYXJnZXRcclxuICAgICAgICB9KTtcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZUNhbGxCYWNrLCB0aGlzLl9lbGVtZW50LCB0cnVlKTtcclxuICAgIH1cclxuICAgIGhpZGUoKSB7XHJcbiAgICAgIGlmICghdGhpcy5faXNTaG93bikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFJDMpO1xyXG4gICAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fZm9jdXN0cmFwLmRlYWN0aXZhdGUoKTtcclxuICAgICAgdGhpcy5fZWxlbWVudC5ibHVyKCk7XHJcbiAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcclxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfSElESU5HKTtcclxuICAgICAgdGhpcy5fYmFja2Ryb3AuaGlkZSgpO1xyXG4gICAgICBjb25zdCBjb21wbGV0ZUNhbGxiYWNrID0gKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1ckMywgQ0xBU1NfTkFNRV9ISURJTkcpO1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLW1vZGFsJyk7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3JvbGUnKTtcclxuICAgICAgICBpZiAoIXRoaXMuX2NvbmZpZy5zY3JvbGwpIHtcclxuICAgICAgICAgIG5ldyBTY3JvbGxCYXJIZWxwZXIoKS5yZXNldCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURERU4kMyk7XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGVDYWxsYmFjaywgdGhpcy5fZWxlbWVudCwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICB0aGlzLl9iYWNrZHJvcC5kaXNwb3NlKCk7XHJcbiAgICAgIHRoaXMuX2ZvY3VzdHJhcC5kZWFjdGl2YXRlKCk7XHJcbiAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQcml2YXRlXHJcbiAgICBfaW5pdGlhbGl6ZUJhY2tEcm9wKCkge1xyXG4gICAgICBjb25zdCBjbGlja0NhbGxiYWNrID0gKCkgPT4ge1xyXG4gICAgICAgIGlmICh0aGlzLl9jb25maWcuYmFja2Ryb3AgPT09ICdzdGF0aWMnKSB7XHJcbiAgICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFX1BSRVZFTlRFRCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gJ3N0YXRpYycgb3B0aW9uIHdpbGwgYmUgdHJhbnNsYXRlZCB0byB0cnVlLCBhbmQgYm9vbGVhbnMgd2lsbCBrZWVwIHRoZWlyIHZhbHVlXHJcbiAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IEJvb2xlYW4odGhpcy5fY29uZmlnLmJhY2tkcm9wKTtcclxuICAgICAgcmV0dXJuIG5ldyBCYWNrZHJvcCh7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBDTEFTU19OQU1FX0JBQ0tEUk9QLFxyXG4gICAgICAgIGlzVmlzaWJsZSxcclxuICAgICAgICBpc0FuaW1hdGVkOiB0cnVlLFxyXG4gICAgICAgIHJvb3RFbGVtZW50OiB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUsXHJcbiAgICAgICAgY2xpY2tDYWxsYmFjazogaXNWaXNpYmxlID8gY2xpY2tDYWxsYmFjayA6IG51bGxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfaW5pdGlhbGl6ZUZvY3VzVHJhcCgpIHtcclxuICAgICAgcmV0dXJuIG5ldyBGb2N1c1RyYXAoe1xyXG4gICAgICAgIHRyYXBFbGVtZW50OiB0aGlzLl9lbGVtZW50XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xyXG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfS0VZRE9XTl9ESVNNSVNTLCBldmVudCA9PiB7XHJcbiAgICAgICAgaWYgKGV2ZW50LmtleSAhPT0gRVNDQVBFX0tFWSkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fY29uZmlnLmtleWJvYXJkKSB7XHJcbiAgICAgICAgICB0aGlzLmhpZGUoKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERV9QUkVWRU5URUQpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTdGF0aWNcclxuICAgIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBPZmZjYW52YXMuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGF0YVtjb25maWddID09PSB1bmRlZmluZWQgfHwgY29uZmlnLnN0YXJ0c1dpdGgoJ18nKSB8fCBjb25maWcgPT09ICdjb25zdHJ1Y3RvcicpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRhdGFbY29uZmlnXSh0aGlzKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxyXG4gICAqL1xyXG5cclxuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDEsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDEsIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gU2VsZWN0b3JFbmdpbmUuZ2V0RWxlbWVudEZyb21TZWxlY3Rvcih0aGlzKTtcclxuICAgIGlmIChbJ0EnLCAnQVJFQSddLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkpIHtcclxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIH1cclxuICAgIGlmIChpc0Rpc2FibGVkKHRoaXMpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIEV2ZW50SGFuZGxlci5vbmUodGFyZ2V0LCBFVkVOVF9ISURERU4kMywgKCkgPT4ge1xyXG4gICAgICAvLyBmb2N1cyBvbiB0cmlnZ2VyIHdoZW4gaXQgaXMgY2xvc2VkXHJcbiAgICAgIGlmIChpc1Zpc2libGUodGhpcykpIHtcclxuICAgICAgICB0aGlzLmZvY3VzKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIGF2b2lkIGNvbmZsaWN0IHdoZW4gY2xpY2tpbmcgYSB0b2dnbGVyIG9mIGFuIG9mZmNhbnZhcywgd2hpbGUgYW5vdGhlciBpcyBvcGVuXHJcbiAgICBjb25zdCBhbHJlYWR5T3BlbiA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoT1BFTl9TRUxFQ1RPUik7XHJcbiAgICBpZiAoYWxyZWFkeU9wZW4gJiYgYWxyZWFkeU9wZW4gIT09IHRhcmdldCkge1xyXG4gICAgICBPZmZjYW52YXMuZ2V0SW5zdGFuY2UoYWxyZWFkeU9wZW4pLmhpZGUoKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGRhdGEgPSBPZmZjYW52YXMuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0YXJnZXQpO1xyXG4gICAgZGF0YS50b2dnbGUodGhpcyk7XHJcbiAgfSk7XHJcbiAgRXZlbnRIYW5kbGVyLm9uKHdpbmRvdywgRVZFTlRfTE9BRF9EQVRBX0FQSSQyLCAoKSA9PiB7XHJcbiAgICBmb3IgKGNvbnN0IHNlbGVjdG9yIG9mIFNlbGVjdG9yRW5naW5lLmZpbmQoT1BFTl9TRUxFQ1RPUikpIHtcclxuICAgICAgT2ZmY2FudmFzLmdldE9yQ3JlYXRlSW5zdGFuY2Uoc2VsZWN0b3IpLnNob3coKTtcclxuICAgIH1cclxuICB9KTtcclxuICBFdmVudEhhbmRsZXIub24od2luZG93LCBFVkVOVF9SRVNJWkUsICgpID0+IHtcclxuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBTZWxlY3RvckVuZ2luZS5maW5kKCdbYXJpYS1tb2RhbF1bY2xhc3MqPXNob3ddW2NsYXNzKj1vZmZjYW52YXMtXScpKSB7XHJcbiAgICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uICE9PSAnZml4ZWQnKSB7XHJcbiAgICAgICAgT2ZmY2FudmFzLmdldE9yQ3JlYXRlSW5zdGFuY2UoZWxlbWVudCkuaGlkZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgZW5hYmxlRGlzbWlzc1RyaWdnZXIoT2ZmY2FudmFzKTtcclxuXHJcbiAgLyoqXHJcbiAgICogalF1ZXJ5XHJcbiAgICovXHJcblxyXG4gIGRlZmluZUpRdWVyeVBsdWdpbihPZmZjYW52YXMpO1xyXG5cclxuICAvKipcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqIEJvb3RzdHJhcCB1dGlsL3Nhbml0aXplci5qc1xyXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICovXHJcblxyXG4gIC8vIGpzLWRvY3Mtc3RhcnQgYWxsb3ctbGlzdFxyXG4gIGNvbnN0IEFSSUFfQVRUUklCVVRFX1BBVFRFUk4gPSAvXmFyaWEtW1xcdy1dKiQvaTtcclxuICBjb25zdCBEZWZhdWx0QWxsb3dsaXN0ID0ge1xyXG4gICAgLy8gR2xvYmFsIGF0dHJpYnV0ZXMgYWxsb3dlZCBvbiBhbnkgc3VwcGxpZWQgZWxlbWVudCBiZWxvdy5cclxuICAgICcqJzogWydjbGFzcycsICdkaXInLCAnaWQnLCAnbGFuZycsICdyb2xlJywgQVJJQV9BVFRSSUJVVEVfUEFUVEVSTl0sXHJcbiAgICBhOiBbJ3RhcmdldCcsICdocmVmJywgJ3RpdGxlJywgJ3JlbCddLFxyXG4gICAgYXJlYTogW10sXHJcbiAgICBiOiBbXSxcclxuICAgIGJyOiBbXSxcclxuICAgIGNvbDogW10sXHJcbiAgICBjb2RlOiBbXSxcclxuICAgIGRkOiBbXSxcclxuICAgIGRpdjogW10sXHJcbiAgICBkbDogW10sXHJcbiAgICBkdDogW10sXHJcbiAgICBlbTogW10sXHJcbiAgICBocjogW10sXHJcbiAgICBoMTogW10sXHJcbiAgICBoMjogW10sXHJcbiAgICBoMzogW10sXHJcbiAgICBoNDogW10sXHJcbiAgICBoNTogW10sXHJcbiAgICBoNjogW10sXHJcbiAgICBpOiBbXSxcclxuICAgIGltZzogWydzcmMnLCAnc3Jjc2V0JywgJ2FsdCcsICd0aXRsZScsICd3aWR0aCcsICdoZWlnaHQnXSxcclxuICAgIGxpOiBbXSxcclxuICAgIG9sOiBbXSxcclxuICAgIHA6IFtdLFxyXG4gICAgcHJlOiBbXSxcclxuICAgIHM6IFtdLFxyXG4gICAgc21hbGw6IFtdLFxyXG4gICAgc3BhbjogW10sXHJcbiAgICBzdWI6IFtdLFxyXG4gICAgc3VwOiBbXSxcclxuICAgIHN0cm9uZzogW10sXHJcbiAgICB1OiBbXSxcclxuICAgIHVsOiBbXVxyXG4gIH07XHJcbiAgLy8ganMtZG9jcy1lbmQgYWxsb3ctbGlzdFxyXG5cclxuICBjb25zdCB1cmlBdHRyaWJ1dGVzID0gbmV3IFNldChbJ2JhY2tncm91bmQnLCAnY2l0ZScsICdocmVmJywgJ2l0ZW10eXBlJywgJ2xvbmdkZXNjJywgJ3Bvc3RlcicsICdzcmMnLCAneGxpbms6aHJlZiddKTtcclxuXHJcbiAgLyoqXHJcbiAgICogQSBwYXR0ZXJuIHRoYXQgcmVjb2duaXplcyBVUkxzIHRoYXQgYXJlIHNhZmUgd3J0LiBYU1MgaW4gVVJMIG5hdmlnYXRpb25cclxuICAgKiBjb250ZXh0cy5cclxuICAgKlxyXG4gICAqIFNob3V0LW91dCB0byBBbmd1bGFyIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvYmxvYi8xNS4yLjgvcGFja2FnZXMvY29yZS9zcmMvc2FuaXRpemF0aW9uL3VybF9zYW5pdGl6ZXIudHMjTDM4XHJcbiAgICovXHJcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vYmV0dGVyLXJlZ2V4XHJcbiAgY29uc3QgU0FGRV9VUkxfUEFUVEVSTiA9IC9eKD8hamF2YXNjcmlwdDopKD86W2EtejAtOSsuLV0rOnxbXiY6Lz8jXSooPzpbLz8jXXwkKSkvaTtcclxuICBjb25zdCBhbGxvd2VkQXR0cmlidXRlID0gKGF0dHJpYnV0ZSwgYWxsb3dlZEF0dHJpYnV0ZUxpc3QpID0+IHtcclxuICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgIGlmIChhbGxvd2VkQXR0cmlidXRlTGlzdC5pbmNsdWRlcyhhdHRyaWJ1dGVOYW1lKSkge1xyXG4gICAgICBpZiAodXJpQXR0cmlidXRlcy5oYXMoYXR0cmlidXRlTmFtZSkpIHtcclxuICAgICAgICByZXR1cm4gQm9vbGVhbihTQUZFX1VSTF9QQVRURVJOLnRlc3QoYXR0cmlidXRlLm5vZGVWYWx1ZSkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENoZWNrIGlmIGEgcmVndWxhciBleHByZXNzaW9uIHZhbGlkYXRlcyB0aGUgYXR0cmlidXRlLlxyXG4gICAgcmV0dXJuIGFsbG93ZWRBdHRyaWJ1dGVMaXN0LmZpbHRlcihhdHRyaWJ1dGVSZWdleCA9PiBhdHRyaWJ1dGVSZWdleCBpbnN0YW5jZW9mIFJlZ0V4cCkuc29tZShyZWdleCA9PiByZWdleC50ZXN0KGF0dHJpYnV0ZU5hbWUpKTtcclxuICB9O1xyXG4gIGZ1bmN0aW9uIHNhbml0aXplSHRtbCh1bnNhZmVIdG1sLCBhbGxvd0xpc3QsIHNhbml0aXplRnVuY3Rpb24pIHtcclxuICAgIGlmICghdW5zYWZlSHRtbC5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIHVuc2FmZUh0bWw7XHJcbiAgICB9XHJcbiAgICBpZiAoc2FuaXRpemVGdW5jdGlvbiAmJiB0eXBlb2Ygc2FuaXRpemVGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICByZXR1cm4gc2FuaXRpemVGdW5jdGlvbih1bnNhZmVIdG1sKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGRvbVBhcnNlciA9IG5ldyB3aW5kb3cuRE9NUGFyc2VyKCk7XHJcbiAgICBjb25zdCBjcmVhdGVkRG9jdW1lbnQgPSBkb21QYXJzZXIucGFyc2VGcm9tU3RyaW5nKHVuc2FmZUh0bWwsICd0ZXh0L2h0bWwnKTtcclxuICAgIGNvbnN0IGVsZW1lbnRzID0gW10uY29uY2F0KC4uLmNyZWF0ZWREb2N1bWVudC5ib2R5LnF1ZXJ5U2VsZWN0b3JBbGwoJyonKSk7XHJcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcclxuICAgICAgY29uc3QgZWxlbWVudE5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgIGlmICghT2JqZWN0LmtleXMoYWxsb3dMaXN0KS5pbmNsdWRlcyhlbGVtZW50TmFtZSkpIHtcclxuICAgICAgICBlbGVtZW50LnJlbW92ZSgpO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZUxpc3QgPSBbXS5jb25jYXQoLi4uZWxlbWVudC5hdHRyaWJ1dGVzKTtcclxuICAgICAgY29uc3QgYWxsb3dlZEF0dHJpYnV0ZXMgPSBbXS5jb25jYXQoYWxsb3dMaXN0WycqJ10gfHwgW10sIGFsbG93TGlzdFtlbGVtZW50TmFtZV0gfHwgW10pO1xyXG4gICAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiBhdHRyaWJ1dGVMaXN0KSB7XHJcbiAgICAgICAgaWYgKCFhbGxvd2VkQXR0cmlidXRlKGF0dHJpYnV0ZSwgYWxsb3dlZEF0dHJpYnV0ZXMpKSB7XHJcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUubm9kZU5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNyZWF0ZWREb2N1bWVudC5ib2R5LmlubmVySFRNTDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICogQm9vdHN0cmFwIHV0aWwvdGVtcGxhdGUtZmFjdG9yeS5qc1xyXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICovXHJcblxyXG5cclxuICAvKipcclxuICAgKiBDb25zdGFudHNcclxuICAgKi9cclxuXHJcbiAgY29uc3QgTkFNRSQ1ID0gJ1RlbXBsYXRlRmFjdG9yeSc7XHJcbiAgY29uc3QgRGVmYXVsdCQ0ID0ge1xyXG4gICAgYWxsb3dMaXN0OiBEZWZhdWx0QWxsb3dsaXN0LFxyXG4gICAgY29udGVudDoge30sXHJcbiAgICAvLyB7IHNlbGVjdG9yIDogdGV4dCAsICBzZWxlY3RvcjIgOiB0ZXh0MiAsIH1cclxuICAgIGV4dHJhQ2xhc3M6ICcnLFxyXG4gICAgaHRtbDogZmFsc2UsXHJcbiAgICBzYW5pdGl6ZTogdHJ1ZSxcclxuICAgIHNhbml0aXplRm46IG51bGwsXHJcbiAgICB0ZW1wbGF0ZTogJzxkaXY+PC9kaXY+J1xyXG4gIH07XHJcbiAgY29uc3QgRGVmYXVsdFR5cGUkNCA9IHtcclxuICAgIGFsbG93TGlzdDogJ29iamVjdCcsXHJcbiAgICBjb250ZW50OiAnb2JqZWN0JyxcclxuICAgIGV4dHJhQ2xhc3M6ICcoc3RyaW5nfGZ1bmN0aW9uKScsXHJcbiAgICBodG1sOiAnYm9vbGVhbicsXHJcbiAgICBzYW5pdGl6ZTogJ2Jvb2xlYW4nLFxyXG4gICAgc2FuaXRpemVGbjogJyhudWxsfGZ1bmN0aW9uKScsXHJcbiAgICB0ZW1wbGF0ZTogJ3N0cmluZydcclxuICB9O1xyXG4gIGNvbnN0IERlZmF1bHRDb250ZW50VHlwZSA9IHtcclxuICAgIGVudHJ5OiAnKHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9ufG51bGwpJyxcclxuICAgIHNlbGVjdG9yOiAnKHN0cmluZ3xlbGVtZW50KSdcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDbGFzcyBkZWZpbml0aW9uXHJcbiAgICovXHJcblxyXG4gIGNsYXNzIFRlbXBsYXRlRmFjdG9yeSBleHRlbmRzIENvbmZpZyB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gR2V0dGVyc1xyXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xyXG4gICAgICByZXR1cm4gRGVmYXVsdCQ0O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcclxuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJDQ7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XHJcbiAgICAgIHJldHVybiBOQU1FJDU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHVibGljXHJcbiAgICBnZXRDb250ZW50KCkge1xyXG4gICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLl9jb25maWcuY29udGVudCkubWFwKGNvbmZpZyA9PiB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbihjb25maWcpKS5maWx0ZXIoQm9vbGVhbik7XHJcbiAgICB9XHJcbiAgICBoYXNDb250ZW50KCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5nZXRDb250ZW50KCkubGVuZ3RoID4gMDtcclxuICAgIH1cclxuICAgIGNoYW5nZUNvbnRlbnQoY29udGVudCkge1xyXG4gICAgICB0aGlzLl9jaGVja0NvbnRlbnQoY29udGVudCk7XHJcbiAgICAgIHRoaXMuX2NvbmZpZy5jb250ZW50ID0ge1xyXG4gICAgICAgIC4uLnRoaXMuX2NvbmZpZy5jb250ZW50LFxyXG4gICAgICAgIC4uLmNvbnRlbnRcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICB0b0h0bWwoKSB7XHJcbiAgICAgIGNvbnN0IHRlbXBsYXRlV3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICB0ZW1wbGF0ZVdyYXBwZXIuaW5uZXJIVE1MID0gdGhpcy5fbWF5YmVTYW5pdGl6ZSh0aGlzLl9jb25maWcudGVtcGxhdGUpO1xyXG4gICAgICBmb3IgKGNvbnN0IFtzZWxlY3RvciwgdGV4dF0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5fY29uZmlnLmNvbnRlbnQpKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0Q29udGVudCh0ZW1wbGF0ZVdyYXBwZXIsIHRleHQsIHNlbGVjdG9yKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRlbXBsYXRlV3JhcHBlci5jaGlsZHJlblswXTtcclxuICAgICAgY29uc3QgZXh0cmFDbGFzcyA9IHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHRoaXMuX2NvbmZpZy5leHRyYUNsYXNzKTtcclxuICAgICAgaWYgKGV4dHJhQ2xhc3MpIHtcclxuICAgICAgICB0ZW1wbGF0ZS5jbGFzc0xpc3QuYWRkKC4uLmV4dHJhQ2xhc3Muc3BsaXQoJyAnKSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRlbXBsYXRlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFByaXZhdGVcclxuICAgIF90eXBlQ2hlY2tDb25maWcoY29uZmlnKSB7XHJcbiAgICAgIHN1cGVyLl90eXBlQ2hlY2tDb25maWcoY29uZmlnKTtcclxuICAgICAgdGhpcy5fY2hlY2tDb250ZW50KGNvbmZpZy5jb250ZW50KTtcclxuICAgIH1cclxuICAgIF9jaGVja0NvbnRlbnQoYXJnKSB7XHJcbiAgICAgIGZvciAoY29uc3QgW3NlbGVjdG9yLCBjb250ZW50XSBvZiBPYmplY3QuZW50cmllcyhhcmcpKSB7XHJcbiAgICAgICAgc3VwZXIuX3R5cGVDaGVja0NvbmZpZyh7XHJcbiAgICAgICAgICBzZWxlY3RvcixcclxuICAgICAgICAgIGVudHJ5OiBjb250ZW50XHJcbiAgICAgICAgfSwgRGVmYXVsdENvbnRlbnRUeXBlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3NldENvbnRlbnQodGVtcGxhdGUsIGNvbnRlbnQsIHNlbGVjdG9yKSB7XHJcbiAgICAgIGNvbnN0IHRlbXBsYXRlRWxlbWVudCA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoc2VsZWN0b3IsIHRlbXBsYXRlKTtcclxuICAgICAgaWYgKCF0ZW1wbGF0ZUVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29udGVudCA9IHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKGNvbnRlbnQpO1xyXG4gICAgICBpZiAoIWNvbnRlbnQpIHtcclxuICAgICAgICB0ZW1wbGF0ZUVsZW1lbnQucmVtb3ZlKCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc0VsZW1lbnQkMShjb250ZW50KSkge1xyXG4gICAgICAgIHRoaXMuX3B1dEVsZW1lbnRJblRlbXBsYXRlKGdldEVsZW1lbnQoY29udGVudCksIHRlbXBsYXRlRWxlbWVudCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLl9jb25maWcuaHRtbCkge1xyXG4gICAgICAgIHRlbXBsYXRlRWxlbWVudC5pbm5lckhUTUwgPSB0aGlzLl9tYXliZVNhbml0aXplKGNvbnRlbnQpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0ZW1wbGF0ZUVsZW1lbnQudGV4dENvbnRlbnQgPSBjb250ZW50O1xyXG4gICAgfVxyXG4gICAgX21heWJlU2FuaXRpemUoYXJnKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9jb25maWcuc2FuaXRpemUgPyBzYW5pdGl6ZUh0bWwoYXJnLCB0aGlzLl9jb25maWcuYWxsb3dMaXN0LCB0aGlzLl9jb25maWcuc2FuaXRpemVGbikgOiBhcmc7XHJcbiAgICB9XHJcbiAgICBfcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24oYXJnKSB7XHJcbiAgICAgIHJldHVybiBleGVjdXRlKGFyZywgW3RoaXNdKTtcclxuICAgIH1cclxuICAgIF9wdXRFbGVtZW50SW5UZW1wbGF0ZShlbGVtZW50LCB0ZW1wbGF0ZUVsZW1lbnQpIHtcclxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5odG1sKSB7XHJcbiAgICAgICAgdGVtcGxhdGVFbGVtZW50LmlubmVySFRNTCA9ICcnO1xyXG4gICAgICAgIHRlbXBsYXRlRWxlbWVudC5hcHBlbmQoZWxlbWVudCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRlbXBsYXRlRWxlbWVudC50ZXh0Q29udGVudCA9IGVsZW1lbnQudGV4dENvbnRlbnQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqIEJvb3RzdHJhcCB0b29sdGlwLmpzXHJcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKi9cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0YW50c1xyXG4gICAqL1xyXG5cclxuICBjb25zdCBOQU1FJDQgPSAndG9vbHRpcCc7XHJcbiAgY29uc3QgRElTQUxMT1dFRF9BVFRSSUJVVEVTID0gbmV3IFNldChbJ3Nhbml0aXplJywgJ2FsbG93TGlzdCcsICdzYW5pdGl6ZUZuJ10pO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfRkFERSQyID0gJ2ZhZGUnO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfTU9EQUwgPSAnbW9kYWwnO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfU0hPVyQyID0gJ3Nob3cnO1xyXG4gIGNvbnN0IFNFTEVDVE9SX1RPT0xUSVBfSU5ORVIgPSAnLnRvb2x0aXAtaW5uZXInO1xyXG4gIGNvbnN0IFNFTEVDVE9SX01PREFMID0gYC4ke0NMQVNTX05BTUVfTU9EQUx9YDtcclxuICBjb25zdCBFVkVOVF9NT0RBTF9ISURFID0gJ2hpZGUuYnMubW9kYWwnO1xyXG4gIGNvbnN0IFRSSUdHRVJfSE9WRVIgPSAnaG92ZXInO1xyXG4gIGNvbnN0IFRSSUdHRVJfRk9DVVMgPSAnZm9jdXMnO1xyXG4gIGNvbnN0IFRSSUdHRVJfQ0xJQ0sgPSAnY2xpY2snO1xyXG4gIGNvbnN0IFRSSUdHRVJfTUFOVUFMID0gJ21hbnVhbCc7XHJcbiAgY29uc3QgRVZFTlRfSElERSQyID0gJ2hpZGUnO1xyXG4gIGNvbnN0IEVWRU5UX0hJRERFTiQyID0gJ2hpZGRlbic7XHJcbiAgY29uc3QgRVZFTlRfU0hPVyQyID0gJ3Nob3cnO1xyXG4gIGNvbnN0IEVWRU5UX1NIT1dOJDIgPSAnc2hvd24nO1xyXG4gIGNvbnN0IEVWRU5UX0lOU0VSVEVEID0gJ2luc2VydGVkJztcclxuICBjb25zdCBFVkVOVF9DTElDSyQxID0gJ2NsaWNrJztcclxuICBjb25zdCBFVkVOVF9GT0NVU0lOJDEgPSAnZm9jdXNpbic7XHJcbiAgY29uc3QgRVZFTlRfRk9DVVNPVVQkMSA9ICdmb2N1c291dCc7XHJcbiAgY29uc3QgRVZFTlRfTU9VU0VFTlRFUiA9ICdtb3VzZWVudGVyJztcclxuICBjb25zdCBFVkVOVF9NT1VTRUxFQVZFID0gJ21vdXNlbGVhdmUnO1xyXG4gIGNvbnN0IEF0dGFjaG1lbnRNYXAgPSB7XHJcbiAgICBBVVRPOiAnYXV0bycsXHJcbiAgICBUT1A6ICd0b3AnLFxyXG4gICAgUklHSFQ6IGlzUlRMKCkgPyAnbGVmdCcgOiAncmlnaHQnLFxyXG4gICAgQk9UVE9NOiAnYm90dG9tJyxcclxuICAgIExFRlQ6IGlzUlRMKCkgPyAncmlnaHQnIDogJ2xlZnQnXHJcbiAgfTtcclxuICBjb25zdCBEZWZhdWx0JDMgPSB7XHJcbiAgICBhbGxvd0xpc3Q6IERlZmF1bHRBbGxvd2xpc3QsXHJcbiAgICBhbmltYXRpb246IHRydWUsXHJcbiAgICBib3VuZGFyeTogJ2NsaXBwaW5nUGFyZW50cycsXHJcbiAgICBjb250YWluZXI6IGZhbHNlLFxyXG4gICAgY3VzdG9tQ2xhc3M6ICcnLFxyXG4gICAgZGVsYXk6IDAsXHJcbiAgICBmYWxsYmFja1BsYWNlbWVudHM6IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10sXHJcbiAgICBodG1sOiBmYWxzZSxcclxuICAgIG9mZnNldDogWzAsIDZdLFxyXG4gICAgcGxhY2VtZW50OiAndG9wJyxcclxuICAgIHBvcHBlckNvbmZpZzogbnVsbCxcclxuICAgIHNhbml0aXplOiB0cnVlLFxyXG4gICAgc2FuaXRpemVGbjogbnVsbCxcclxuICAgIHNlbGVjdG9yOiBmYWxzZSxcclxuICAgIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cInRvb2x0aXBcIiByb2xlPVwidG9vbHRpcFwiPicgKyAnPGRpdiBjbGFzcz1cInRvb2x0aXAtYXJyb3dcIj48L2Rpdj4nICsgJzxkaXYgY2xhc3M9XCJ0b29sdGlwLWlubmVyXCI+PC9kaXY+JyArICc8L2Rpdj4nLFxyXG4gICAgdGl0bGU6ICcnLFxyXG4gICAgdHJpZ2dlcjogJ2hvdmVyIGZvY3VzJ1xyXG4gIH07XHJcbiAgY29uc3QgRGVmYXVsdFR5cGUkMyA9IHtcclxuICAgIGFsbG93TGlzdDogJ29iamVjdCcsXHJcbiAgICBhbmltYXRpb246ICdib29sZWFuJyxcclxuICAgIGJvdW5kYXJ5OiAnKHN0cmluZ3xlbGVtZW50KScsXHJcbiAgICBjb250YWluZXI6ICcoc3RyaW5nfGVsZW1lbnR8Ym9vbGVhbiknLFxyXG4gICAgY3VzdG9tQ2xhc3M6ICcoc3RyaW5nfGZ1bmN0aW9uKScsXHJcbiAgICBkZWxheTogJyhudW1iZXJ8b2JqZWN0KScsXHJcbiAgICBmYWxsYmFja1BsYWNlbWVudHM6ICdhcnJheScsXHJcbiAgICBodG1sOiAnYm9vbGVhbicsXHJcbiAgICBvZmZzZXQ6ICcoYXJyYXl8c3RyaW5nfGZ1bmN0aW9uKScsXHJcbiAgICBwbGFjZW1lbnQ6ICcoc3RyaW5nfGZ1bmN0aW9uKScsXHJcbiAgICBwb3BwZXJDb25maWc6ICcobnVsbHxvYmplY3R8ZnVuY3Rpb24pJyxcclxuICAgIHNhbml0aXplOiAnYm9vbGVhbicsXHJcbiAgICBzYW5pdGl6ZUZuOiAnKG51bGx8ZnVuY3Rpb24pJyxcclxuICAgIHNlbGVjdG9yOiAnKHN0cmluZ3xib29sZWFuKScsXHJcbiAgICB0ZW1wbGF0ZTogJ3N0cmluZycsXHJcbiAgICB0aXRsZTogJyhzdHJpbmd8ZWxlbWVudHxmdW5jdGlvbiknLFxyXG4gICAgdHJpZ2dlcjogJ3N0cmluZydcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDbGFzcyBkZWZpbml0aW9uXHJcbiAgICovXHJcblxyXG4gIGNsYXNzIFRvb2x0aXAgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xyXG4gICAgICBpZiAodHlwZW9mIFBvcHBlciA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb290c3RyYXBcXCdzIHRvb2x0aXBzIHJlcXVpcmUgUG9wcGVyIChodHRwczovL3BvcHBlci5qcy5vcmcpJyk7XHJcbiAgICAgIH1cclxuICAgICAgc3VwZXIoZWxlbWVudCwgY29uZmlnKTtcclxuXHJcbiAgICAgIC8vIFByaXZhdGVcclxuICAgICAgdGhpcy5faXNFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgdGhpcy5fdGltZW91dCA9IDA7XHJcbiAgICAgIHRoaXMuX2lzSG92ZXJlZCA9IG51bGw7XHJcbiAgICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXIgPSB7fTtcclxuICAgICAgdGhpcy5fcG9wcGVyID0gbnVsbDtcclxuICAgICAgdGhpcy5fdGVtcGxhdGVGYWN0b3J5ID0gbnVsbDtcclxuICAgICAgdGhpcy5fbmV3Q29udGVudCA9IG51bGw7XHJcblxyXG4gICAgICAvLyBQcm90ZWN0ZWRcclxuICAgICAgdGhpcy50aXAgPSBudWxsO1xyXG4gICAgICB0aGlzLl9zZXRMaXN0ZW5lcnMoKTtcclxuICAgICAgaWYgKCF0aGlzLl9jb25maWcuc2VsZWN0b3IpIHtcclxuICAgICAgICB0aGlzLl9maXhUaXRsZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gR2V0dGVyc1xyXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xyXG4gICAgICByZXR1cm4gRGVmYXVsdCQzO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcclxuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJDM7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XHJcbiAgICAgIHJldHVybiBOQU1FJDQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHVibGljXHJcbiAgICBlbmFibGUoKSB7XHJcbiAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBkaXNhYmxlKCkge1xyXG4gICAgICB0aGlzLl9pc0VuYWJsZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHRvZ2dsZUVuYWJsZWQoKSB7XHJcbiAgICAgIHRoaXMuX2lzRW5hYmxlZCA9ICF0aGlzLl9pc0VuYWJsZWQ7XHJcbiAgICB9XHJcbiAgICB0b2dnbGUoKSB7XHJcbiAgICAgIGlmICghdGhpcy5faXNFbmFibGVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXIuY2xpY2sgPSAhdGhpcy5fYWN0aXZlVHJpZ2dlci5jbGljaztcclxuICAgICAgaWYgKHRoaXMuX2lzU2hvd24oKSkge1xyXG4gICAgICAgIHRoaXMuX2xlYXZlKCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2VudGVyKCk7XHJcbiAgICB9XHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XHJcbiAgICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fZWxlbWVudC5jbG9zZXN0KFNFTEVDVE9SX01PREFMKSwgRVZFTlRfTU9EQUxfSElERSwgdGhpcy5faGlkZU1vZGFsSGFuZGxlcik7XHJcbiAgICAgIGlmICh0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1icy1vcmlnaW5hbC10aXRsZScpKSB7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtb3JpZ2luYWwtdGl0bGUnKSk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fZGlzcG9zZVBvcHBlcigpO1xyXG4gICAgICBzdXBlci5kaXNwb3NlKCk7XHJcbiAgICB9XHJcbiAgICBzaG93KCkge1xyXG4gICAgICBpZiAodGhpcy5fZWxlbWVudC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSB1c2Ugc2hvdyBvbiB2aXNpYmxlIGVsZW1lbnRzJyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCEodGhpcy5faXNXaXRoQ29udGVudCgpICYmIHRoaXMuX2lzRW5hYmxlZCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfU0hPVyQyKSk7XHJcbiAgICAgIGNvbnN0IHNoYWRvd1Jvb3QgPSBmaW5kU2hhZG93Um9vdCh0aGlzLl9lbGVtZW50KTtcclxuICAgICAgY29uc3QgaXNJblRoZURvbSA9IChzaGFkb3dSb290IHx8IHRoaXMuX2VsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLmNvbnRhaW5zKHRoaXMuX2VsZW1lbnQpO1xyXG4gICAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgfHwgIWlzSW5UaGVEb20pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRPRE86IHY2IHJlbW92ZSB0aGlzIG9yIG1ha2UgaXQgb3B0aW9uYWxcclxuICAgICAgdGhpcy5fZGlzcG9zZVBvcHBlcigpO1xyXG4gICAgICBjb25zdCB0aXAgPSB0aGlzLl9nZXRUaXBFbGVtZW50KCk7XHJcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5JywgdGlwLmdldEF0dHJpYnV0ZSgnaWQnKSk7XHJcbiAgICAgIGNvbnN0IHtcclxuICAgICAgICBjb250YWluZXJcclxuICAgICAgfSA9IHRoaXMuX2NvbmZpZztcclxuICAgICAgaWYgKCF0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKHRoaXMudGlwKSkge1xyXG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmQodGlwKTtcclxuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLmV2ZW50TmFtZShFVkVOVF9JTlNFUlRFRCkpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX3BvcHBlciA9IHRoaXMuX2NyZWF0ZVBvcHBlcih0aXApO1xyXG4gICAgICB0aXAuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1ckMik7XHJcblxyXG4gICAgICAvLyBJZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgYWRkIGV4dHJhXHJcbiAgICAgIC8vIGVtcHR5IG1vdXNlb3ZlciBsaXN0ZW5lcnMgdG8gdGhlIGJvZHkncyBpbW1lZGlhdGUgY2hpbGRyZW47XHJcbiAgICAgIC8vIG9ubHkgbmVlZGVkIGJlY2F1c2Ugb2YgYnJva2VuIGV2ZW50IGRlbGVnYXRpb24gb24gaU9TXHJcbiAgICAgIC8vIGh0dHBzOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxNC8wMi9tb3VzZV9ldmVudF9idWIuaHRtbFxyXG4gICAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKSkge1xyXG4gICAgICAgICAgRXZlbnRIYW5kbGVyLm9uKGVsZW1lbnQsICdtb3VzZW92ZXInLCBub29wKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XHJcbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfU0hPV04kMikpO1xyXG4gICAgICAgIGlmICh0aGlzLl9pc0hvdmVyZWQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICB0aGlzLl9sZWF2ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9pc0hvdmVyZWQgPSBmYWxzZTtcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgdGhpcy50aXAsIHRoaXMuX2lzQW5pbWF0ZWQoKSk7XHJcbiAgICB9XHJcbiAgICBoaWRlKCkge1xyXG4gICAgICBpZiAoIXRoaXMuX2lzU2hvd24oKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLmV2ZW50TmFtZShFVkVOVF9ISURFJDIpKTtcclxuICAgICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHRpcCA9IHRoaXMuX2dldFRpcEVsZW1lbnQoKTtcclxuICAgICAgdGlwLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDIpO1xyXG5cclxuICAgICAgLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIHJlbW92ZSB0aGUgZXh0cmFcclxuICAgICAgLy8gZW1wdHkgbW91c2VvdmVyIGxpc3RlbmVycyB3ZSBhZGRlZCBmb3IgaU9TIHN1cHBvcnRcclxuICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBbXS5jb25jYXQoLi4uZG9jdW1lbnQuYm9keS5jaGlsZHJlbikpIHtcclxuICAgICAgICAgIEV2ZW50SGFuZGxlci5vZmYoZWxlbWVudCwgJ21vdXNlb3ZlcicsIG5vb3ApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyW1RSSUdHRVJfQ0xJQ0tdID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXJbVFJJR0dFUl9GT0NVU10gPSBmYWxzZTtcclxuICAgICAgdGhpcy5fYWN0aXZlVHJpZ2dlcltUUklHR0VSX0hPVkVSXSA9IGZhbHNlO1xyXG4gICAgICB0aGlzLl9pc0hvdmVyZWQgPSBudWxsOyAvLyBpdCBpcyBhIHRyaWNrIHRvIHN1cHBvcnQgbWFudWFsIHRyaWdnZXJpbmdcclxuXHJcbiAgICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xyXG4gICAgICAgIGlmICh0aGlzLl9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pc0hvdmVyZWQpIHtcclxuICAgICAgICAgIHRoaXMuX2Rpc3Bvc2VQb3BwZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknKTtcclxuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLmV2ZW50TmFtZShFVkVOVF9ISURERU4kMikpO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCB0aGlzLnRpcCwgdGhpcy5faXNBbmltYXRlZCgpKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZSgpIHtcclxuICAgICAgaWYgKHRoaXMuX3BvcHBlcikge1xyXG4gICAgICAgIHRoaXMuX3BvcHBlci51cGRhdGUoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFByb3RlY3RlZFxyXG4gICAgX2lzV2l0aENvbnRlbnQoKSB7XHJcbiAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuX2dldFRpdGxlKCkpO1xyXG4gICAgfVxyXG4gICAgX2dldFRpcEVsZW1lbnQoKSB7XHJcbiAgICAgIGlmICghdGhpcy50aXApIHtcclxuICAgICAgICB0aGlzLnRpcCA9IHRoaXMuX2NyZWF0ZVRpcEVsZW1lbnQodGhpcy5fbmV3Q29udGVudCB8fCB0aGlzLl9nZXRDb250ZW50Rm9yVGVtcGxhdGUoKSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMudGlwO1xyXG4gICAgfVxyXG4gICAgX2NyZWF0ZVRpcEVsZW1lbnQoY29udGVudCkge1xyXG4gICAgICBjb25zdCB0aXAgPSB0aGlzLl9nZXRUZW1wbGF0ZUZhY3RvcnkoY29udGVudCkudG9IdG1sKCk7XHJcblxyXG4gICAgICAvLyBUT0RPOiByZW1vdmUgdGhpcyBjaGVjayBpbiB2NlxyXG4gICAgICBpZiAoIXRpcCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIHRpcC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfRkFERSQyLCBDTEFTU19OQU1FX1NIT1ckMik7XHJcbiAgICAgIC8vIFRPRE86IHY2IHRoZSBmb2xsb3dpbmcgY2FuIGJlIGFjaGlldmVkIHdpdGggQ1NTIG9ubHlcclxuICAgICAgdGlwLmNsYXNzTGlzdC5hZGQoYGJzLSR7dGhpcy5jb25zdHJ1Y3Rvci5OQU1FfS1hdXRvYCk7XHJcbiAgICAgIGNvbnN0IHRpcElkID0gZ2V0VUlEKHRoaXMuY29uc3RydWN0b3IuTkFNRSkudG9TdHJpbmcoKTtcclxuICAgICAgdGlwLnNldEF0dHJpYnV0ZSgnaWQnLCB0aXBJZCk7XHJcbiAgICAgIGlmICh0aGlzLl9pc0FuaW1hdGVkKCkpIHtcclxuICAgICAgICB0aXAuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0ZBREUkMik7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRpcDtcclxuICAgIH1cclxuICAgIHNldENvbnRlbnQoY29udGVudCkge1xyXG4gICAgICB0aGlzLl9uZXdDb250ZW50ID0gY29udGVudDtcclxuICAgICAgaWYgKHRoaXMuX2lzU2hvd24oKSkge1xyXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VQb3BwZXIoKTtcclxuICAgICAgICB0aGlzLnNob3coKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2dldFRlbXBsYXRlRmFjdG9yeShjb250ZW50KSB7XHJcbiAgICAgIGlmICh0aGlzLl90ZW1wbGF0ZUZhY3RvcnkpIHtcclxuICAgICAgICB0aGlzLl90ZW1wbGF0ZUZhY3RvcnkuY2hhbmdlQ29udGVudChjb250ZW50KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl90ZW1wbGF0ZUZhY3RvcnkgPSBuZXcgVGVtcGxhdGVGYWN0b3J5KHtcclxuICAgICAgICAgIC4uLnRoaXMuX2NvbmZpZyxcclxuICAgICAgICAgIC8vIHRoZSBgY29udGVudGAgdmFyIGhhcyB0byBiZSBhZnRlciBgdGhpcy5fY29uZmlnYFxyXG4gICAgICAgICAgLy8gdG8gb3ZlcnJpZGUgY29uZmlnLmNvbnRlbnQgaW4gY2FzZSBvZiBwb3BvdmVyXHJcbiAgICAgICAgICBjb250ZW50LFxyXG4gICAgICAgICAgZXh0cmFDbGFzczogdGhpcy5fcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24odGhpcy5fY29uZmlnLmN1c3RvbUNsYXNzKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLl90ZW1wbGF0ZUZhY3Rvcnk7XHJcbiAgICB9XHJcbiAgICBfZ2V0Q29udGVudEZvclRlbXBsYXRlKCkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIFtTRUxFQ1RPUl9UT09MVElQX0lOTkVSXTogdGhpcy5fZ2V0VGl0bGUoKVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgX2dldFRpdGxlKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24odGhpcy5fY29uZmlnLnRpdGxlKSB8fCB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1icy1vcmlnaW5hbC10aXRsZScpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFByaXZhdGVcclxuICAgIF9pbml0aWFsaXplT25EZWxlZ2F0ZWRUYXJnZXQoZXZlbnQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuZ2V0T3JDcmVhdGVJbnN0YW5jZShldmVudC5kZWxlZ2F0ZVRhcmdldCwgdGhpcy5fZ2V0RGVsZWdhdGVDb25maWcoKSk7XHJcbiAgICB9XHJcbiAgICBfaXNBbmltYXRlZCgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5hbmltYXRpb24gfHwgdGhpcy50aXAgJiYgdGhpcy50aXAuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRkFERSQyKTtcclxuICAgIH1cclxuICAgIF9pc1Nob3duKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy50aXAgJiYgdGhpcy50aXAuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0hPVyQyKTtcclxuICAgIH1cclxuICAgIF9jcmVhdGVQb3BwZXIodGlwKSB7XHJcbiAgICAgIGNvbnN0IHBsYWNlbWVudCA9IGV4ZWN1dGUodGhpcy5fY29uZmlnLnBsYWNlbWVudCwgW3RoaXMsIHRpcCwgdGhpcy5fZWxlbWVudF0pO1xyXG4gICAgICBjb25zdCBhdHRhY2htZW50ID0gQXR0YWNobWVudE1hcFtwbGFjZW1lbnQudG9VcHBlckNhc2UoKV07XHJcbiAgICAgIHJldHVybiBjcmVhdGVQb3BwZXIodGhpcy5fZWxlbWVudCwgdGlwLCB0aGlzLl9nZXRQb3BwZXJDb25maWcoYXR0YWNobWVudCkpO1xyXG4gICAgfVxyXG4gICAgX2dldE9mZnNldCgpIHtcclxuICAgICAgY29uc3Qge1xyXG4gICAgICAgIG9mZnNldFxyXG4gICAgICB9ID0gdGhpcy5fY29uZmlnO1xyXG4gICAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gb2Zmc2V0LnNwbGl0KCcsJykubWFwKHZhbHVlID0+IE51bWJlci5wYXJzZUludCh2YWx1ZSwgMTApKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHJldHVybiBwb3BwZXJEYXRhID0+IG9mZnNldChwb3BwZXJEYXRhLCB0aGlzLl9lbGVtZW50KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gb2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKGFyZykge1xyXG4gICAgICByZXR1cm4gZXhlY3V0ZShhcmcsIFt0aGlzLl9lbGVtZW50XSk7XHJcbiAgICB9XHJcbiAgICBfZ2V0UG9wcGVyQ29uZmlnKGF0dGFjaG1lbnQpIHtcclxuICAgICAgY29uc3QgZGVmYXVsdEJzUG9wcGVyQ29uZmlnID0ge1xyXG4gICAgICAgIHBsYWNlbWVudDogYXR0YWNobWVudCxcclxuICAgICAgICBtb2RpZmllcnM6IFt7XHJcbiAgICAgICAgICBuYW1lOiAnZmxpcCcsXHJcbiAgICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgIGZhbGxiYWNrUGxhY2VtZW50czogdGhpcy5fY29uZmlnLmZhbGxiYWNrUGxhY2VtZW50c1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sIHtcclxuICAgICAgICAgIG5hbWU6ICdvZmZzZXQnLFxyXG4gICAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICBvZmZzZXQ6IHRoaXMuX2dldE9mZnNldCgpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSwge1xyXG4gICAgICAgICAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXHJcbiAgICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgIGJvdW5kYXJ5OiB0aGlzLl9jb25maWcuYm91bmRhcnlcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LCB7XHJcbiAgICAgICAgICBuYW1lOiAnYXJyb3cnLFxyXG4gICAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICBlbGVtZW50OiBgLiR7dGhpcy5jb25zdHJ1Y3Rvci5OQU1FfS1hcnJvd2BcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LCB7XHJcbiAgICAgICAgICBuYW1lOiAncHJlU2V0UGxhY2VtZW50JyxcclxuICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXHJcbiAgICAgICAgICBwaGFzZTogJ2JlZm9yZU1haW4nLFxyXG4gICAgICAgICAgZm46IGRhdGEgPT4ge1xyXG4gICAgICAgICAgICAvLyBQcmUtc2V0IFBvcHBlcidzIHBsYWNlbWVudCBhdHRyaWJ1dGUgaW4gb3JkZXIgdG8gcmVhZCB0aGUgYXJyb3cgc2l6ZXMgcHJvcGVybHkuXHJcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgUG9wcGVyIG1peGVzIHVwIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IGRpbWVuc2lvbnMgc2luY2UgdGhlIGluaXRpYWwgYXJyb3cgc3R5bGUgaXMgZm9yIHRvcCBwbGFjZW1lbnRcclxuICAgICAgICAgICAgdGhpcy5fZ2V0VGlwRWxlbWVudCgpLnNldEF0dHJpYnV0ZSgnZGF0YS1wb3BwZXItcGxhY2VtZW50JywgZGF0YS5zdGF0ZS5wbGFjZW1lbnQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1dXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgLi4uZGVmYXVsdEJzUG9wcGVyQ29uZmlnLFxyXG4gICAgICAgIC4uLmV4ZWN1dGUodGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZywgW2RlZmF1bHRCc1BvcHBlckNvbmZpZ10pXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBfc2V0TGlzdGVuZXJzKCkge1xyXG4gICAgICBjb25zdCB0cmlnZ2VycyA9IHRoaXMuX2NvbmZpZy50cmlnZ2VyLnNwbGl0KCcgJyk7XHJcbiAgICAgIGZvciAoY29uc3QgdHJpZ2dlciBvZiB0cmlnZ2Vycykge1xyXG4gICAgICAgIGlmICh0cmlnZ2VyID09PSAnY2xpY2snKSB7XHJcbiAgICAgICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfQ0xJQ0skMSksIHRoaXMuX2NvbmZpZy5zZWxlY3RvciwgZXZlbnQgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5faW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KGV2ZW50KTtcclxuICAgICAgICAgICAgY29udGV4dC50b2dnbGUoKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHJpZ2dlciAhPT0gVFJJR0dFUl9NQU5VQUwpIHtcclxuICAgICAgICAgIGNvbnN0IGV2ZW50SW4gPSB0cmlnZ2VyID09PSBUUklHR0VSX0hPVkVSID8gdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfTU9VU0VFTlRFUikgOiB0aGlzLmNvbnN0cnVjdG9yLmV2ZW50TmFtZShFVkVOVF9GT0NVU0lOJDEpO1xyXG4gICAgICAgICAgY29uc3QgZXZlbnRPdXQgPSB0cmlnZ2VyID09PSBUUklHR0VSX0hPVkVSID8gdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfTU9VU0VMRUFWRSkgOiB0aGlzLmNvbnN0cnVjdG9yLmV2ZW50TmFtZShFVkVOVF9GT0NVU09VVCQxKTtcclxuICAgICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBldmVudEluLCB0aGlzLl9jb25maWcuc2VsZWN0b3IsIGV2ZW50ID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldChldmVudCk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuX2FjdGl2ZVRyaWdnZXJbZXZlbnQudHlwZSA9PT0gJ2ZvY3VzaW4nID8gVFJJR0dFUl9GT0NVUyA6IFRSSUdHRVJfSE9WRVJdID0gdHJ1ZTtcclxuICAgICAgICAgICAgY29udGV4dC5fZW50ZXIoKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIGV2ZW50T3V0LCB0aGlzLl9jb25maWcuc2VsZWN0b3IsIGV2ZW50ID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldChldmVudCk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuX2FjdGl2ZVRyaWdnZXJbZXZlbnQudHlwZSA9PT0gJ2ZvY3Vzb3V0JyA/IFRSSUdHRVJfRk9DVVMgOiBUUklHR0VSX0hPVkVSXSA9IGNvbnRleHQuX2VsZW1lbnQuY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuX2xlYXZlKCk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5faGlkZU1vZGFsSGFuZGxlciA9ICgpID0+IHtcclxuICAgICAgICBpZiAodGhpcy5fZWxlbWVudCkge1xyXG4gICAgICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudC5jbG9zZXN0KFNFTEVDVE9SX01PREFMKSwgRVZFTlRfTU9EQUxfSElERSwgdGhpcy5faGlkZU1vZGFsSGFuZGxlcik7XHJcbiAgICB9XHJcbiAgICBfZml4VGl0bGUoKSB7XHJcbiAgICAgIGNvbnN0IHRpdGxlID0gdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RpdGxlJyk7XHJcbiAgICAgIGlmICghdGl0bGUpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCF0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcpICYmICF0aGlzLl9lbGVtZW50LnRleHRDb250ZW50LnRyaW0oKSkge1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgdGl0bGUpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLWJzLW9yaWdpbmFsLXRpdGxlJywgdGl0bGUpOyAvLyBETyBOT1QgVVNFIElULiBJcyBvbmx5IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxyXG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgndGl0bGUnKTtcclxuICAgIH1cclxuICAgIF9lbnRlcigpIHtcclxuICAgICAgaWYgKHRoaXMuX2lzU2hvd24oKSB8fCB0aGlzLl9pc0hvdmVyZWQpIHtcclxuICAgICAgICB0aGlzLl9pc0hvdmVyZWQgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9pc0hvdmVyZWQgPSB0cnVlO1xyXG4gICAgICB0aGlzLl9zZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBpZiAodGhpcy5faXNIb3ZlcmVkKSB7XHJcbiAgICAgICAgICB0aGlzLnNob3coKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sIHRoaXMuX2NvbmZpZy5kZWxheS5zaG93KTtcclxuICAgIH1cclxuICAgIF9sZWF2ZSgpIHtcclxuICAgICAgaWYgKHRoaXMuX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9pc0hvdmVyZWQgPSBmYWxzZTtcclxuICAgICAgdGhpcy5fc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pc0hvdmVyZWQpIHtcclxuICAgICAgICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSwgdGhpcy5fY29uZmlnLmRlbGF5LmhpZGUpO1xyXG4gICAgfVxyXG4gICAgX3NldFRpbWVvdXQoaGFuZGxlciwgdGltZW91dCkge1xyXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XHJcbiAgICAgIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGhhbmRsZXIsIHRpbWVvdXQpO1xyXG4gICAgfVxyXG4gICAgX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSB7XHJcbiAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuX2FjdGl2ZVRyaWdnZXIpLmluY2x1ZGVzKHRydWUpO1xyXG4gICAgfVxyXG4gICAgX2dldENvbmZpZyhjb25maWcpIHtcclxuICAgICAgY29uc3QgZGF0YUF0dHJpYnV0ZXMgPSBNYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcclxuICAgICAgZm9yIChjb25zdCBkYXRhQXR0cmlidXRlIG9mIE9iamVjdC5rZXlzKGRhdGFBdHRyaWJ1dGVzKSkge1xyXG4gICAgICAgIGlmIChESVNBTExPV0VEX0FUVFJJQlVURVMuaGFzKGRhdGFBdHRyaWJ1dGUpKSB7XHJcbiAgICAgICAgICBkZWxldGUgZGF0YUF0dHJpYnV0ZXNbZGF0YUF0dHJpYnV0ZV07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGNvbmZpZyA9IHtcclxuICAgICAgICAuLi5kYXRhQXR0cmlidXRlcyxcclxuICAgICAgICAuLi4odHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgJiYgY29uZmlnID8gY29uZmlnIDoge30pXHJcbiAgICAgIH07XHJcbiAgICAgIGNvbmZpZyA9IHRoaXMuX21lcmdlQ29uZmlnT2JqKGNvbmZpZyk7XHJcbiAgICAgIGNvbmZpZyA9IHRoaXMuX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKTtcclxuICAgICAgdGhpcy5fdHlwZUNoZWNrQ29uZmlnKGNvbmZpZyk7XHJcbiAgICAgIHJldHVybiBjb25maWc7XHJcbiAgICB9XHJcbiAgICBfY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpIHtcclxuICAgICAgY29uZmlnLmNvbnRhaW5lciA9IGNvbmZpZy5jb250YWluZXIgPT09IGZhbHNlID8gZG9jdW1lbnQuYm9keSA6IGdldEVsZW1lbnQoY29uZmlnLmNvbnRhaW5lcik7XHJcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnLmRlbGF5ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIGNvbmZpZy5kZWxheSA9IHtcclxuICAgICAgICAgIHNob3c6IGNvbmZpZy5kZWxheSxcclxuICAgICAgICAgIGhpZGU6IGNvbmZpZy5kZWxheVxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHR5cGVvZiBjb25maWcudGl0bGUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgY29uZmlnLnRpdGxlID0gY29uZmlnLnRpdGxlLnRvU3RyaW5nKCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHR5cGVvZiBjb25maWcuY29udGVudCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICBjb25maWcuY29udGVudCA9IGNvbmZpZy5jb250ZW50LnRvU3RyaW5nKCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGNvbmZpZztcclxuICAgIH1cclxuICAgIF9nZXREZWxlZ2F0ZUNvbmZpZygpIHtcclxuICAgICAgY29uc3QgY29uZmlnID0ge307XHJcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuX2NvbmZpZykpIHtcclxuICAgICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0W2tleV0gIT09IHZhbHVlKSB7XHJcbiAgICAgICAgICBjb25maWdba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBjb25maWcuc2VsZWN0b3IgPSBmYWxzZTtcclxuICAgICAgY29uZmlnLnRyaWdnZXIgPSAnbWFudWFsJztcclxuXHJcbiAgICAgIC8vIEluIHRoZSBmdXR1cmUgY2FuIGJlIHJlcGxhY2VkIHdpdGg6XHJcbiAgICAgIC8vIGNvbnN0IGtleXNXaXRoRGlmZmVyZW50VmFsdWVzID0gT2JqZWN0LmVudHJpZXModGhpcy5fY29uZmlnKS5maWx0ZXIoZW50cnkgPT4gdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0W2VudHJ5WzBdXSAhPT0gdGhpcy5fY29uZmlnW2VudHJ5WzBdXSlcclxuICAgICAgLy8gYE9iamVjdC5mcm9tRW50cmllcyhrZXlzV2l0aERpZmZlcmVudFZhbHVlcylgXHJcbiAgICAgIHJldHVybiBjb25maWc7XHJcbiAgICB9XHJcbiAgICBfZGlzcG9zZVBvcHBlcigpIHtcclxuICAgICAgaWYgKHRoaXMuX3BvcHBlcikge1xyXG4gICAgICAgIHRoaXMuX3BvcHBlci5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5fcG9wcGVyID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy50aXApIHtcclxuICAgICAgICB0aGlzLnRpcC5yZW1vdmUoKTtcclxuICAgICAgICB0aGlzLnRpcCA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBTdGF0aWNcclxuICAgIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBUb29sdGlwLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcclxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkYXRhW2NvbmZpZ10oKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBqUXVlcnlcclxuICAgKi9cclxuXHJcbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luKFRvb2x0aXApO1xyXG5cclxuICAvKipcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqIEJvb3RzdHJhcCBwb3BvdmVyLmpzXHJcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKi9cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0YW50c1xyXG4gICAqL1xyXG5cclxuICBjb25zdCBOQU1FJDMgPSAncG9wb3Zlcic7XHJcbiAgY29uc3QgU0VMRUNUT1JfVElUTEUgPSAnLnBvcG92ZXItaGVhZGVyJztcclxuICBjb25zdCBTRUxFQ1RPUl9DT05URU5UID0gJy5wb3BvdmVyLWJvZHknO1xyXG4gIGNvbnN0IERlZmF1bHQkMiA9IHtcclxuICAgIC4uLlRvb2x0aXAuRGVmYXVsdCxcclxuICAgIGNvbnRlbnQ6ICcnLFxyXG4gICAgb2Zmc2V0OiBbMCwgOF0sXHJcbiAgICBwbGFjZW1lbnQ6ICdyaWdodCcsXHJcbiAgICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJwb3BvdmVyXCIgcm9sZT1cInRvb2x0aXBcIj4nICsgJzxkaXYgY2xhc3M9XCJwb3BvdmVyLWFycm93XCI+PC9kaXY+JyArICc8aDMgY2xhc3M9XCJwb3BvdmVyLWhlYWRlclwiPjwvaDM+JyArICc8ZGl2IGNsYXNzPVwicG9wb3Zlci1ib2R5XCI+PC9kaXY+JyArICc8L2Rpdj4nLFxyXG4gICAgdHJpZ2dlcjogJ2NsaWNrJ1xyXG4gIH07XHJcbiAgY29uc3QgRGVmYXVsdFR5cGUkMiA9IHtcclxuICAgIC4uLlRvb2x0aXAuRGVmYXVsdFR5cGUsXHJcbiAgICBjb250ZW50OiAnKG51bGx8c3RyaW5nfGVsZW1lbnR8ZnVuY3Rpb24pJ1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENsYXNzIGRlZmluaXRpb25cclxuICAgKi9cclxuXHJcbiAgY2xhc3MgUG9wb3ZlciBleHRlbmRzIFRvb2x0aXAge1xyXG4gICAgLy8gR2V0dGVyc1xyXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xyXG4gICAgICByZXR1cm4gRGVmYXVsdCQyO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcclxuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJDI7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XHJcbiAgICAgIHJldHVybiBOQU1FJDM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gT3ZlcnJpZGVzXHJcbiAgICBfaXNXaXRoQ29udGVudCgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2dldFRpdGxlKCkgfHwgdGhpcy5fZ2V0Q29udGVudCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFByaXZhdGVcclxuICAgIF9nZXRDb250ZW50Rm9yVGVtcGxhdGUoKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgW1NFTEVDVE9SX1RJVExFXTogdGhpcy5fZ2V0VGl0bGUoKSxcclxuICAgICAgICBbU0VMRUNUT1JfQ09OVEVOVF06IHRoaXMuX2dldENvbnRlbnQoKVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgX2dldENvbnRlbnQoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbih0aGlzLl9jb25maWcuY29udGVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU3RhdGljXHJcbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xyXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCBkYXRhID0gUG9wb3Zlci5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGNvbmZpZyk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGF0YVtjb25maWddKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogalF1ZXJ5XHJcbiAgICovXHJcblxyXG4gIGRlZmluZUpRdWVyeVBsdWdpbihQb3BvdmVyKTtcclxuXHJcbiAgLyoqXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKiBCb290c3RyYXAgc2Nyb2xsc3B5LmpzXHJcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKi9cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0YW50c1xyXG4gICAqL1xyXG5cclxuICBjb25zdCBOQU1FJDIgPSAnc2Nyb2xsc3B5JztcclxuICBjb25zdCBEQVRBX0tFWSQyID0gJ2JzLnNjcm9sbHNweSc7XHJcbiAgY29uc3QgRVZFTlRfS0VZJDIgPSBgLiR7REFUQV9LRVkkMn1gO1xyXG4gIGNvbnN0IERBVEFfQVBJX0tFWSA9ICcuZGF0YS1hcGknO1xyXG4gIGNvbnN0IEVWRU5UX0FDVElWQVRFID0gYGFjdGl2YXRlJHtFVkVOVF9LRVkkMn1gO1xyXG4gIGNvbnN0IEVWRU5UX0NMSUNLID0gYGNsaWNrJHtFVkVOVF9LRVkkMn1gO1xyXG4gIGNvbnN0IEVWRU5UX0xPQURfREFUQV9BUEkkMSA9IGBsb2FkJHtFVkVOVF9LRVkkMn0ke0RBVEFfQVBJX0tFWX1gO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfRFJPUERPV05fSVRFTSA9ICdkcm9wZG93bi1pdGVtJztcclxuICBjb25zdCBDTEFTU19OQU1FX0FDVElWRSQxID0gJ2FjdGl2ZSc7XHJcbiAgY29uc3QgU0VMRUNUT1JfREFUQV9TUFkgPSAnW2RhdGEtYnMtc3B5PVwic2Nyb2xsXCJdJztcclxuICBjb25zdCBTRUxFQ1RPUl9UQVJHRVRfTElOS1MgPSAnW2hyZWZdJztcclxuICBjb25zdCBTRUxFQ1RPUl9OQVZfTElTVF9HUk9VUCA9ICcubmF2LCAubGlzdC1ncm91cCc7XHJcbiAgY29uc3QgU0VMRUNUT1JfTkFWX0xJTktTID0gJy5uYXYtbGluayc7XHJcbiAgY29uc3QgU0VMRUNUT1JfTkFWX0lURU1TID0gJy5uYXYtaXRlbSc7XHJcbiAgY29uc3QgU0VMRUNUT1JfTElTVF9JVEVNUyA9ICcubGlzdC1ncm91cC1pdGVtJztcclxuICBjb25zdCBTRUxFQ1RPUl9MSU5LX0lURU1TID0gYCR7U0VMRUNUT1JfTkFWX0xJTktTfSwgJHtTRUxFQ1RPUl9OQVZfSVRFTVN9ID4gJHtTRUxFQ1RPUl9OQVZfTElOS1N9LCAke1NFTEVDVE9SX0xJU1RfSVRFTVN9YDtcclxuICBjb25zdCBTRUxFQ1RPUl9EUk9QRE9XTiA9ICcuZHJvcGRvd24nO1xyXG4gIGNvbnN0IFNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSQxID0gJy5kcm9wZG93bi10b2dnbGUnO1xyXG4gIGNvbnN0IERlZmF1bHQkMSA9IHtcclxuICAgIG9mZnNldDogbnVsbCxcclxuICAgIC8vIFRPRE86IHY2IEBkZXByZWNhdGVkLCBrZWVwIGl0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSByZWFzb25zXHJcbiAgICByb290TWFyZ2luOiAnMHB4IDBweCAtMjUlJyxcclxuICAgIHNtb290aFNjcm9sbDogZmFsc2UsXHJcbiAgICB0YXJnZXQ6IG51bGwsXHJcbiAgICB0aHJlc2hvbGQ6IFswLjEsIDAuNSwgMV1cclxuICB9O1xyXG4gIGNvbnN0IERlZmF1bHRUeXBlJDEgPSB7XHJcbiAgICBvZmZzZXQ6ICcobnVtYmVyfG51bGwpJyxcclxuICAgIC8vIFRPRE8gdjYgQGRlcHJlY2F0ZWQsIGtlZXAgaXQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHJlYXNvbnNcclxuICAgIHJvb3RNYXJnaW46ICdzdHJpbmcnLFxyXG4gICAgc21vb3RoU2Nyb2xsOiAnYm9vbGVhbicsXHJcbiAgICB0YXJnZXQ6ICdlbGVtZW50JyxcclxuICAgIHRocmVzaG9sZDogJ2FycmF5J1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENsYXNzIGRlZmluaXRpb25cclxuICAgKi9cclxuXHJcbiAgY2xhc3MgU2Nyb2xsU3B5IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcclxuICAgICAgc3VwZXIoZWxlbWVudCwgY29uZmlnKTtcclxuXHJcbiAgICAgIC8vIHRoaXMuX2VsZW1lbnQgaXMgdGhlIG9ic2VydmFibGVzQ29udGFpbmVyIGFuZCBjb25maWcudGFyZ2V0IHRoZSBtZW51IGxpbmtzIHdyYXBwZXJcclxuICAgICAgdGhpcy5fdGFyZ2V0TGlua3MgPSBuZXcgTWFwKCk7XHJcbiAgICAgIHRoaXMuX29ic2VydmFibGVTZWN0aW9ucyA9IG5ldyBNYXAoKTtcclxuICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuX2VsZW1lbnQpLm92ZXJmbG93WSA9PT0gJ3Zpc2libGUnID8gbnVsbCA6IHRoaXMuX2VsZW1lbnQ7XHJcbiAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IG51bGw7XHJcbiAgICAgIHRoaXMuX29ic2VydmVyID0gbnVsbDtcclxuICAgICAgdGhpcy5fcHJldmlvdXNTY3JvbGxEYXRhID0ge1xyXG4gICAgICAgIHZpc2libGVFbnRyeVRvcDogMCxcclxuICAgICAgICBwYXJlbnRTY3JvbGxUb3A6IDBcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5yZWZyZXNoKCk7IC8vIGluaXRpYWxpemVcclxuICAgIH1cclxuXHJcbiAgICAvLyBHZXR0ZXJzXHJcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XHJcbiAgICAgIHJldHVybiBEZWZhdWx0JDE7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xyXG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGUkMTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcclxuICAgICAgcmV0dXJuIE5BTUUkMjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQdWJsaWNcclxuICAgIHJlZnJlc2goKSB7XHJcbiAgICAgIHRoaXMuX2luaXRpYWxpemVUYXJnZXRzQW5kT2JzZXJ2YWJsZXMoKTtcclxuICAgICAgdGhpcy5fbWF5YmVFbmFibGVTbW9vdGhTY3JvbGwoKTtcclxuICAgICAgaWYgKHRoaXMuX29ic2VydmVyKSB7XHJcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuX29ic2VydmVyID0gdGhpcy5fZ2V0TmV3T2JzZXJ2ZXIoKTtcclxuICAgICAgfVxyXG4gICAgICBmb3IgKGNvbnN0IHNlY3Rpb24gb2YgdGhpcy5fb2JzZXJ2YWJsZVNlY3Rpb25zLnZhbHVlcygpKSB7XHJcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZShzZWN0aW9uKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xyXG4gICAgICBzdXBlci5kaXNwb3NlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHJpdmF0ZVxyXG4gICAgX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKSB7XHJcbiAgICAgIC8vIFRPRE86IG9uIHY2IHRhcmdldCBzaG91bGQgYmUgZ2l2ZW4gZXhwbGljaXRseSAmIHJlbW92ZSB0aGUge3RhcmdldDogJ3NzLXRhcmdldCd9IGNhc2VcclxuICAgICAgY29uZmlnLnRhcmdldCA9IGdldEVsZW1lbnQoY29uZmlnLnRhcmdldCkgfHwgZG9jdW1lbnQuYm9keTtcclxuXHJcbiAgICAgIC8vIFRPRE86IHY2IE9ubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHJlYXNvbnMuIFVzZSByb290TWFyZ2luIG9ubHlcclxuICAgICAgY29uZmlnLnJvb3RNYXJnaW4gPSBjb25maWcub2Zmc2V0ID8gYCR7Y29uZmlnLm9mZnNldH1weCAwcHggLTMwJWAgOiBjb25maWcucm9vdE1hcmdpbjtcclxuICAgICAgaWYgKHR5cGVvZiBjb25maWcudGhyZXNob2xkID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGNvbmZpZy50aHJlc2hvbGQgPSBjb25maWcudGhyZXNob2xkLnNwbGl0KCcsJykubWFwKHZhbHVlID0+IE51bWJlci5wYXJzZUZsb2F0KHZhbHVlKSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGNvbmZpZztcclxuICAgIH1cclxuICAgIF9tYXliZUVuYWJsZVNtb290aFNjcm9sbCgpIHtcclxuICAgICAgaWYgKCF0aGlzLl9jb25maWcuc21vb3RoU2Nyb2xsKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB1bnJlZ2lzdGVyIGFueSBwcmV2aW91cyBsaXN0ZW5lcnNcclxuICAgICAgRXZlbnRIYW5kbGVyLm9mZih0aGlzLl9jb25maWcudGFyZ2V0LCBFVkVOVF9DTElDSyk7XHJcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9jb25maWcudGFyZ2V0LCBFVkVOVF9DTElDSywgU0VMRUNUT1JfVEFSR0VUX0xJTktTLCBldmVudCA9PiB7XHJcbiAgICAgICAgY29uc3Qgb2JzZXJ2YWJsZVNlY3Rpb24gPSB0aGlzLl9vYnNlcnZhYmxlU2VjdGlvbnMuZ2V0KGV2ZW50LnRhcmdldC5oYXNoKTtcclxuICAgICAgICBpZiAob2JzZXJ2YWJsZVNlY3Rpb24pIHtcclxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICBjb25zdCByb290ID0gdGhpcy5fcm9vdEVsZW1lbnQgfHwgd2luZG93O1xyXG4gICAgICAgICAgY29uc3QgaGVpZ2h0ID0gb2JzZXJ2YWJsZVNlY3Rpb24ub2Zmc2V0VG9wIC0gdGhpcy5fZWxlbWVudC5vZmZzZXRUb3A7XHJcbiAgICAgICAgICBpZiAocm9vdC5zY3JvbGxUbykge1xyXG4gICAgICAgICAgICByb290LnNjcm9sbFRvKHtcclxuICAgICAgICAgICAgICB0b3A6IGhlaWdodCxcclxuICAgICAgICAgICAgICBiZWhhdmlvcjogJ3Ntb290aCdcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBDaHJvbWUgNjAgZG9lc24ndCBzdXBwb3J0IGBzY3JvbGxUb2BcclxuICAgICAgICAgIHJvb3Quc2Nyb2xsVG9wID0gaGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfZ2V0TmV3T2JzZXJ2ZXIoKSB7XHJcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgcm9vdDogdGhpcy5fcm9vdEVsZW1lbnQsXHJcbiAgICAgICAgdGhyZXNob2xkOiB0aGlzLl9jb25maWcudGhyZXNob2xkLFxyXG4gICAgICAgIHJvb3RNYXJnaW46IHRoaXMuX2NvbmZpZy5yb290TWFyZ2luXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB0aGlzLl9vYnNlcnZlckNhbGxiYWNrKGVudHJpZXMpLCBvcHRpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGUgbG9naWMgb2Ygc2VsZWN0aW9uXHJcbiAgICBfb2JzZXJ2ZXJDYWxsYmFjayhlbnRyaWVzKSB7XHJcbiAgICAgIGNvbnN0IHRhcmdldEVsZW1lbnQgPSBlbnRyeSA9PiB0aGlzLl90YXJnZXRMaW5rcy5nZXQoYCMke2VudHJ5LnRhcmdldC5pZH1gKTtcclxuICAgICAgY29uc3QgYWN0aXZhdGUgPSBlbnRyeSA9PiB7XHJcbiAgICAgICAgdGhpcy5fcHJldmlvdXNTY3JvbGxEYXRhLnZpc2libGVFbnRyeVRvcCA9IGVudHJ5LnRhcmdldC5vZmZzZXRUb3A7XHJcbiAgICAgICAgdGhpcy5fcHJvY2Vzcyh0YXJnZXRFbGVtZW50KGVudHJ5KSk7XHJcbiAgICAgIH07XHJcbiAgICAgIGNvbnN0IHBhcmVudFNjcm9sbFRvcCA9ICh0aGlzLl9yb290RWxlbWVudCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLnNjcm9sbFRvcDtcclxuICAgICAgY29uc3QgdXNlclNjcm9sbHNEb3duID0gcGFyZW50U2Nyb2xsVG9wID49IHRoaXMuX3ByZXZpb3VzU2Nyb2xsRGF0YS5wYXJlbnRTY3JvbGxUb3A7XHJcbiAgICAgIHRoaXMuX3ByZXZpb3VzU2Nyb2xsRGF0YS5wYXJlbnRTY3JvbGxUb3AgPSBwYXJlbnRTY3JvbGxUb3A7XHJcbiAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xyXG4gICAgICAgIGlmICghZW50cnkuaXNJbnRlcnNlY3RpbmcpIHtcclxuICAgICAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IG51bGw7XHJcbiAgICAgICAgICB0aGlzLl9jbGVhckFjdGl2ZUNsYXNzKHRhcmdldEVsZW1lbnQoZW50cnkpKTtcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBlbnRyeUlzTG93ZXJUaGFuUHJldmlvdXMgPSBlbnRyeS50YXJnZXQub2Zmc2V0VG9wID49IHRoaXMuX3ByZXZpb3VzU2Nyb2xsRGF0YS52aXNpYmxlRW50cnlUb3A7XHJcbiAgICAgICAgLy8gaWYgd2UgYXJlIHNjcm9sbGluZyBkb3duLCBwaWNrIHRoZSBiaWdnZXIgb2Zmc2V0VG9wXHJcbiAgICAgICAgaWYgKHVzZXJTY3JvbGxzRG93biAmJiBlbnRyeUlzTG93ZXJUaGFuUHJldmlvdXMpIHtcclxuICAgICAgICAgIGFjdGl2YXRlKGVudHJ5KTtcclxuICAgICAgICAgIC8vIGlmIHBhcmVudCBpc24ndCBzY3JvbGxlZCwgbGV0J3Mga2VlcCB0aGUgZmlyc3QgdmlzaWJsZSBpdGVtLCBicmVha2luZyB0aGUgaXRlcmF0aW9uXHJcbiAgICAgICAgICBpZiAoIXBhcmVudFNjcm9sbFRvcCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGlmIHdlIGFyZSBzY3JvbGxpbmcgdXAsIHBpY2sgdGhlIHNtYWxsZXN0IG9mZnNldFRvcFxyXG4gICAgICAgIGlmICghdXNlclNjcm9sbHNEb3duICYmICFlbnRyeUlzTG93ZXJUaGFuUHJldmlvdXMpIHtcclxuICAgICAgICAgIGFjdGl2YXRlKGVudHJ5KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIF9pbml0aWFsaXplVGFyZ2V0c0FuZE9ic2VydmFibGVzKCkge1xyXG4gICAgICB0aGlzLl90YXJnZXRMaW5rcyA9IG5ldyBNYXAoKTtcclxuICAgICAgdGhpcy5fb2JzZXJ2YWJsZVNlY3Rpb25zID0gbmV3IE1hcCgpO1xyXG4gICAgICBjb25zdCB0YXJnZXRMaW5rcyA9IFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfVEFSR0VUX0xJTktTLCB0aGlzLl9jb25maWcudGFyZ2V0KTtcclxuICAgICAgZm9yIChjb25zdCBhbmNob3Igb2YgdGFyZ2V0TGlua3MpIHtcclxuICAgICAgICAvLyBlbnN1cmUgdGhhdCB0aGUgYW5jaG9yIGhhcyBhbiBpZCBhbmQgaXMgbm90IGRpc2FibGVkXHJcbiAgICAgICAgaWYgKCFhbmNob3IuaGFzaCB8fCBpc0Rpc2FibGVkKGFuY2hvcikpIHtcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBvYnNlcnZhYmxlU2VjdGlvbiA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoZGVjb2RlVVJJKGFuY2hvci5oYXNoKSwgdGhpcy5fZWxlbWVudCk7XHJcblxyXG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IHRoZSBvYnNlcnZhYmxlU2VjdGlvbiBleGlzdHMgJiBpcyB2aXNpYmxlXHJcbiAgICAgICAgaWYgKGlzVmlzaWJsZShvYnNlcnZhYmxlU2VjdGlvbikpIHtcclxuICAgICAgICAgIHRoaXMuX3RhcmdldExpbmtzLnNldChkZWNvZGVVUkkoYW5jaG9yLmhhc2gpLCBhbmNob3IpO1xyXG4gICAgICAgICAgdGhpcy5fb2JzZXJ2YWJsZVNlY3Rpb25zLnNldChhbmNob3IuaGFzaCwgb2JzZXJ2YWJsZVNlY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3Byb2Nlc3ModGFyZ2V0KSB7XHJcbiAgICAgIGlmICh0aGlzLl9hY3RpdmVUYXJnZXQgPT09IHRhcmdldCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9jbGVhckFjdGl2ZUNsYXNzKHRoaXMuX2NvbmZpZy50YXJnZXQpO1xyXG4gICAgICB0aGlzLl9hY3RpdmVUYXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgIHRhcmdldC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFJDEpO1xyXG4gICAgICB0aGlzLl9hY3RpdmF0ZVBhcmVudHModGFyZ2V0KTtcclxuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfQUNUSVZBVEUsIHtcclxuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0YXJnZXRcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfYWN0aXZhdGVQYXJlbnRzKHRhcmdldCkge1xyXG4gICAgICAvLyBBY3RpdmF0ZSBkcm9wZG93biBwYXJlbnRzXHJcbiAgICAgIGlmICh0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRFJPUERPV05fSVRFTSkpIHtcclxuICAgICAgICBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSQxLCB0YXJnZXQuY2xvc2VzdChTRUxFQ1RPUl9EUk9QRE9XTikpLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUkMSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGZvciAoY29uc3QgbGlzdEdyb3VwIG9mIFNlbGVjdG9yRW5naW5lLnBhcmVudHModGFyZ2V0LCBTRUxFQ1RPUl9OQVZfTElTVF9HUk9VUCkpIHtcclxuICAgICAgICAvLyBTZXQgdHJpZ2dlcmVkIGxpbmtzIHBhcmVudHMgYXMgYWN0aXZlXHJcbiAgICAgICAgLy8gV2l0aCBib3RoIDx1bD4gYW5kIDxuYXY+IG1hcmt1cCBhIHBhcmVudCBpcyB0aGUgcHJldmlvdXMgc2libGluZyBvZiBhbnkgbmF2IGFuY2VzdG9yXHJcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIFNlbGVjdG9yRW5naW5lLnByZXYobGlzdEdyb3VwLCBTRUxFQ1RPUl9MSU5LX0lURU1TKSkge1xyXG4gICAgICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFJDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2NsZWFyQWN0aXZlQ2xhc3MocGFyZW50KSB7XHJcbiAgICAgIHBhcmVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFJDEpO1xyXG4gICAgICBjb25zdCBhY3RpdmVOb2RlcyA9IFNlbGVjdG9yRW5naW5lLmZpbmQoYCR7U0VMRUNUT1JfVEFSR0VUX0xJTktTfS4ke0NMQVNTX05BTUVfQUNUSVZFJDF9YCwgcGFyZW50KTtcclxuICAgICAgZm9yIChjb25zdCBub2RlIG9mIGFjdGl2ZU5vZGVzKSB7XHJcbiAgICAgICAgbm9kZS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFJDEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU3RhdGljXHJcbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xyXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCBkYXRhID0gU2Nyb2xsU3B5LmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcclxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRhdGFbY29uZmlnXSA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5zdGFydHNXaXRoKCdfJykgfHwgY29uZmlnID09PSAnY29uc3RydWN0b3InKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkYXRhW2NvbmZpZ10oKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxyXG4gICAqL1xyXG5cclxuICBFdmVudEhhbmRsZXIub24od2luZG93LCBFVkVOVF9MT0FEX0RBVEFfQVBJJDEsICgpID0+IHtcclxuICAgIGZvciAoY29uc3Qgc3B5IG9mIFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfREFUQV9TUFkpKSB7XHJcbiAgICAgIFNjcm9sbFNweS5nZXRPckNyZWF0ZUluc3RhbmNlKHNweSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIGpRdWVyeVxyXG4gICAqL1xyXG5cclxuICBkZWZpbmVKUXVlcnlQbHVnaW4oU2Nyb2xsU3B5KTtcclxuXHJcbiAgLyoqXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKiBCb290c3RyYXAgdGFiLmpzXHJcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKi9cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0YW50c1xyXG4gICAqL1xyXG5cclxuICBjb25zdCBOQU1FJDEgPSAndGFiJztcclxuICBjb25zdCBEQVRBX0tFWSQxID0gJ2JzLnRhYic7XHJcbiAgY29uc3QgRVZFTlRfS0VZJDEgPSBgLiR7REFUQV9LRVkkMX1gO1xyXG4gIGNvbnN0IEVWRU5UX0hJREUkMSA9IGBoaWRlJHtFVkVOVF9LRVkkMX1gO1xyXG4gIGNvbnN0IEVWRU5UX0hJRERFTiQxID0gYGhpZGRlbiR7RVZFTlRfS0VZJDF9YDtcclxuICBjb25zdCBFVkVOVF9TSE9XJDEgPSBgc2hvdyR7RVZFTlRfS0VZJDF9YDtcclxuICBjb25zdCBFVkVOVF9TSE9XTiQxID0gYHNob3duJHtFVkVOVF9LRVkkMX1gO1xyXG4gIGNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJID0gYGNsaWNrJHtFVkVOVF9LRVkkMX1gO1xyXG4gIGNvbnN0IEVWRU5UX0tFWURPV04gPSBga2V5ZG93biR7RVZFTlRfS0VZJDF9YDtcclxuICBjb25zdCBFVkVOVF9MT0FEX0RBVEFfQVBJID0gYGxvYWQke0VWRU5UX0tFWSQxfWA7XHJcbiAgY29uc3QgQVJST1dfTEVGVF9LRVkgPSAnQXJyb3dMZWZ0JztcclxuICBjb25zdCBBUlJPV19SSUdIVF9LRVkgPSAnQXJyb3dSaWdodCc7XHJcbiAgY29uc3QgQVJST1dfVVBfS0VZID0gJ0Fycm93VXAnO1xyXG4gIGNvbnN0IEFSUk9XX0RPV05fS0VZID0gJ0Fycm93RG93bic7XHJcbiAgY29uc3QgSE9NRV9LRVkgPSAnSG9tZSc7XHJcbiAgY29uc3QgRU5EX0tFWSA9ICdFbmQnO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfQUNUSVZFID0gJ2FjdGl2ZSc7XHJcbiAgY29uc3QgQ0xBU1NfTkFNRV9GQURFJDEgPSAnZmFkZSc7XHJcbiAgY29uc3QgQ0xBU1NfTkFNRV9TSE9XJDEgPSAnc2hvdyc7XHJcbiAgY29uc3QgQ0xBU1NfRFJPUERPV04gPSAnZHJvcGRvd24nO1xyXG4gIGNvbnN0IFNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSA9ICcuZHJvcGRvd24tdG9nZ2xlJztcclxuICBjb25zdCBTRUxFQ1RPUl9EUk9QRE9XTl9NRU5VID0gJy5kcm9wZG93bi1tZW51JztcclxuICBjb25zdCBOT1RfU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFID0gYDpub3QoJHtTRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEV9KWA7XHJcbiAgY29uc3QgU0VMRUNUT1JfVEFCX1BBTkVMID0gJy5saXN0LWdyb3VwLCAubmF2LCBbcm9sZT1cInRhYmxpc3RcIl0nO1xyXG4gIGNvbnN0IFNFTEVDVE9SX09VVEVSID0gJy5uYXYtaXRlbSwgLmxpc3QtZ3JvdXAtaXRlbSc7XHJcbiAgY29uc3QgU0VMRUNUT1JfSU5ORVIgPSBgLm5hdi1saW5rJHtOT1RfU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFfSwgLmxpc3QtZ3JvdXAtaXRlbSR7Tk9UX1NFTEVDVE9SX0RST1BET1dOX1RPR0dMRX0sIFtyb2xlPVwidGFiXCJdJHtOT1RfU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFfWA7XHJcbiAgY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEUgPSAnW2RhdGEtYnMtdG9nZ2xlPVwidGFiXCJdLCBbZGF0YS1icy10b2dnbGU9XCJwaWxsXCJdLCBbZGF0YS1icy10b2dnbGU9XCJsaXN0XCJdJzsgLy8gVE9ETzogY291bGQgb25seSBiZSBgdGFiYCBpbiB2NlxyXG4gIGNvbnN0IFNFTEVDVE9SX0lOTkVSX0VMRU0gPSBgJHtTRUxFQ1RPUl9JTk5FUn0sICR7U0VMRUNUT1JfREFUQV9UT0dHTEV9YDtcclxuICBjb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRV9BQ1RJVkUgPSBgLiR7Q0xBU1NfTkFNRV9BQ1RJVkV9W2RhdGEtYnMtdG9nZ2xlPVwidGFiXCJdLCAuJHtDTEFTU19OQU1FX0FDVElWRX1bZGF0YS1icy10b2dnbGU9XCJwaWxsXCJdLCAuJHtDTEFTU19OQU1FX0FDVElWRX1bZGF0YS1icy10b2dnbGU9XCJsaXN0XCJdYDtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxyXG4gICAqL1xyXG5cclxuICBjbGFzcyBUYWIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQpIHtcclxuICAgICAgc3VwZXIoZWxlbWVudCk7XHJcbiAgICAgIHRoaXMuX3BhcmVudCA9IHRoaXMuX2VsZW1lbnQuY2xvc2VzdChTRUxFQ1RPUl9UQUJfUEFORUwpO1xyXG4gICAgICBpZiAoIXRoaXMuX3BhcmVudCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgICAvLyBUT0RPOiBzaG91bGQgdGhyb3cgZXhjZXB0aW9uIGluIHY2XHJcbiAgICAgICAgLy8gdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtlbGVtZW50Lm91dGVySFRNTH0gaGFzIG5vdCBhIHZhbGlkIHBhcmVudCAke1NFTEVDVE9SX0lOTkVSX0VMRU19YClcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU2V0IHVwIGluaXRpYWwgYXJpYSBhdHRyaWJ1dGVzXHJcbiAgICAgIHRoaXMuX3NldEluaXRpYWxBdHRyaWJ1dGVzKHRoaXMuX3BhcmVudCwgdGhpcy5fZ2V0Q2hpbGRyZW4oKSk7XHJcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9LRVlET1dOLCBldmVudCA9PiB0aGlzLl9rZXlkb3duKGV2ZW50KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gR2V0dGVyc1xyXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xyXG4gICAgICByZXR1cm4gTkFNRSQxO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFB1YmxpY1xyXG4gICAgc2hvdygpIHtcclxuICAgICAgLy8gU2hvd3MgdGhpcyBlbGVtIGFuZCBkZWFjdGl2YXRlIHRoZSBhY3RpdmUgc2libGluZyBpZiBleGlzdHNcclxuICAgICAgY29uc3QgaW5uZXJFbGVtID0gdGhpcy5fZWxlbWVudDtcclxuICAgICAgaWYgKHRoaXMuX2VsZW1Jc0FjdGl2ZShpbm5lckVsZW0pKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBTZWFyY2ggZm9yIGFjdGl2ZSB0YWIgb24gc2FtZSBwYXJlbnQgdG8gZGVhY3RpdmF0ZSBpdFxyXG4gICAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9nZXRBY3RpdmVFbGVtKCk7XHJcbiAgICAgIGNvbnN0IGhpZGVFdmVudCA9IGFjdGl2ZSA/IEV2ZW50SGFuZGxlci50cmlnZ2VyKGFjdGl2ZSwgRVZFTlRfSElERSQxLCB7XHJcbiAgICAgICAgcmVsYXRlZFRhcmdldDogaW5uZXJFbGVtXHJcbiAgICAgIH0pIDogbnVsbDtcclxuICAgICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIoaW5uZXJFbGVtLCBFVkVOVF9TSE9XJDEsIHtcclxuICAgICAgICByZWxhdGVkVGFyZ2V0OiBhY3RpdmVcclxuICAgICAgfSk7XHJcbiAgICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCB8fCBoaWRlRXZlbnQgJiYgaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fZGVhY3RpdmF0ZShhY3RpdmUsIGlubmVyRWxlbSk7XHJcbiAgICAgIHRoaXMuX2FjdGl2YXRlKGlubmVyRWxlbSwgYWN0aXZlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQcml2YXRlXHJcbiAgICBfYWN0aXZhdGUoZWxlbWVudCwgcmVsYXRlZEVsZW0pIHtcclxuICAgICAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSk7XHJcbiAgICAgIHRoaXMuX2FjdGl2YXRlKFNlbGVjdG9yRW5naW5lLmdldEVsZW1lbnRGcm9tU2VsZWN0b3IoZWxlbWVudCkpOyAvLyBTZWFyY2ggYW5kIGFjdGl2YXRlL3Nob3cgdGhlIHByb3BlciBzZWN0aW9uXHJcblxyXG4gICAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcclxuICAgICAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSAhPT0gJ3RhYicpIHtcclxuICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1ckMSk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xyXG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5fdG9nZ2xlRHJvcERvd24oZWxlbWVudCwgdHJ1ZSk7XHJcbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIoZWxlbWVudCwgRVZFTlRfU0hPV04kMSwge1xyXG4gICAgICAgICAgcmVsYXRlZFRhcmdldDogcmVsYXRlZEVsZW1cclxuICAgICAgICB9KTtcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgZWxlbWVudCwgZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9GQURFJDEpKTtcclxuICAgIH1cclxuICAgIF9kZWFjdGl2YXRlKGVsZW1lbnQsIHJlbGF0ZWRFbGVtKSB7XHJcbiAgICAgIGlmICghZWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9BQ1RJVkUpO1xyXG4gICAgICBlbGVtZW50LmJsdXIoKTtcclxuICAgICAgdGhpcy5fZGVhY3RpdmF0ZShTZWxlY3RvckVuZ2luZS5nZXRFbGVtZW50RnJvbVNlbGVjdG9yKGVsZW1lbnQpKTsgLy8gU2VhcmNoIGFuZCBkZWFjdGl2YXRlIHRoZSBzaG93biBzZWN0aW9uIHRvb1xyXG5cclxuICAgICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdyb2xlJykgIT09ICd0YWInKSB7XHJcbiAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDEpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIGZhbHNlKTtcclxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcclxuICAgICAgICB0aGlzLl90b2dnbGVEcm9wRG93bihlbGVtZW50LCBmYWxzZSk7XHJcbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIoZWxlbWVudCwgRVZFTlRfSElEREVOJDEsIHtcclxuICAgICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHJlbGF0ZWRFbGVtXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIGVsZW1lbnQsIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRkFERSQxKSk7XHJcbiAgICB9XHJcbiAgICBfa2V5ZG93bihldmVudCkge1xyXG4gICAgICBpZiAoIVtBUlJPV19MRUZUX0tFWSwgQVJST1dfUklHSFRfS0VZLCBBUlJPV19VUF9LRVksIEFSUk9XX0RPV05fS0VZLCBIT01FX0tFWSwgRU5EX0tFWV0uaW5jbHVkZXMoZXZlbnQua2V5KSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTsgLy8gc3RvcFByb3BhZ2F0aW9uL3ByZXZlbnREZWZhdWx0IGJvdGggYWRkZWQgdG8gc3VwcG9ydCB1cC9kb3duIGtleXMgd2l0aG91dCBzY3JvbGxpbmcgdGhlIHBhZ2VcclxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl9nZXRDaGlsZHJlbigpLmZpbHRlcihlbGVtZW50ID0+ICFpc0Rpc2FibGVkKGVsZW1lbnQpKTtcclxuICAgICAgbGV0IG5leHRBY3RpdmVFbGVtZW50O1xyXG4gICAgICBpZiAoW0hPTUVfS0VZLCBFTkRfS0VZXS5pbmNsdWRlcyhldmVudC5rZXkpKSB7XHJcbiAgICAgICAgbmV4dEFjdGl2ZUVsZW1lbnQgPSBjaGlsZHJlbltldmVudC5rZXkgPT09IEhPTUVfS0VZID8gMCA6IGNoaWxkcmVuLmxlbmd0aCAtIDFdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGlzTmV4dCA9IFtBUlJPV19SSUdIVF9LRVksIEFSUk9XX0RPV05fS0VZXS5pbmNsdWRlcyhldmVudC5rZXkpO1xyXG4gICAgICAgIG5leHRBY3RpdmVFbGVtZW50ID0gZ2V0TmV4dEFjdGl2ZUVsZW1lbnQoY2hpbGRyZW4sIGV2ZW50LnRhcmdldCwgaXNOZXh0LCB0cnVlKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAobmV4dEFjdGl2ZUVsZW1lbnQpIHtcclxuICAgICAgICBuZXh0QWN0aXZlRWxlbWVudC5mb2N1cyh7XHJcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgVGFiLmdldE9yQ3JlYXRlSW5zdGFuY2UobmV4dEFjdGl2ZUVsZW1lbnQpLnNob3coKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2dldENoaWxkcmVuKCkge1xyXG4gICAgICAvLyBjb2xsZWN0aW9uIG9mIGlubmVyIGVsZW1lbnRzXHJcbiAgICAgIHJldHVybiBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0lOTkVSX0VMRU0sIHRoaXMuX3BhcmVudCk7XHJcbiAgICB9XHJcbiAgICBfZ2V0QWN0aXZlRWxlbSgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2dldENoaWxkcmVuKCkuZmluZChjaGlsZCA9PiB0aGlzLl9lbGVtSXNBY3RpdmUoY2hpbGQpKSB8fCBudWxsO1xyXG4gICAgfVxyXG4gICAgX3NldEluaXRpYWxBdHRyaWJ1dGVzKHBhcmVudCwgY2hpbGRyZW4pIHtcclxuICAgICAgdGhpcy5fc2V0QXR0cmlidXRlSWZOb3RFeGlzdHMocGFyZW50LCAncm9sZScsICd0YWJsaXN0Jyk7XHJcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcclxuICAgICAgICB0aGlzLl9zZXRJbml0aWFsQXR0cmlidXRlc09uQ2hpbGQoY2hpbGQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBfc2V0SW5pdGlhbEF0dHJpYnV0ZXNPbkNoaWxkKGNoaWxkKSB7XHJcbiAgICAgIGNoaWxkID0gdGhpcy5fZ2V0SW5uZXJFbGVtZW50KGNoaWxkKTtcclxuICAgICAgY29uc3QgaXNBY3RpdmUgPSB0aGlzLl9lbGVtSXNBY3RpdmUoY2hpbGQpO1xyXG4gICAgICBjb25zdCBvdXRlckVsZW0gPSB0aGlzLl9nZXRPdXRlckVsZW1lbnQoY2hpbGQpO1xyXG4gICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCBpc0FjdGl2ZSk7XHJcbiAgICAgIGlmIChvdXRlckVsZW0gIT09IGNoaWxkKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0QXR0cmlidXRlSWZOb3RFeGlzdHMob3V0ZXJFbGVtLCAncm9sZScsICdwcmVzZW50YXRpb24nKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWlzQWN0aXZlKSB7XHJcbiAgICAgICAgY2hpbGQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX3NldEF0dHJpYnV0ZUlmTm90RXhpc3RzKGNoaWxkLCAncm9sZScsICd0YWInKTtcclxuXHJcbiAgICAgIC8vIHNldCBhdHRyaWJ1dGVzIHRvIHRoZSByZWxhdGVkIHBhbmVsIHRvb1xyXG4gICAgICB0aGlzLl9zZXRJbml0aWFsQXR0cmlidXRlc09uVGFyZ2V0UGFuZWwoY2hpbGQpO1xyXG4gICAgfVxyXG4gICAgX3NldEluaXRpYWxBdHRyaWJ1dGVzT25UYXJnZXRQYW5lbChjaGlsZCkge1xyXG4gICAgICBjb25zdCB0YXJnZXQgPSBTZWxlY3RvckVuZ2luZS5nZXRFbGVtZW50RnJvbVNlbGVjdG9yKGNoaWxkKTtcclxuICAgICAgaWYgKCF0YXJnZXQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fc2V0QXR0cmlidXRlSWZOb3RFeGlzdHModGFyZ2V0LCAncm9sZScsICd0YWJwYW5lbCcpO1xyXG4gICAgICBpZiAoY2hpbGQuaWQpIHtcclxuICAgICAgICB0aGlzLl9zZXRBdHRyaWJ1dGVJZk5vdEV4aXN0cyh0YXJnZXQsICdhcmlhLWxhYmVsbGVkYnknLCBgJHtjaGlsZC5pZH1gKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3RvZ2dsZURyb3BEb3duKGVsZW1lbnQsIG9wZW4pIHtcclxuICAgICAgY29uc3Qgb3V0ZXJFbGVtID0gdGhpcy5fZ2V0T3V0ZXJFbGVtZW50KGVsZW1lbnQpO1xyXG4gICAgICBpZiAoIW91dGVyRWxlbS5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfRFJPUERPV04pKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHRvZ2dsZSA9IChzZWxlY3RvciwgY2xhc3NOYW1lKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoc2VsZWN0b3IsIG91dGVyRWxlbSk7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShjbGFzc05hbWUsIG9wZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgICAgdG9nZ2xlKFNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSwgQ0xBU1NfTkFNRV9BQ1RJVkUpO1xyXG4gICAgICB0b2dnbGUoU0VMRUNUT1JfRFJPUERPV05fTUVOVSwgQ0xBU1NfTkFNRV9TSE9XJDEpO1xyXG4gICAgICBvdXRlckVsZW0uc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgb3Blbik7XHJcbiAgICB9XHJcbiAgICBfc2V0QXR0cmlidXRlSWZOb3RFeGlzdHMoZWxlbWVudCwgYXR0cmlidXRlLCB2YWx1ZSkge1xyXG4gICAgICBpZiAoIWVsZW1lbnQuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZSkpIHtcclxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2VsZW1Jc0FjdGl2ZShlbGVtKSB7XHJcbiAgICAgIHJldHVybiBlbGVtLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0FDVElWRSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVHJ5IHRvIGdldCB0aGUgaW5uZXIgZWxlbWVudCAodXN1YWxseSB0aGUgLm5hdi1saW5rKVxyXG4gICAgX2dldElubmVyRWxlbWVudChlbGVtKSB7XHJcbiAgICAgIHJldHVybiBlbGVtLm1hdGNoZXMoU0VMRUNUT1JfSU5ORVJfRUxFTSkgPyBlbGVtIDogU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9JTk5FUl9FTEVNLCBlbGVtKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUcnkgdG8gZ2V0IHRoZSBvdXRlciBlbGVtZW50ICh1c3VhbGx5IHRoZSAubmF2LWl0ZW0pXHJcbiAgICBfZ2V0T3V0ZXJFbGVtZW50KGVsZW0pIHtcclxuICAgICAgcmV0dXJuIGVsZW0uY2xvc2VzdChTRUxFQ1RPUl9PVVRFUikgfHwgZWxlbTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTdGF0aWNcclxuICAgIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBUYWIuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKTtcclxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRhdGFbY29uZmlnXSA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5zdGFydHNXaXRoKCdfJykgfHwgY29uZmlnID09PSAnY29uc3RydWN0b3InKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkYXRhW2NvbmZpZ10oKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxyXG4gICAqL1xyXG5cclxuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSwgZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICBpZiAoWydBJywgJ0FSRUEnXS5pbmNsdWRlcyh0aGlzLnRhZ05hbWUpKSB7XHJcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNEaXNhYmxlZCh0aGlzKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBUYWIuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKS5zaG93KCk7XHJcbiAgfSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgb24gZm9jdXNcclxuICAgKi9cclxuICBFdmVudEhhbmRsZXIub24od2luZG93LCBFVkVOVF9MT0FEX0RBVEFfQVBJLCAoKSA9PiB7XHJcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9EQVRBX1RPR0dMRV9BQ1RJVkUpKSB7XHJcbiAgICAgIFRhYi5nZXRPckNyZWF0ZUluc3RhbmNlKGVsZW1lbnQpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIC8qKlxyXG4gICAqIGpRdWVyeVxyXG4gICAqL1xyXG5cclxuICBkZWZpbmVKUXVlcnlQbHVnaW4oVGFiKTtcclxuXHJcbiAgLyoqXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKiBCb290c3RyYXAgdG9hc3QuanNcclxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqL1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RhbnRzXHJcbiAgICovXHJcblxyXG4gIGNvbnN0IE5BTUUgPSAndG9hc3QnO1xyXG4gIGNvbnN0IERBVEFfS0VZID0gJ2JzLnRvYXN0JztcclxuICBjb25zdCBFVkVOVF9LRVkgPSBgLiR7REFUQV9LRVl9YDtcclxuICBjb25zdCBFVkVOVF9NT1VTRU9WRVIgPSBgbW91c2VvdmVyJHtFVkVOVF9LRVl9YDtcclxuICBjb25zdCBFVkVOVF9NT1VTRU9VVCA9IGBtb3VzZW91dCR7RVZFTlRfS0VZfWA7XHJcbiAgY29uc3QgRVZFTlRfRk9DVVNJTiA9IGBmb2N1c2luJHtFVkVOVF9LRVl9YDtcclxuICBjb25zdCBFVkVOVF9GT0NVU09VVCA9IGBmb2N1c291dCR7RVZFTlRfS0VZfWA7XHJcbiAgY29uc3QgRVZFTlRfSElERSA9IGBoaWRlJHtFVkVOVF9LRVl9YDtcclxuICBjb25zdCBFVkVOVF9ISURERU4gPSBgaGlkZGVuJHtFVkVOVF9LRVl9YDtcclxuICBjb25zdCBFVkVOVF9TSE9XID0gYHNob3cke0VWRU5UX0tFWX1gO1xyXG4gIGNvbnN0IEVWRU5UX1NIT1dOID0gYHNob3duJHtFVkVOVF9LRVl9YDtcclxuICBjb25zdCBDTEFTU19OQU1FX0ZBREUgPSAnZmFkZSc7XHJcbiAgY29uc3QgQ0xBU1NfTkFNRV9ISURFID0gJ2hpZGUnOyAvLyBAZGVwcmVjYXRlZCAtIGtlcHQgaGVyZSBvbmx5IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxyXG4gIGNvbnN0IENMQVNTX05BTUVfU0hPVyA9ICdzaG93JztcclxuICBjb25zdCBDTEFTU19OQU1FX1NIT1dJTkcgPSAnc2hvd2luZyc7XHJcbiAgY29uc3QgRGVmYXVsdFR5cGUgPSB7XHJcbiAgICBhbmltYXRpb246ICdib29sZWFuJyxcclxuICAgIGF1dG9oaWRlOiAnYm9vbGVhbicsXHJcbiAgICBkZWxheTogJ251bWJlcidcclxuICB9O1xyXG4gIGNvbnN0IERlZmF1bHQgPSB7XHJcbiAgICBhbmltYXRpb246IHRydWUsXHJcbiAgICBhdXRvaGlkZTogdHJ1ZSxcclxuICAgIGRlbGF5OiA1MDAwXHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxyXG4gICAqL1xyXG5cclxuICBjbGFzcyBUb2FzdCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XHJcbiAgICAgIHN1cGVyKGVsZW1lbnQsIGNvbmZpZyk7XHJcbiAgICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsO1xyXG4gICAgICB0aGlzLl9oYXNNb3VzZUludGVyYWN0aW9uID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuX2hhc0tleWJvYXJkSW50ZXJhY3Rpb24gPSBmYWxzZTtcclxuICAgICAgdGhpcy5fc2V0TGlzdGVuZXJzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gR2V0dGVyc1xyXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xyXG4gICAgICByZXR1cm4gRGVmYXVsdDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XHJcbiAgICAgIHJldHVybiBEZWZhdWx0VHlwZTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcclxuICAgICAgcmV0dXJuIE5BTUU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHVibGljXHJcbiAgICBzaG93KCkge1xyXG4gICAgICBjb25zdCBzaG93RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XKTtcclxuICAgICAgaWYgKHNob3dFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xyXG4gICAgICBpZiAodGhpcy5fY29uZmlnLmFuaW1hdGlvbikge1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0ZBREUpO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1dJTkcpO1xyXG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOKTtcclxuICAgICAgICB0aGlzLl9tYXliZVNjaGVkdWxlSGlkZSgpO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9ISURFKTsgLy8gQGRlcHJlY2F0ZWRcclxuICAgICAgcmVmbG93KHRoaXMuX2VsZW1lbnQpO1xyXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XLCBDTEFTU19OQU1FX1NIT1dJTkcpO1xyXG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCB0aGlzLl9lbGVtZW50LCB0aGlzLl9jb25maWcuYW5pbWF0aW9uKTtcclxuICAgIH1cclxuICAgIGhpZGUoKSB7XHJcbiAgICAgIGlmICghdGhpcy5pc1Nob3duKCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgaGlkZUV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERSk7XHJcbiAgICAgIGlmIChoaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcclxuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9ISURFKTsgLy8gQGRlcHJlY2F0ZWRcclxuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XSU5HLCBDTEFTU19OQU1FX1NIT1cpO1xyXG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJRERFTik7XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1dJTkcpO1xyXG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCB0aGlzLl9lbGVtZW50LCB0aGlzLl9jb25maWcuYW5pbWF0aW9uKTtcclxuICAgIH1cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xyXG4gICAgICBpZiAodGhpcy5pc1Nob3duKCkpIHtcclxuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XKTtcclxuICAgICAgfVxyXG4gICAgICBzdXBlci5kaXNwb3NlKCk7XHJcbiAgICB9XHJcbiAgICBpc1Nob3duKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQcml2YXRlXHJcblxyXG4gICAgX21heWJlU2NoZWR1bGVIaWRlKCkge1xyXG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5hdXRvaGlkZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5faGFzTW91c2VJbnRlcmFjdGlvbiB8fCB0aGlzLl9oYXNLZXlib2FyZEludGVyYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICB0aGlzLmhpZGUoKTtcclxuICAgICAgfSwgdGhpcy5fY29uZmlnLmRlbGF5KTtcclxuICAgIH1cclxuICAgIF9vbkludGVyYWN0aW9uKGV2ZW50LCBpc0ludGVyYWN0aW5nKSB7XHJcbiAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xyXG4gICAgICAgIGNhc2UgJ21vdXNlb3Zlcic6XHJcbiAgICAgICAgY2FzZSAnbW91c2VvdXQnOlxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9oYXNNb3VzZUludGVyYWN0aW9uID0gaXNJbnRlcmFjdGluZztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAnZm9jdXNpbic6XHJcbiAgICAgICAgY2FzZSAnZm9jdXNvdXQnOlxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9oYXNLZXlib2FyZEludGVyYWN0aW9uID0gaXNJbnRlcmFjdGluZztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGlzSW50ZXJhY3RpbmcpIHtcclxuICAgICAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgbmV4dEVsZW1lbnQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xyXG4gICAgICBpZiAodGhpcy5fZWxlbWVudCA9PT0gbmV4dEVsZW1lbnQgfHwgdGhpcy5fZWxlbWVudC5jb250YWlucyhuZXh0RWxlbWVudCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fbWF5YmVTY2hlZHVsZUhpZGUoKTtcclxuICAgIH1cclxuICAgIF9zZXRMaXN0ZW5lcnMoKSB7XHJcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9NT1VTRU9WRVIsIGV2ZW50ID0+IHRoaXMuX29uSW50ZXJhY3Rpb24oZXZlbnQsIHRydWUpKTtcclxuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFT1VULCBldmVudCA9PiB0aGlzLl9vbkludGVyYWN0aW9uKGV2ZW50LCBmYWxzZSkpO1xyXG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfRk9DVVNJTiwgZXZlbnQgPT4gdGhpcy5fb25JbnRlcmFjdGlvbihldmVudCwgdHJ1ZSkpO1xyXG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfRk9DVVNPVVQsIGV2ZW50ID0+IHRoaXMuX29uSW50ZXJhY3Rpb24oZXZlbnQsIGZhbHNlKSk7XHJcbiAgICB9XHJcbiAgICBfY2xlYXJUaW1lb3V0KCkge1xyXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XHJcbiAgICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFN0YXRpY1xyXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IFRvYXN0LmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcclxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZGF0YVtjb25maWddKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxyXG4gICAqL1xyXG5cclxuICBlbmFibGVEaXNtaXNzVHJpZ2dlcihUb2FzdCk7XHJcblxyXG4gIC8qKlxyXG4gICAqIGpRdWVyeVxyXG4gICAqL1xyXG5cclxuICBkZWZpbmVKUXVlcnlQbHVnaW4oVG9hc3QpO1xyXG5cclxuICAvKipcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqIEJvb3RzdHJhcCBpbmRleC51bWQuanNcclxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqL1xyXG5cclxuICBjb25zdCBpbmRleF91bWQgPSB7XHJcbiAgICBBbGVydCxcclxuICAgIEJ1dHRvbixcclxuICAgIENhcm91c2VsLFxyXG4gICAgQ29sbGFwc2UsXHJcbiAgICBEcm9wZG93bixcclxuICAgIE1vZGFsLFxyXG4gICAgT2ZmY2FudmFzLFxyXG4gICAgUG9wb3ZlcixcclxuICAgIFNjcm9sbFNweSxcclxuICAgIFRhYixcclxuICAgIFRvYXN0LFxyXG4gICAgVG9vbHRpcFxyXG4gIH07XHJcblxyXG4gIHJldHVybiBpbmRleF91bWQ7XHJcblxyXG59KSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJvb3RzdHJhcC5idW5kbGUuanMubWFwXHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bootstrap/dist/js/bootstrap.bundle.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bootstrap/dist/css/bootstrap.min.css":
/*!***********************************************************!*\
  !*** ./node_modules/bootstrap/dist/css/bootstrap.min.css ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"69c92abc829b\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL2Rpc3QvY3NzL2Jvb3RzdHJhcC5taW4uY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksS0FBVSxFQUFFLEVBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL2Rpc3QvY3NzL2Jvb3RzdHJhcC5taW4uY3NzP2JmMjUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCI2OWM5MmFiYzgyOWJcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bootstrap/dist/css/bootstrap.min.css\n");

/***/ })

};
;